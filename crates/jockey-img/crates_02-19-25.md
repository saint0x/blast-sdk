# Jockey Image

Generated: 02-19-2025 at 12:15:07

## Repository Structure

```
crates
│   ├── blast-core
│       └── src
│       │   ├── lib.rs
│       │   ├── error.rs
│           └── sync
│               └── types.rs
│   ├── blast-daemon
│   │   ├── Cargo.toml
│       └── src
│       │   ├── ipc.rs
│       │   ├── lib.rs
│       │   ├── security
│           └── state.rs
│   ├── blast-sync
│       └── src
│           └── manifest.rs
│   ├── blast-resolver
│       └── Cargo.toml
│   ├── blast-cache
│   │   ├── src
│   │   │   ├── index.rs
│   │   │   ├── compression.rs
│   │   │   ├── disk.rs
│   │   │   ├── lru.rs
│   │       └── memory.rs
│       └── Cargo.toml
│   ├── blast-cli
│   │   ├── Cargo.toml
│       └── jockey-img
    └── blast-image
    │   ├── Cargo.toml
        └── src
        │   ├── layer.rs
        │   ├── manifest.rs
        │   ├── packages.rs
        │   ├── hooks.rs
        │   ├── lib.rs
        │   ├── validation.rs
            └── error.rs
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-daemon/Cargo.toml

```toml
[package]
name = "blast-daemon"
version = "0.1.0"
edition = "2021"
authors = ["Blast Contributors"]
description = "Daemon service for the Blast Python environment manager"
license = "MIT"

[dependencies]
# Internal dependencies
blast-core = { path = "../blast-core", features = ["serde-support"] }
blast-resolver = { path = "../blast-resolver" }
blast-cache = { path = "../blast-cache" }
blast-image = { path = "../blast-image" }

# Error handling
thiserror = { workspace = true }
anyhow = "1.0"

# Serialization
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# Async runtime
tokio = { version = "1.0", features = ["full"] }
tokio-stream = "0.1"
async-trait = "0.1"

# File system monitoring
notify = "6.1"
walkdir = "2.4.0"

# IPC
ipc-channel = "0.16"

# Logging
tracing = "0.1"
tracing-subscriber = { workspace = true }

# Transaction support
uuid = { version = "1.0", features = ["v4", "serde"] }
chrono = { version = "0.4", features = ["serde"] }

# Graph algorithms
petgraph = "0.6"
sysinfo = "0.33.1"

# Platform-specific dependencies
[target.'cfg(target_os = "linux")'.dependencies]
caps = "0.5.5"
nix = { version = "0.27.1", features = ["sched", "mount"] }
libseccomp = "0.3.0"

[target.'cfg(target_os = "windows")'.dependencies]
windows-sys = { version = "0.48", features = ["Win32_Security_Isolation"] }

[target.'cfg(target_os = "macos")'.dependencies]
security-framework = "2.9.2"

# Additional dependencies
toml = "0.8"
sha2 = "0.10"
hex = "0.4"

[dev-dependencies]
tokio-test = "0.4"
tempfile = "3.0"
mockall = { workspace = true }
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-daemon/src/transaction.rs

```rs
use std::collections::HashMap;
use std::path::PathBuf;
use tokio::sync::RwLock;
use uuid::Uuid;
use chrono::{DateTime, Utc};
use tracing::{info, warn};
use std::sync::Arc;

use blast_core::{
    package::Package,
    error::BlastError,
    state::{EnvironmentState, StateVerification, StateIssue},
    version_history::{VersionEvent, VersionImpact, VersionChangeAnalysis},
    sync::IssueSeverity,
};

use crate::{
    state::{StateManager, Checkpoint},
    error::DaemonError,
    DaemonResult,
};

#[derive(Debug, Clone)]
pub enum TransactionOperation {
    Install(Package),
    Uninstall(Package),
    Update { from: Package, to: Package },
    AddEnvironment {
        name: String,
        state: EnvironmentState,
    },
    RemoveEnvironment {
        name: String,
    },
}

#[derive(Debug, Clone)]
pub struct TransactionContext {
    pub id: Uuid,
    pub operations: Vec<TransactionOperation>,
    pub state_before: HashMap<String, Package>,
    pub created_at: DateTime<Utc>,
    pub status: TransactionStatus,
    pub checkpoint_id: Option<Uuid>,
    pub metrics: TransactionMetrics,
    pub verification: Option<StateVerification>,
    pub description: String,
    pub state_manager: Arc<RwLock<StateManager>>,
}

#[derive(Debug, Clone)]
pub struct TransactionMetrics {
    pub duration: Option<std::time::Duration>,
    pub memory_usage: u64,
    pub cpu_usage: f32,
    pub network_operations: u32,
    pub cache_hits: u32,
    pub dependencies_checked: u32,
}

#[derive(Debug, Clone)]
pub enum TransactionStatus {
    Pending,
    InProgress,
    Committed,
    RolledBack,
    Failed(String),
}

impl TransactionContext {
    pub fn new(description: String, state_manager: Arc<RwLock<StateManager>>) -> Self {
        Self {
            id: Uuid::new_v4(),
            operations: Vec::new(),
            state_before: HashMap::new(),
            created_at: Utc::now(),
            status: TransactionStatus::Pending,
            checkpoint_id: None,
            metrics: TransactionMetrics {
                duration: None,
                memory_usage: 0,
                cpu_usage: 0.0,
                network_operations: 0,
                cache_hits: 0,
                dependencies_checked: 0,
            },
            verification: None,
            description,
            state_manager,
        }
    }

    pub fn add_operation(&mut self, operation: TransactionOperation) -> DaemonResult<()> {
        match self.status {
            TransactionStatus::Pending => {
                // Analyze version impact for updates
                if let TransactionOperation::Update { ref from, ref to } = operation {
                    let analysis = VersionChangeAnalysis {
                        impact: VersionImpact::from_version_change(from.version(), to.version()),
                        affected_dependents: Default::default(),
                        breaking_changes: Vec::new(),
                        compatibility_issues: Vec::new(),
                    };

                    if analysis.impact.is_breaking() {
                        warn!(
                            "Adding potentially unsafe update operation: {} {} -> {}",
                            from.id().name(),
                            from.id().version(),
                            to.id().version()
                        );
                    }
                }

                self.operations.push(operation);
                Ok(())
            }
            _ => Err(BlastError::environment(
                "Transaction is no longer pending"
            ).into()),
        }
    }

    pub fn set_state_before(&mut self, packages: HashMap<String, Package>) {
        self.state_before = packages;
    }

    pub fn update_metrics(&mut self, metrics: TransactionMetrics) {
        self.metrics = metrics;
    }

    pub fn set_verification(&mut self, verification: StateVerification) {
        self.verification = Some(verification);
    }
}

#[derive(Debug)]
pub struct TransactionManager {
    active_transactions: RwLock<HashMap<Uuid, TransactionContext>>,
    state_manager: RwLock<StateManager>,
}

impl Clone for TransactionManager {
    fn clone(&self) -> Self {
        // Create new RwLocks with empty contents
        Self {
            active_transactions: RwLock::new(HashMap::new()),
            state_manager: RwLock::new(StateManager::new(PathBuf::from("environments/default"))),
        }
    }
}

impl TransactionManager {
    pub fn new(initial_state: EnvironmentState) -> Self {
        let state_manager = StateManager::new(PathBuf::from("environments/default"));
        let state_manager = RwLock::new(state_manager);
        
        Self {
            active_transactions: RwLock::new(HashMap::new()),
            state_manager,
        }
    }

    pub async fn list_active_transactions(&self) -> DaemonResult<HashMap<Uuid, TransactionContext>> {
        Ok(self.active_transactions.read().await.clone())
    }

    pub async fn begin_transaction(&self, description: String) -> DaemonResult<TransactionContext> {
        let transaction_id = Uuid::new_v4();
        let state_manager = Arc::new(RwLock::new(StateManager::new(PathBuf::from("environments/default"))));
        
        // Create initial checkpoint
        {
            let state_manager_guard = state_manager.write().await;
            state_manager_guard.create_checkpoint(
                Uuid::new_v4(),
                format!("Transaction start: {}", description),
                Some(transaction_id),
            ).await?;
        }

        Ok(TransactionContext {
            id: transaction_id,
            description,
            state_manager,
            operations: Vec::new(),
            state_before: HashMap::new(),
            created_at: Utc::now(),
            status: TransactionStatus::Pending,
            checkpoint_id: None,
            metrics: TransactionMetrics {
                duration: None,
                memory_usage: 0,
                cpu_usage: 0.0,
                network_operations: 0,
                cache_hits: 0,
                dependencies_checked: 0,
            },
            verification: None,
        })
    }

    pub async fn execute_transaction<F, T>(&self, description: String, f: F) -> DaemonResult<T>
    where
        F: FnOnce(TransactionContext) -> std::pin::Pin<Box<dyn std::future::Future<Output = DaemonResult<T>> + Send>>,
    {
        let ctx = self.begin_transaction(description).await?;
        let transaction_id = ctx.id;

        match f(ctx).await {
            Ok(result) => {
                // Create success checkpoint
                let state_manager = self.state_manager.write().await;
                state_manager.create_checkpoint(
                    Uuid::new_v4(),
                    "Transaction completed successfully".to_string(),
                    Some(transaction_id),
                ).await?;
                Ok(result)
            }
            Err(e) => {
                // Restore to initial checkpoint
                let state_manager = self.state_manager.write().await;
                let checkpoints = state_manager.list_checkpoints().await?;
                if let Some(initial) = checkpoints.iter().find(|c| c.transaction_id == Some(transaction_id)) {
                    state_manager.restore_checkpoint(&initial.id.to_string()).await?;
                }
                Err(e)
            }
        }
    }

    pub async fn commit_transaction(&self, id: Uuid) -> DaemonResult<()> {
        let mut transactions = self.active_transactions.write().await;
        let txn = transactions.get_mut(&id)
            .ok_or_else(|| DaemonError::transaction("Transaction not found"))?;

        // Verify state before commit
        let verification = self.verify_transaction_state(txn).await?;
        txn.set_verification(verification.clone());

        if !verification.is_verified {
            let error_msg = verification.issues.iter()
                .map(|i| i.description.clone())
                .collect::<Vec<_>>()
                .join(", ");
            return Err(DaemonError::transaction(format!(
                "Transaction verification failed: {}", error_msg
            )));
        }

        // Update metrics before commit
        let metrics = self.collect_transaction_metrics(txn).await?;
        txn.update_metrics(metrics);

        // Perform commit
        let state_manager = self.state_manager.write().await;
        
        // Apply operations in order
        for op in &txn.operations {
            match op {
                TransactionOperation::Install(pkg) => {
                    let current_state = state_manager.get_current_state().await.map_err(|e| DaemonError::from(e))?;
                    let event = VersionEvent {
                        timestamp: Utc::now(),
                        from_version: None,
                        to_version: pkg.version().clone(),
                        impact: VersionImpact::None,
                        reason: format!("Installation via transaction {}", txn.id),
                        python_version: current_state.python_version.clone(),
                        is_direct: true,
                        affected_dependencies: Default::default(),
                        approved: true,
                        approved_by: None,
                        policy_snapshot: None,
                    };
                    state_manager.add_package_with_event(&pkg, event).await.map_err(|e| DaemonError::from(e))?;
                }
                TransactionOperation::Uninstall(pkg) => {
                    state_manager.remove_package(&pkg).await.map_err(|e| DaemonError::from(e))?;
                }
                TransactionOperation::Update { from, to } => {
                    let current_state = state_manager.get_current_state().await.map_err(|e| DaemonError::from(e))?;
                    let event = VersionEvent {
                        timestamp: Utc::now(),
                        from_version: Some(from.version().clone()),
                        to_version: to.version().clone(),
                        impact: VersionImpact::from_version_change(from.version(), to.version()),
                        reason: format!("Update via transaction {}", txn.id),
                        python_version: current_state.python_version.clone(),
                        is_direct: true,
                        affected_dependencies: Default::default(),
                        approved: true,
                        approved_by: None,
                        policy_snapshot: None,
                    };
                    state_manager.update_package_with_event(&from, &to, event).await.map_err(|e| DaemonError::from(e))?;
                }
                TransactionOperation::AddEnvironment { name, state } => {
                    state_manager.add_environment(name.clone(), state.clone()).await.map_err(|e| DaemonError::from(e))?;
                }
                TransactionOperation::RemoveEnvironment { name } => {
                    state_manager.remove_environment(name).await.map_err(|e| DaemonError::from(e))?;
                }
            }
        }

        // Create commit checkpoint
        let checkpoint_id = Uuid::new_v4();
        state_manager.create_checkpoint(
            checkpoint_id,
            format!("Transaction {} commit state", id),
            Some(id),
        ).await.map_err(|e| DaemonError::from(e))?;

        txn.status = TransactionStatus::Committed;
        txn.checkpoint_id = Some(checkpoint_id);

        Ok(())
    }

    async fn verify_transaction_state(&self, txn: &TransactionContext) -> DaemonResult<StateVerification> {
        let mut verification = StateVerification::default();
        
        // Get current state
        let current_state = self.get_current_state().await?;
        
        // Verify each operation
        for op in &txn.operations {
            match op {
                TransactionOperation::Install(pkg) => {
                    // Check if package is already installed
                    if current_state.packages.contains_key(pkg.id().name()) {
                        verification.add_issue(StateIssue {
                            description: format!("Package {} is already installed", pkg.id().name()),
                            severity: IssueSeverity::Critical,
                            context: None,
                            recommendation: Some(format!("Remove existing {} package first", pkg.id().name())),
                        });
                    }
                }
                TransactionOperation::Update { from, to: _ } => {
                    // Verify current version matches
                    if !current_state.packages.contains_key(from.id().name()) {
                        verification.add_issue(StateIssue {
                            description: format!(
                                "Package {} version {} not found",
                                from.id().name(),
                                from.id().version()
                            ),
                            severity: IssueSeverity::Critical,
                            context: None,
                            recommendation: Some("Install the correct version before updating".to_string()),
                        });
                    }
                }
                TransactionOperation::Uninstall(pkg) => {
                    // Verify package exists
                    if !current_state.packages.contains_key(pkg.id().name()) {
                        verification.add_issue(StateIssue {
                            description: format!("Package {} not found", pkg.id().name()),
                            severity: IssueSeverity::Critical,
                            context: None,
                            recommendation: Some("Verify package name and version".to_string()),
                        });
                    }
                }
                TransactionOperation::AddEnvironment { name, state: _ } => {
                    // Verify environment doesn't exist
                    if current_state.packages.contains_key(name) {
                        verification.add_issue(StateIssue {
                            description: format!("Environment {} already exists", name),
                            severity: IssueSeverity::Critical,
                            context: None,
                            recommendation: Some(format!("Choose a different name or remove existing environment {}", name)),
                        });
                    }
                }
                TransactionOperation::RemoveEnvironment { name } => {
                    // Verify environment exists
                    if !current_state.packages.contains_key(name) {
                        verification.add_issue(StateIssue {
                            description: format!("Environment {} not found", name),
                            severity: IssueSeverity::Critical,
                            context: None,
                            recommendation: Some(format!("Verify environment name {}", name)),
                        });
                    }
                }
            }
        }

        Ok(verification)
    }

    async fn collect_transaction_metrics(&self, txn: &TransactionContext) -> DaemonResult<TransactionMetrics> {
        // Get process stats
        let memory_usage = std::process::Command::new("ps")
            .args(&["-o", "rss=", "-p", &std::process::id().to_string()])
            .output()
            .map_err(|e| DaemonError::transaction(format!("Failed to get memory usage: {}", e)))?
            .stdout;
        
        let memory = String::from_utf8_lossy(&memory_usage)
            .trim()
            .parse::<u64>()
            .unwrap_or(0) * 1024; // Convert KB to bytes

        let cpu_usage = std::process::Command::new("ps")
            .args(&["-o", "%cpu=", "-p", &std::process::id().to_string()])
            .output()
            .map_err(|e| DaemonError::transaction(format!("Failed to get CPU usage: {}", e)))?
            .stdout;
        
        let cpu = String::from_utf8_lossy(&cpu_usage)
            .trim()
            .parse::<f32>()
            .unwrap_or(0.0);

        Ok(TransactionMetrics {
            duration: Some(Utc::now().signed_duration_since(txn.created_at).to_std().unwrap_or_default()),
            memory_usage: memory,
            cpu_usage: cpu,
            network_operations: txn.operations.len() as u32,
            cache_hits: 0,
            dependencies_checked: txn.operations.iter()
                .filter(|op| matches!(op, TransactionOperation::Install(_) | TransactionOperation::Update { .. }))
                .count() as u32,
        })
    }

    pub async fn rollback_transaction(&self, id: Uuid) -> DaemonResult<()> {
        let mut transactions = self.active_transactions.write().await;
        let mut ctx = transactions.remove(&id).ok_or_else(|| {
            DaemonError::transaction("Transaction not found")
        })?;

        if let Some(checkpoint_id) = ctx.checkpoint_id {
            let state_manager = self.state_manager.write().await;
            state_manager.restore_checkpoint(&checkpoint_id.to_string()).await.map_err(|e| DaemonError::from(e))?;
            ctx.status = TransactionStatus::RolledBack;
            info!("Transaction {} rolled back successfully", id);
            Ok(())
        } else {
            Err(DaemonError::transaction("No checkpoint found for rollback"))
        }
    }

    pub async fn get_current_state(&self) -> DaemonResult<EnvironmentState> {
        let state_manager = self.state_manager.read().await;
        state_manager.get_current_state().await.map_err(DaemonError::from)
    }

    pub async fn list_checkpoints(&self) -> DaemonResult<Vec<Checkpoint>> {
        let state_manager = self.state_manager.read().await;
        state_manager.list_checkpoints().await.map_err(DaemonError::from)
    }

    pub async fn get_checkpoint(&self, id: &str) -> DaemonResult<Option<Checkpoint>> {
        let state_manager = self.state_manager.read().await;
        state_manager.get_checkpoint(id).await.map_err(DaemonError::from)
    }

    pub async fn get_transaction(&self, id: Uuid) -> DaemonResult<Option<TransactionContext>> {
        Ok(self.active_transactions.read().await.get(&id).cloned())
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-daemon/src/ipc.rs

```rs
//! Inter-Process Communication for the daemon service

use std::sync::Arc;
use tokio::sync::{mpsc, Mutex};
use tracing::{error, info};

use crate::update::UpdateRequest;
use crate::DaemonResult;
use crate::update::UpdateType;

/// IPC server for handling client requests
pub struct IPCServer {
    receiver: Arc<Mutex<mpsc::Receiver<UpdateRequest>>>,
}

impl IPCServer {
    /// Create a new IPC server
    pub fn new(receiver: mpsc::Receiver<UpdateRequest>) -> Self {
        Self {
            receiver: Arc::new(Mutex::new(receiver)),
        }
    }

    /// Run the IPC server
    pub async fn run(&self) -> DaemonResult<()> {
        info!("Starting IPC server");

        loop {
            let mut receiver = self.receiver.lock().await;
            match receiver.recv().await {
                Some(request) => {
                    match &request.update_type {
                        UpdateType::PackageUpdate { package, .. } => {
                            info!("Processing update request for {}", package.name());
                        }
                        UpdateType::PackageInstall(package) => {
                            info!("Processing install request for {}", package.name());
                        }
                        UpdateType::PackageRemove(package) => {
                            info!("Processing remove request for {}", package.name());
                        }
                        UpdateType::EnvironmentSync => {
                            info!("Processing environment sync request");
                        }
                    }
                }
                None => {
                    error!("IPC channel closed");
                    break;
                }
            }
        }

        info!("IPC server stopped");
        Ok(())
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-daemon/src/security/audit.rs

```rs
use std::{
    collections::HashMap,
    path::PathBuf,
    sync::Arc,
    time::{SystemTime, UNIX_EPOCH},
};
use tokio::sync::Mutex;
use serde::{Serialize, Deserialize};
use blast_core::{
    error::{BlastError, BlastResult},
    security::{AuditRecord, AuditEvent, EventSeverity},
};

/// Audit logger for security events
pub struct AuditLogger {
    /// Log file path
    log_path: PathBuf,
    /// Pending records
    pending: Arc<Mutex<Vec<AuditRecord>>>,
    /// Event filters
    filters: HashMap<String, EventSeverity>,
}

/// Audit log entry
#[derive(Debug, Serialize, Deserialize)]
struct LogEntry {
    /// Timestamp in Unix seconds
    timestamp: u64,
    /// Event type
    event_type: String,
    /// Event severity
    severity: EventSeverity,
    /// Event details
    details: String,
    /// Related package if any
    package: Option<String>,
    /// Related environment if any
    environment: Option<String>,
    /// Additional metadata
    metadata: HashMap<String, String>,
}

impl AuditLogger {
    /// Create new audit logger
    pub fn new<P: Into<PathBuf>>(log_path: P) -> Self {
        Self {
            log_path: log_path.into(),
            pending: Arc::new(Mutex::new(Vec::new())),
            filters: HashMap::new(),
        }
    }

    /// Add event filter
    pub fn add_filter(&mut self, event_type: &str, min_severity: EventSeverity) {
        self.filters.insert(event_type.to_string(), min_severity);
    }

    /// Log audit event
    pub async fn log_event(&self, event: AuditEvent) -> BlastResult<()> {
        // Check if event should be filtered
        if let Some(min_severity) = self.filters.get(&event.event_type) {
            if event.severity < *min_severity {
                return Ok(());
            }
        }

        let timestamp = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs();

        let entry = LogEntry {
            timestamp,
            event_type: event.event_type,
            severity: event.severity,
            details: event.details,
            package: event.package,
            environment: event.environment,
            metadata: event.metadata,
        };

        // Add to pending records
        self.pending.lock().await.push(AuditRecord {
            timestamp,
            event_type: entry.event_type.clone(),
            severity: entry.severity,
            details: entry.details.clone(),
        });

        // Write to log file
        let log_line = serde_json::to_string(&entry)?;
        tokio::fs::OpenOptions::new()
            .create(true)
            .append(true)
            .open(&self.log_path)
            .await?
            .write_all(format!("{}\n", log_line).as_bytes())
            .await?;

        Ok(())
    }

    /// Get pending audit records
    pub async fn get_pending(&self) -> BlastResult<Vec<AuditRecord>> {
        Ok(self.pending.lock().await.clone())
    }

    /// Clear pending audit records
    pub async fn clear_pending(&self) -> BlastResult<()> {
        self.pending.lock().await.clear();
        Ok(())
    }

    /// Query audit log
    pub async fn query_log(&self, 
        start_time: Option<u64>,
        end_time: Option<u64>,
        min_severity: Option<EventSeverity>,
        event_types: Option<Vec<String>>,
    ) -> BlastResult<Vec<LogEntry>> {
        let content = tokio::fs::read_to_string(&self.log_path).await?;
        let mut entries: Vec<LogEntry> = content
            .lines()
            .filter_map(|line| serde_json::from_str(line).ok())
            .collect();

        // Apply filters
        if let Some(start) = start_time {
            entries.retain(|e| e.timestamp >= start);
        }
        if let Some(end) = end_time {
            entries.retain(|e| e.timestamp <= end);
        }
        if let Some(severity) = min_severity {
            entries.retain(|e| e.severity >= severity);
        }
        if let Some(types) = event_types {
            entries.retain(|e| types.contains(&e.event_type));
        }

        Ok(entries)
    }

    /// Start background flush task
    pub async fn start_flush_task(&self, interval: std::time::Duration) -> BlastResult<()> {
        let pending = self.pending.clone();
        
        tokio::spawn(async move {
            let mut interval = tokio::time::interval(interval);
            
            loop {
                interval.tick().await;
                pending.lock().await.clear();
            }
        });

        Ok(())
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-daemon/src/security/monitor.rs

```rs
use std::{
    collections::HashMap,
    sync::Arc,
    time::{Duration, Instant},
};
use tokio::sync::Mutex;
use sysinfo::{System, SystemExt, ProcessExt};
use blast_core::{
    error::{BlastError, BlastResult},
    security::{ResourceLimits, ResourceUsage},
};

/// Resource monitor for tracking environment resource usage
pub struct ResourceMonitor {
    /// System information
    sys: Arc<Mutex<System>>,
    /// Process ID to monitor
    pid: u32,
    /// Resource limits
    limits: ResourceLimits,
    /// Usage history
    history: Arc<Mutex<Vec<ResourceUsage>>>,
    /// Start time
    start_time: Instant,
}

impl ResourceMonitor {
    /// Create new resource monitor
    pub fn new(pid: u32, limits: ResourceLimits) -> Self {
        Self {
            sys: Arc::new(Mutex::new(System::new_all())),
            pid,
            limits,
            history: Arc::new(Mutex::new(Vec::new())),
            start_time: Instant::now(),
        }
    }

    /// Get current resource usage
    pub async fn get_usage(&self) -> BlastResult<ResourceUsage> {
        let mut sys = self.sys.lock().await;
        sys.refresh_all();

        let process = sys.process(self.pid as i32)
            .ok_or_else(|| BlastError::ProcessNotFound(self.pid))?;

        let usage = ResourceUsage {
            timestamp: Instant::now(),
            memory_bytes: process.memory() * 1024, // KB to bytes
            cpu_percent: process.cpu_usage(),
            disk_bytes_read: process.disk_usage().read_bytes,
            disk_bytes_written: process.disk_usage().written_bytes,
            network_bytes_rx: 0, // TODO: Implement network monitoring
            network_bytes_tx: 0,
        };

        // Store in history
        self.history.lock().await.push(usage.clone());

        Ok(usage)
    }

    /// Check if resource usage exceeds limits
    pub async fn check_limits(&self) -> BlastResult<bool> {
        let usage = self.get_usage().await?;
        
        // Check memory limit
        if let Some(limit) = self.limits.memory_bytes {
            if usage.memory_bytes > limit {
                return Ok(false);
            }
        }

        // Check CPU limit
        if let Some(limit) = self.limits.cpu_percent {
            if usage.cpu_percent > limit {
                return Ok(false);
            }
        }

        // Check disk read limit
        if let Some(limit) = self.limits.disk_bytes_read {
            if usage.disk_bytes_read > limit {
                return Ok(false);
            }
        }

        // Check disk write limit
        if let Some(limit) = self.limits.disk_bytes_written {
            if usage.disk_bytes_written > limit {
                return Ok(false);
            }
        }

        Ok(true)
    }

    /// Get resource usage history
    pub async fn get_history(&self) -> BlastResult<Vec<ResourceUsage>> {
        Ok(self.history.lock().await.clone())
    }

    /// Get average resource usage over time window
    pub async fn get_average_usage(&self, window: Duration) -> BlastResult<ResourceUsage> {
        let history = self.history.lock().await;
        let now = Instant::now();
        
        // Filter entries within time window
        let recent: Vec<_> = history.iter()
            .filter(|usage| now.duration_since(usage.timestamp) <= window)
            .collect();

        if recent.is_empty() {
            return Err(BlastError::NoDataAvailable);
        }

        // Calculate averages
        let avg_memory = recent.iter().map(|u| u.memory_bytes).sum::<u64>() / recent.len() as u64;
        let avg_cpu = recent.iter().map(|u| u.cpu_percent).sum::<f32>() / recent.len() as f32;
        let avg_disk_read = recent.iter().map(|u| u.disk_bytes_read).sum::<u64>() / recent.len() as u64;
        let avg_disk_write = recent.iter().map(|u| u.disk_bytes_written).sum::<u64>() / recent.len() as u64;

        Ok(ResourceUsage {
            timestamp: now,
            memory_bytes: avg_memory,
            cpu_percent: avg_cpu,
            disk_bytes_read: avg_disk_read,
            disk_bytes_written: avg_disk_write,
            network_bytes_rx: 0,
            network_bytes_tx: 0,
        })
    }

    /// Start background monitoring task
    pub async fn start_monitoring(&self, interval: Duration) -> BlastResult<()> {
        let sys = self.sys.clone();
        let history = self.history.clone();
        let pid = self.pid;

        tokio::spawn(async move {
            let mut interval = tokio::time::interval(interval);
            
            loop {
                interval.tick().await;
                
                let mut sys = sys.lock().await;
                sys.refresh_all();

                if let Some(process) = sys.process(pid as i32) {
                    let usage = ResourceUsage {
                        timestamp: Instant::now(),
                        memory_bytes: process.memory() * 1024,
                        cpu_percent: process.cpu_usage(),
                        disk_bytes_read: process.disk_usage().read_bytes,
                        disk_bytes_written: process.disk_usage().written_bytes,
                        network_bytes_rx: 0,
                        network_bytes_tx: 0,
                    };

                    history.lock().await.push(usage);
                }
            }
        });

        Ok(())
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-daemon/src/security/verify.rs

```rs
use std::collections::HashMap;
use chrono::Utc;
use reqwest::Client;
use serde::Deserialize;
use blast_core::{
    error::{BlastError, BlastResult},
    package::Package,
    security::{
        PackageVerification, SecurityPolicy, VerificationResult,
        SignatureInfo, Vulnerability, VulnerabilitySeverity,
        PolicyResult, PolicyViolation,
    },
};

/// Package verification implementation
pub struct PackageVerifier {
    /// HTTP client for API calls
    client: Client,
    /// Vulnerability database cache
    vulnerability_cache: HashMap<String, Vec<Vulnerability>>,
}

/// Vulnerability database response
#[derive(Debug, Deserialize)]
struct VulnerabilityResponse {
    vulnerabilities: Vec<VulnerabilityData>,
}

#[derive(Debug, Deserialize)]
struct VulnerabilityData {
    id: String,
    severity: String,
    description: String,
    affected_versions: Vec<String>,
    fixed_versions: Vec<String>,
    references: Vec<String>,
}

impl PackageVerifier {
    /// Create new package verifier
    pub fn new() -> Self {
        Self {
            client: Client::new(),
            vulnerability_cache: HashMap::new(),
        }
    }

    /// Verify package signature using GPG
    async fn verify_signature(&self, package: &Package) -> BlastResult<Option<SignatureInfo>> {
        // TODO: Implement actual GPG signature verification
        // For now, return a mock signature check
        Ok(Some(SignatureInfo {
            signature_type: "GPG".to_string(),
            key_id: "mock-key-id".to_string(),
            timestamp: Utc::now(),
            valid: true,
        }))
    }

    /// Check package source
    fn verify_source(&self, package: &Package, policy: &SecurityPolicy) -> BlastResult<bool> {
        // For PyPI packages, verify against allowed sources
        if let Some(source) = package.source() {
            Ok(policy.allowed_sources.iter().any(|s| source.starts_with(s)))
        } else {
            Ok(false)
        }
    }

    /// Fetch vulnerabilities from advisory database
    async fn fetch_vulnerabilities(&self, package: &Package) -> BlastResult<Vec<Vulnerability>> {
        // Check cache first
        if let Some(vulns) = self.vulnerability_cache.get(package.name()) {
            return Ok(vulns.clone());
        }

        // TODO: Implement actual vulnerability database API call
        // For now, return mock data for demonstration
        let vulns = vec![
            Vulnerability {
                id: "MOCK-2024-001".to_string(),
                severity: VulnerabilitySeverity::Low,
                description: "Mock vulnerability for testing".to_string(),
                affected_versions: vec!["<1.0.0".to_string()],
                fixed_versions: vec![">=1.0.0".to_string()],
                references: vec!["https://example.com/mock-vuln".to_string()],
            }
        ];

        Ok(vulns)
    }
}

#[async_trait::async_trait]
impl PackageVerification for PackageVerifier {
    async fn verify_package(&self, package: &Package) -> BlastResult<VerificationResult> {
        let mut result = VerificationResult {
            verified: true,
            details: String::new(),
            signature: None,
            warnings: Vec::new(),
        };

        // Verify signature
        match self.verify_signature(package).await? {
            Some(sig) => {
                if !sig.valid {
                    result.verified = false;
                    result.details = "Invalid package signature".to_string();
                }
                result.signature = Some(sig);
            }
            None => {
                result.warnings.push("Package is not signed".to_string());
            }
        }

        Ok(result)
    }

    async fn scan_vulnerabilities(&self, package: &Package) -> BlastResult<Vec<Vulnerability>> {
        self.fetch_vulnerabilities(package).await
    }

    async fn verify_policy(&self, package: &Package, policy: &SecurityPolicy) -> BlastResult<PolicyResult> {
        let mut result = PolicyResult {
            allowed: true,
            violations: Vec::new(),
            required_actions: Vec::new(),
        };

        // Check package source
        if !self.verify_source(package, policy)? {
            result.allowed = false;
            result.violations.push(PolicyViolation {
                rule: "allowed_sources".to_string(),
                details: format!("Package source not in allowed list: {:?}", package.source()),
                severity: VulnerabilitySeverity::High,
                recommendations: vec!["Use an approved package source".to_string()],
            });
        }

        // Check package-specific policies
        if let Some(pkg_policy) = policy.package_policies.get(package.name()) {
            // Check version constraints
            let version_allowed = pkg_policy.allowed_versions.iter().any(|constraint| {
                package.version().to_string().starts_with(constraint)
            });

            if !version_allowed {
                result.allowed = false;
                result.violations.push(PolicyViolation {
                    rule: "allowed_versions".to_string(),
                    details: format!(
                        "Package version {} not allowed by policy",
                        package.version()
                    ),
                    severity: VulnerabilitySeverity::High,
                    recommendations: vec![format!(
                        "Use one of the allowed versions: {:?}",
                        pkg_policy.allowed_versions
                    )],
                });
            }

            // Check required signatures
            if policy.verify_signatures {
                for required_sig in &pkg_policy.required_signatures {
                    if let Some(sig) = &result.signature {
                        if sig.key_id != *required_sig {
                            result.violations.push(PolicyViolation {
                                rule: "required_signatures".to_string(),
                                details: format!(
                                    "Package not signed with required key: {}",
                                    required_sig
                                ),
                                severity: VulnerabilitySeverity::High,
                                recommendations: vec![
                                    "Obtain package signed with required key".to_string()
                                ],
                            });
                        }
                    }
                }
            }
        }

        // Check vulnerabilities if enabled
        if policy.vulnerability_scan {
            let vulns = self.scan_vulnerabilities(package).await?;
            for vuln in vulns {
                if vuln.severity >= VulnerabilitySeverity::High {
                    result.allowed = false;
                    result.violations.push(PolicyViolation {
                        rule: "vulnerability_check".to_string(),
                        details: format!(
                            "Critical vulnerability found: {} ({})",
                            vuln.id,
                            vuln.description
                        ),
                        severity: vuln.severity,
                        recommendations: vec![format!(
                            "Upgrade to one of the fixed versions: {:?}",
                            vuln.fixed_versions
                        )],
                    });
                }
            }
        }

        Ok(result)
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-daemon/src/security/process.rs

```rs
use std::process::{Command, Stdio};
use std::sync::Arc;
use tokio::sync::Mutex;
use blast_core::{
    error::{BlastError, BlastResult},
    python::PythonEnvironment,
    security::{
        EnvironmentIsolation, SecurityPolicy, ResourceUsage,
        IsolationLevel,
    },
};

#[cfg(target_os = "linux")]
use {
    caps::{CapSet, Capability},
    nix::{
        sched::{CloneFlags, unshare},
        sys::stat::Mode,
        mount::{mount, MsFlags},
    },
};

/// Process-level environment isolation implementation
pub struct ProcessIsolation {
    /// Active environment processes
    active_environments: Arc<Mutex<Vec<ActiveEnvironment>>>,
    /// Security policy
    policy: SecurityPolicy,
}

/// Active environment information
struct ActiveEnvironment {
    /// Environment identifier
    env_id: String,
    /// Process ID
    pid: u32,
    /// Resource monitor handle
    monitor: ResourceMonitor,
    /// Namespace ID (Linux only)
    #[cfg(target_os = "linux")]
    namespace_id: Option<String>,
}

/// Resource monitor for processes
struct ResourceMonitor {
    /// Process ID to monitor
    pid: u32,
    /// Last usage measurements
    last_usage: ResourceUsage,
    /// Monitoring interval
    interval: std::time::Duration,
}

impl ProcessIsolation {
    /// Create new process isolation
    pub fn new(policy: SecurityPolicy) -> Self {
        Self {
            active_environments: Arc::new(Mutex::new(Vec::new())),
            policy,
        }
    }

    /// Set up process isolation
    #[cfg(target_os = "linux")]
    async fn setup_isolation(&self, env: &PythonEnvironment) -> BlastResult<()> {
        // Create new namespaces for process isolation
        unshare(CloneFlags::CLONE_NEWNS | CloneFlags::CLONE_NEWUSER | CloneFlags::CLONE_NEWPID)?;

        // Set up mount namespace
        mount(
            None::<&str>,
            "/",
            None::<&str>,
            MsFlags::MS_REC | MsFlags::MS_PRIVATE,
            None::<&str>,
        )?;

        // Mount tmpfs for /tmp
        mount(
            Some("tmpfs"),
            "/tmp",
            Some("tmpfs"),
            MsFlags::MS_NOSUID | MsFlags::MS_NODEV,
            None::<&str>,
        )?;

        // Drop capabilities
        let mut caps = caps::CapsHashSet::new();
        caps.insert(Capability::CAP_NET_BIND_SERVICE);
        caps.insert(Capability::CAP_NET_RAW);
        caps::set(None, CapSet::Effective, &caps)?;

        Ok(())
    }

    /// Set up process isolation (macOS)
    #[cfg(target_os = "macos")]
    async fn setup_isolation(&self, env: &PythonEnvironment) -> BlastResult<()> {
        // Use sandbox-exec for process isolation
        let profile = format!(
            r#"(version 1)
            (allow default)
            (deny network*)
            (deny file-write* (subpath "/"))
            (allow file-write* (subpath "{}"))
            (allow file-write* (subpath "/tmp"))
            "#,
            env.path().display()
        );

        Ok(())
    }

    /// Set up process isolation (Windows)
    #[cfg(target_os = "windows")]
    async fn setup_isolation(&self, env: &PythonEnvironment) -> BlastResult<()> {
        use windows_sys::Win32::Security::Isolation::{
            CreateAppContainerProfile,
            DeleteAppContainerProfile,
        };
        
        // Create an AppContainer profile for isolation
        let profile_name = format!("blast_{}", uuid::Uuid::new_v4());
        let display_name = "Blast Python Environment";
        
        // TODO: Implement Windows-specific isolation
        Ok(())
    }

    /// Start monitoring a process with isolation
    async fn start_monitoring(&self, env_id: String, pid: u32) -> BlastResult<()> {
        let monitor = ResourceMonitor::new(pid);
        let env = ActiveEnvironment {
            env_id,
            pid,
            monitor,
            #[cfg(target_os = "linux")]
            namespace_id: None,
        };
        
        self.active_environments.lock().await.push(env);
        Ok(())
    }

    /// Stop monitoring a process
    async fn stop_monitoring(&self, pid: u32) -> BlastResult<()> {
        let mut envs = self.active_environments.lock().await;
        if let Some(pos) = envs.iter().position(|e| e.pid == pid) {
            let env = envs.remove(pos);
            
            // Clean up namespace if needed
            #[cfg(target_os = "linux")]
            if let Some(ns_id) = env.namespace_id {
                // Clean up Linux namespaces
            }
            
            #[cfg(target_os = "windows")]
            {
                // Clean up Windows AppContainer
            }
        }
        Ok(())
    }
}

impl ResourceMonitor {
    /// Create new resource monitor
    fn new(pid: u32) -> Self {
        Self {
            pid,
            last_usage: ResourceUsage {
                memory_usage: 0,
                cpu_usage: 0.0,
                disk_usage: 0,
                bandwidth_usage: 0,
            },
            interval: std::time::Duration::from_secs(1),
        }
    }

    /// Get current resource usage
    fn get_usage(&mut self) -> BlastResult<ResourceUsage> {
        // Read /proc/{pid}/stat for Linux systems
        #[cfg(target_os = "linux")]
        {
            use std::fs::File;
            use std::io::Read;
            
            let mut stat = String::new();
            File::open(format!("/proc/{}/stat", self.pid))?
                .read_to_string(&mut stat)?;
            
            let parts: Vec<&str> = stat.split_whitespace().collect();
            
            // Parse memory usage (RSS)
            let memory = parts.get(23)
                .and_then(|s| s.parse::<u64>().ok())
                .unwrap_or(0) * 4096; // Convert pages to bytes
            
            // Parse CPU usage
            let utime = parts.get(13)
                .and_then(|s| s.parse::<u64>().ok())
                .unwrap_or(0);
            let stime = parts.get(14)
                .and_then(|s| s.parse::<u64>().ok())
                .unwrap_or(0);
            
            let total_time = utime + stime;
            let cpu_usage = (total_time as f32 / 100.0).min(100.0);
            
            self.last_usage = ResourceUsage {
                memory_usage: memory,
                cpu_usage,
                disk_usage: 0, // TODO: Implement disk usage tracking
                bandwidth_usage: 0, // TODO: Implement bandwidth tracking
            };
        }

        // For macOS systems
        #[cfg(target_os = "macos")]
        {
            use std::process::Command;
            
            // Use ps command to get memory and CPU usage
            let output = Command::new("ps")
                .args(&["-o", "rss,%cpu", "-p", &self.pid.to_string()])
                .output()?;
            
            let stats = String::from_utf8_lossy(&output.stdout);
            let parts: Vec<&str> = stats.split_whitespace().collect();
            
            if parts.len() >= 3 {
                let memory = parts[1].parse::<u64>().unwrap_or(0) * 1024; // Convert KB to bytes
                let cpu = parts[2].parse::<f32>().unwrap_or(0.0);
                
                self.last_usage = ResourceUsage {
                    memory_usage: memory,
                    cpu_usage: cpu,
                    disk_usage: 0, // TODO: Implement disk usage tracking
                    bandwidth_usage: 0, // TODO: Implement bandwidth tracking
                };
            }
        }

        Ok(self.last_usage.clone())
    }
}

#[async_trait::async_trait]
impl EnvironmentIsolation for ProcessIsolation {
    async fn create_environment(&self, config: &SecurityPolicy) -> BlastResult<PythonEnvironment> {
        if config.isolation_level != IsolationLevel::Process {
            return Err(BlastError::security(
                "ProcessIsolation only supports process-level isolation"
            ));
        }

        // Create Python environment
        let env = PythonEnvironment::new(
            std::env::current_dir()?.join(".blast").join("envs").join(uuid::Uuid::new_v4().to_string()),
            config.python_version.clone(),
        );

        // Set up isolation
        self.setup_isolation(&env).await?;

        // Start Python process with isolation
        let mut command = Command::new(&env.interpreter_path());
        
        #[cfg(target_os = "macos")]
        {
            command.arg("-c")
                  .arg("import sys; sys.exit(0)")
                  .env("DYLD_INSERT_LIBRARIES", "/usr/lib/libsandbox.dylib");
        }

        #[cfg(target_os = "linux")]
        {
            command.arg("-c")
                  .arg("import sys; sys.exit(0)")
                  .env("LD_PRELOAD", "/usr/lib/libseccomp.so");
        }

        let child = command
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .spawn()?;

        // Start monitoring
        self.start_monitoring(env.name().unwrap_or("unnamed").to_string(), child.id())
            .await?;

        Ok(env)
    }

    async fn destroy_environment(&self, env: &PythonEnvironment) -> BlastResult<()> {
        let envs = self.active_environments.lock().await;
        if let Some(active_env) = envs.iter().find(|e| e.env_id == env.name().unwrap_or("unnamed")) {
            // Stop the process
            #[cfg(unix)]
            {
                use nix::sys::signal::{kill, Signal};
                use nix::unistd::Pid;
                
                kill(Pid::from_raw(active_env.pid as i32), Signal::SIGTERM)?;
            }

            #[cfg(windows)]
            {
                use winapi::um::processthreadsapi::TerminateProcess;
                use winapi::um::winnt::HANDLE;
                use winapi::um::handleapi::CloseHandle;
                
                unsafe {
                    let handle = OpenProcess(
                        PROCESS_TERMINATE,
                        0,
                        active_env.pid
                    );
                    if !handle.is_null() {
                        TerminateProcess(handle, 0);
                        CloseHandle(handle);
                    }
                }
            }

            // Stop monitoring
            self.stop_monitoring(active_env.pid).await?;
        }

        Ok(())
    }

    async fn execute_command(&self, env: &PythonEnvironment, command: &str) -> BlastResult<String> {
        let output = Command::new(&env.interpreter_path())
            .arg("-c")
            .arg(command)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .output()?;

        if output.status.success() {
            Ok(String::from_utf8_lossy(&output.stdout).to_string())
        } else {
            Err(BlastError::security(format!(
                "Command failed: {}",
                String::from_utf8_lossy(&output.stderr)
            )))
        }
    }

    async fn get_resource_usage(&self, env: &PythonEnvironment) -> BlastResult<ResourceUsage> {
        let envs = self.active_environments.lock().await;
        if let Some(active_env) = envs.iter().find(|e| e.env_id == env.name().unwrap_or("unnamed")) {
            Ok(active_env.monitor.get_usage()?)
        } else {
            Err(BlastError::security("Environment not found"))
        }
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-daemon/src/error.rs

```rs
use blast_core::error::BlastError;

/// Daemon error types
#[derive(Debug, thiserror::Error, Clone)]
pub enum DaemonError {
    /// Service error
    #[error("Service error: {0}")]
    Service(String),

    /// IPC error
    #[error("IPC error: {0}")]
    Ipc(String),

    /// Monitor error
    #[error("Monitor error: {0}")]
    Monitor(String),

    /// Core error
    #[error("Core error: {0}")]
    Core(String),

    /// Resolver error
    #[error("Resolver error: {0}")]
    Resolver(String),

    /// Transaction error
    #[error("Transaction error: {0}")]
    Transaction(String),

    /// Validation error
    #[error("Validation error: {0}")]
    Validation(String),

    /// Version error
    #[error("Version error: {0}")]
    Version(String),

    /// Resource limit exceeded
    #[error("Resource limit exceeded: {0}")]
    ResourceLimit(String),

    /// State error
    #[error("State error: {0}")]
    State(String),

    /// Snapshot error
    #[error("Snapshot error: {0}")]
    Snapshot(String),

    /// Access error
    #[error("Access error: {0}")]
    Access(String),

    /// Environment error
    #[error("Environment error: {0}")]
    Environment(String),

    /// IO error
    #[error("IO error: {0}")]
    Io(String),
}

// Implement conversion from BlastError
impl From<BlastError> for DaemonError {
    fn from(error: BlastError) -> Self {
        match error {
            BlastError::Io(msg) => DaemonError::Io(msg),
            BlastError::Python(msg) => DaemonError::Core(format!("Python error: {}", msg)),
            BlastError::Package(msg) => DaemonError::Core(format!("Package error: {}", msg)),
            BlastError::Environment(msg) => DaemonError::Environment(msg),
            BlastError::Resolution(msg) => DaemonError::Resolver(msg),
            BlastError::Version(msg) => DaemonError::Version(msg),
            BlastError::Cache(msg) => DaemonError::Core(format!("Cache error: {}", msg)),
            BlastError::Daemon(msg) => DaemonError::Core(msg),
            _ => DaemonError::Core(error.to_string()),
        }
    }
}

// Implement conversion from std::io::Error
impl From<std::io::Error> for DaemonError {
    fn from(error: std::io::Error) -> Self {
        DaemonError::Io(error.to_string())
    }
}

// Implement conversion to BlastError
impl From<DaemonError> for BlastError {
    fn from(error: DaemonError) -> Self {
        match error {
            DaemonError::Service(msg) => BlastError::daemon(msg),
            DaemonError::Ipc(msg) => BlastError::daemon(format!("IPC error: {}", msg)),
            DaemonError::Monitor(msg) => BlastError::daemon(format!("Monitor error: {}", msg)),
            DaemonError::Core(msg) => BlastError::daemon(msg),
            DaemonError::Resolver(msg) => BlastError::resolution(msg),
            DaemonError::Transaction(msg) => BlastError::daemon(format!("Transaction error: {}", msg)),
            DaemonError::Validation(msg) => BlastError::daemon(format!("Validation error: {}", msg)),
            DaemonError::Version(msg) => BlastError::version(msg),
            DaemonError::ResourceLimit(msg) => BlastError::daemon(format!("Resource limit error: {}", msg)),
            DaemonError::State(msg) => BlastError::daemon(format!("State error: {}", msg)),
            DaemonError::Snapshot(msg) => BlastError::daemon(format!("Snapshot error: {}", msg)),
            DaemonError::Access(msg) => BlastError::daemon(msg),
            DaemonError::Environment(msg) => BlastError::environment(msg),
            DaemonError::Io(msg) => BlastError::Io(msg),
        }
    }
}

// Explicitly implement Send + Sync
unsafe impl Send for DaemonError {}
unsafe impl Sync for DaemonError {}

// Helper methods for error creation
impl DaemonError {
    pub fn service(msg: impl Into<String>) -> Self {
        Self::Service(msg.into())
    }

    pub fn ipc(msg: impl Into<String>) -> Self {
        Self::Ipc(msg.into())
    }

    pub fn monitor(msg: impl Into<String>) -> Self {
        Self::Monitor(msg.into())
    }

    pub fn core(msg: impl Into<String>) -> Self {
        Self::Core(msg.into())
    }

    pub fn resolver(msg: impl Into<String>) -> Self {
        Self::Resolver(msg.into())
    }

    pub fn transaction(msg: impl Into<String>) -> Self {
        Self::Transaction(msg.into())
    }

    pub fn validation(msg: impl Into<String>) -> Self {
        Self::Validation(msg.into())
    }

    pub fn version(msg: impl Into<String>) -> Self {
        Self::Version(msg.into())
    }

    pub fn resource_limit(msg: impl Into<String>) -> Self {
        Self::ResourceLimit(msg.into())
    }

    pub fn state(msg: impl Into<String>) -> Self {
        Self::State(msg.into())
    }

    pub fn snapshot(msg: impl Into<String>) -> Self {
        Self::Snapshot(msg.into())
    }

    pub fn access(msg: impl Into<String>) -> Self {
        Self::Access(msg.into())
    }

    pub fn environment(msg: impl Into<String>) -> Self {
        Self::Environment(msg.into())
    }

    pub fn io(msg: impl Into<String>) -> Self {
        Self::Io(msg.into())
    }
}

/// Result type for daemon operations
pub type DaemonResult<T> = Result<T, DaemonError>; 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-daemon/src/monitor.rs

```rs
//! Environment monitoring functionality for Python environments

use std::path::PathBuf;
use std::time::{Instant, Duration};
use walkdir::WalkDir;

/// Monitor events for Python environment changes
#[derive(Debug)]
pub enum MonitorEvent {
    /// Resource usage check
    ResourceCheck,
    /// Package change detected
    PackageChanged,
    /// Stop monitoring for environment
    StopMonitoring {
        env_path: PathBuf,
    },
    /// Python file change event
    FileChanged(PathBuf),
    /// Environment resource usage update
    ResourceUpdate(EnvironmentUsage),
}

/// Environment resource usage information
#[derive(Debug, Clone)]
pub struct EnvironmentUsage {
    /// Environment disk usage in bytes
    pub env_disk_usage: EnvDiskUsage,
    /// Package cache usage
    pub cache_usage: CacheUsage,
    /// Timestamp of the measurement
    pub timestamp: Instant,
}

/// Environment disk usage information
#[derive(Debug, Clone, Default)]
pub struct EnvDiskUsage {
    /// Total size of the environment in bytes
    pub total_size: u64,
    /// Size of installed packages in bytes
    pub packages_size: u64,
    /// Size of Python standard library in bytes
    pub stdlib_size: u64,
}

/// Package cache usage information
#[derive(Debug, Clone, Default)]
pub struct CacheUsage {
    /// Total size of cached packages in bytes
    pub total_size: u64,
    /// Number of cached packages
    pub package_count: usize,
    /// Cache location
    pub cache_path: PathBuf,
}

/// Resource limits for Python environment
#[derive(Debug, Clone)]
pub struct PythonResourceLimits {
    /// Maximum environment size in bytes
    pub max_env_size: u64,
    /// Maximum cache size in bytes
    pub max_cache_size: u64,
}

impl Default for PythonResourceLimits {
    fn default() -> Self {
        Self {
            max_env_size: 1024 * 1024 * 1024 * 5, // 5GB
            max_cache_size: 1024 * 1024 * 1024 * 2, // 2GB
        }
    }
}

/// Monitor for Python environment resources
#[derive(Debug, Clone)]
pub struct PythonResourceMonitor {
    /// Resource limits
    limits: PythonResourceLimits,
    /// Environment path
    env_path: PathBuf,
    /// Cache path
    cache_path: PathBuf,
    /// Last update time
    last_update: Instant,
    /// Last environment usage
    last_env_usage: EnvDiskUsage,
    /// Last cache usage
    last_cache_usage: CacheUsage,
}

impl PythonResourceMonitor {
    /// Create a new Python resource monitor
    pub fn new(env_path: PathBuf, cache_path: PathBuf, limits: PythonResourceLimits) -> Self {
        Self {
            limits,
            env_path,
            cache_path,
            last_update: Instant::now(),
            last_env_usage: EnvDiskUsage::default(),
            last_cache_usage: CacheUsage::default(),
        }
    }

    /// Check if it's time for a resource update
    pub fn should_update(&self) -> bool {
        self.last_update.elapsed() >= Duration::from_secs(60)
    }

    /// Get current environment usage with optimized calculations
    pub fn get_current_usage(&mut self) -> EnvironmentUsage {
        // Only update if enough time has passed
        if !self.should_update() {
            return EnvironmentUsage {
                env_disk_usage: self.last_env_usage.clone(),
                cache_usage: self.last_cache_usage.clone(),
                timestamp: self.last_update,
            };
        }

        let usage = EnvironmentUsage {
            env_disk_usage: self.calculate_env_disk_usage(),
            cache_usage: self.calculate_cache_usage(),
            timestamp: Instant::now(),
        };

        // Cache the results
        self.last_env_usage = usage.env_disk_usage.clone();
        self.last_cache_usage = usage.cache_usage.clone();
        self.last_update = usage.timestamp;

        usage
    }

    /// Calculate environment disk usage with optimizations
    fn calculate_env_disk_usage(&self) -> EnvDiskUsage {
        let mut usage = EnvDiskUsage::default();
        
        // Calculate site-packages size
        let site_packages = self.env_path.join("lib").join("python3").join("site-packages");
        if site_packages.exists() {
            usage.packages_size = self.calculate_directory_size(&site_packages);
        }
        
        // Calculate stdlib size
        let stdlib = self.env_path.join("lib").join("python3");
        if stdlib.exists() {
            usage.stdlib_size = self.calculate_directory_size(&stdlib);
        }
        
        usage.total_size = usage.packages_size + usage.stdlib_size;
        usage
    }

    /// Calculate cache usage with optimizations
    fn calculate_cache_usage(&self) -> CacheUsage {
        let mut usage = CacheUsage::default();
        usage.cache_path = self.cache_path.clone();

        if !self.cache_path.exists() {
            return usage;
        }

        // Use walkdir for more efficient directory traversal
        for entry in WalkDir::new(&self.cache_path)
            .min_depth(1)
            .max_depth(2)  // Only go one level deep for package counting
            .into_iter()
            .filter_entry(|e| !self.should_skip_path(e.path()))
            .filter_map(|e| e.ok())
        {
            let metadata = match entry.metadata() {
                Ok(m) => m,
                Err(_) => continue,
            };

            if metadata.is_file() {
                usage.total_size += metadata.len();
            }

            // Count top-level directories as packages
            if metadata.is_dir() && entry.depth() == 1 {
                usage.package_count += 1;
            }
        }

        usage
    }

    /// Check if a path should be skipped during traversal
    fn should_skip_path(&self, path: &std::path::Path) -> bool {
        let file_name = match path.file_name().and_then(|n| n.to_str()) {
            Some(name) => name,
            None => return true,
        };

        // Skip common unnecessary directories and files
        file_name.starts_with('.') || 
        file_name == "__pycache__" ||
        file_name == "*.pyc" ||
        file_name == "*.pyo" ||
        file_name == "*.pyd"
    }

    /// Calculate directory size efficiently
    fn calculate_directory_size(&self, path: &PathBuf) -> u64 {
        WalkDir::new(path)
            .into_iter()
            .filter_entry(|e| !self.should_skip_path(e.path()))
            .filter_map(|e| e.ok())
            .filter_map(|e| e.metadata().ok())
            .filter(|m| m.is_file())
            .map(|m| m.len())
            .sum()
    }

    /// Check resource limits
    pub fn check_limits(&mut self) -> bool {
        let usage = self.get_current_usage();
        
        usage.env_disk_usage.total_size <= self.limits.max_env_size &&
        usage.cache_usage.total_size <= self.limits.max_cache_size
    }

    /// Update resource limits
    pub fn update_limits(&mut self, new_limits: PythonResourceLimits) {
        self.limits = new_limits;
    }

    /// Get current resource limits
    pub fn get_limits(&self) -> &PythonResourceLimits {
        &self.limits
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-daemon/src/lib.rs

```rs
//! Background service for the Blast Python environment manager.
//! 
//! This crate provides a daemon service that monitors Python environments
//! and handles real-time dependency updates.

use std::collections::HashMap;
use tokio::sync::{mpsc, Mutex as TokioMutex, RwLock, oneshot};
use tracing::{error, info};
use std::path::PathBuf;
use std::sync::Arc;
use std::time::{Duration, Instant, SystemTime};

use blast_core::{
    python::{PythonVersion, PythonEnvironment},
    security::SecurityPolicy,
    package::Package,
    version::VersionConstraint,
    metadata::PackageMetadata,
    environment::Environment,
    error::BlastResult,
    state::EnvironmentState,
};

use crate::monitor::MonitorEvent;
use crate::transaction::{TransactionOperation, TransactionManager, TransactionContext};
use crate::error::DaemonResult;

pub mod error;
pub mod state;
pub mod metrics;
pub mod service;
pub mod monitor;
pub mod transaction;
pub mod update;
pub mod environment;

// Re-export commonly used types
pub use error::DaemonError;
pub use state::{StateManager, Checkpoint};
pub use metrics::MetricsManager;
pub use service::DaemonService;
pub use monitor::PythonResourceMonitor;
pub use environment::EnvironmentManager;

// Internal module re-exports
pub use monitor::{
    PythonResourceLimits,
    EnvironmentUsage,
    EnvDiskUsage,
    CacheUsage,
};
pub use blast_image::validation;
pub use state::*;
pub use metrics::{
    PackageMetrics,
    EnvironmentMetrics,
};

// Local imports with full paths to avoid conflicts
use crate::update::UpdateManager;

/// Daemon configuration
#[derive(Debug, Clone)]
pub struct DaemonConfig {
    /// Maximum number of pending updates
    pub max_pending_updates: usize,
    /// Maximum age of state snapshots in days
    pub max_snapshot_age_days: u64,
    /// Environment path
    pub env_path: PathBuf,
    /// Cache path
    pub cache_path: PathBuf,
}

impl Default for DaemonConfig {
    fn default() -> Self {
        Self {
            max_pending_updates: 100,
            max_snapshot_age_days: 7,
            env_path: PathBuf::from("environments/default"),
            cache_path: PathBuf::from("cache"),
        }
    }
}

/// Daemon state
#[derive(Debug)]
pub struct Daemon {
    /// Configuration for the daemon
    config: DaemonConfig,
    /// Channel for sending monitor events
    monitor_tx: mpsc::Sender<MonitorEvent>,
    /// Update manager for environment updates
    update_manager: Arc<TokioMutex<UpdateManager>>,
    /// State manager
    state_manager: Arc<RwLock<StateManager>>,
    /// Environment activation state
    activation_state: Arc<RwLock<ActivationState>>,
    /// Environment manager
    environment_manager: Arc<EnvironmentManager>,
    /// Service instance
    service: Arc<TokioMutex<DaemonService>>,
    /// Transaction manager
    transaction_manager: Arc<TokioMutex<TransactionManager>>,
}

#[derive(Debug, Clone)]
pub struct ActivationState {
    /// Currently active environment name
    active_env_name: Option<String>,
    /// Path to active environment
    active_env_path: Option<PathBuf>,
    /// Python version of active environment
    active_python_version: Option<PythonVersion>,
    /// Activation timestamp
    activated_at: Option<SystemTime>,
}

impl ActivationState {
    pub fn new() -> Self {
        Self {
            active_env_name: None,
            active_env_path: None,
            active_python_version: None,
            activated_at: None,
        }
    }
}

impl Daemon {
    /// Create a new daemon instance
    pub async fn new(config: DaemonConfig) -> BlastResult<Self> {
        // Create channels
        let (monitor_tx, monitor_rx) = mpsc::channel(config.max_pending_updates);

        // Create managers
        let state_manager = Arc::new(RwLock::new(StateManager::new(config.env_path.clone())));
        
        // Create initial environment state for transaction manager
        let initial_state = blast_core::state::EnvironmentState::new(
            "default".to_string(),
            PythonVersion::default(),
            HashMap::new(),
            Default::default(),
        );
        let transaction_manager = Arc::new(TokioMutex::new(TransactionManager::new(initial_state)));
        let activation_state = Arc::new(RwLock::new(ActivationState::new()));
        
        // Create environment manager
        let environment_manager = Arc::new(EnvironmentManager::new(config.env_path.clone()));

        // Create update manager
        let update_manager = Arc::new(TokioMutex::new(UpdateManager::new(
            config.env_path.clone(),
            config.cache_path.clone(),
            monitor_rx
        )));

        // Create service instance with cloned monitor_tx
        let service = Arc::new(TokioMutex::new(DaemonService::new(monitor_tx.clone())?));

        Ok(Self {
            config,
            monitor_tx,
            update_manager,
            state_manager,
            activation_state,
            environment_manager,
            service,
            transaction_manager,
        })
    }

    /// Get the daemon configuration
    pub fn config(&self) -> &DaemonConfig {
        &self.config
    }

    /// Get the state manager
    pub fn state_manager(&self) -> Arc<RwLock<StateManager>> {
        self.state_manager.clone()
    }

    pub async fn list_environments(&self) -> DaemonResult<Vec<DaemonEnvironment>> {
        let state_manager = self.state_manager.read().await;
        let current_state = state_manager.get_current_state().await?;
        
        if current_state.name() != "default" {
            Ok(vec![DaemonEnvironment {
                name: current_state.name().to_string(),
                python_version: current_state.python_version.to_string(),
                path: self.config.env_path.clone(),
                last_accessed: SystemTime::now(),
                active: current_state.is_active(),
            }])
        } else {
            Ok(vec![])
        }
    }

    /// Create a new Python environment
    pub async fn create_environment(&self, policy: &SecurityPolicy) -> DaemonResult<PythonEnvironment> {
        info!("Creating new environment with policy: {:?}", policy);
        
        // Create environment using environment manager
        let env = self.environment_manager.create_environment(
            "default",
            &policy.python_version,
        ).await?;

        // Create basic directory structure
        for dir in ["bin", "lib", "include"] {
            tokio::fs::create_dir_all(env.path().join(dir)).await.map_err(|e| 
                DaemonError::environment(format!("Failed to create {} directory: {}", dir, e))
            )?;
        }

        // Create site-packages directory
        tokio::fs::create_dir_all(env.path().join("lib").join("python3").join("site-packages"))
            .await
            .map_err(|e| DaemonError::environment(format!(
                "Failed to create site-packages directory: {}", e
            )))?;

        // Create initial environment state
        let env_state = blast_core::state::EnvironmentState::new(
            "default".to_string(),
            policy.python_version.clone(),
            HashMap::new(),
            HashMap::new(),
        );

        // Add environment with transaction
        self.add_environment("default".to_string(), env_state).await?;

        info!("Environment created successfully at {}", env.path().display());
        Ok(env)
    }

    pub async fn destroy_environment(&self, env: &PythonEnvironment) -> DaemonResult<()> {
        info!("Destroying environment at {}", env.path().display());
        
        // Stop monitoring
        self.stop_monitoring(env).await?;

        // Remove environment with transaction
        if let Some(name) = env.path().file_name().and_then(|n| n.to_str()) {
            self.remove_environment_with_transaction(name).await?;
        }

        // Remove environment directory
        tokio::fs::remove_dir_all(env.path()).await?;

        info!("Environment destroyed successfully");
        Ok(())
    }

    pub async fn stop_monitoring(&self, env: &PythonEnvironment) -> DaemonResult<()> {
        info!("Stopping environment monitoring");
        
        // Send stop monitoring event
        self.monitor_tx.send(MonitorEvent::StopMonitoring {
            env_path: env.path().to_path_buf(),
        }).await.map_err(|e| DaemonError::monitor(format!("Failed to send stop monitoring event: {}", e)))?;

        info!("Environment monitoring stopped");
        Ok(())
    }

    pub async fn clean_environment(&self, env: &PythonEnvironment) -> DaemonResult<()> {
        info!("Cleaning environment");
        
        // Get all installed packages
        let packages = env.get_packages()?;
        
        // Remove each package with transaction
        for package in packages {
            if let Err(e) = self.remove_package(&package).await {
                error!("Failed to remove package {}: {}", package.name(), e);
            }
        }

        info!("Environment cleaned successfully");
        Ok(())
    }

    pub async fn reinitialize_environment(&self, env: &PythonEnvironment) -> DaemonResult<()> {
        info!("Reinitializing environment");
        
        // Create fresh virtual environment
        env.create().await?;

        // Set up basic configuration
        let python_path = env.path().join("bin").join("python");
        std::fs::write(
            env.path().join("pyvenv.cfg"),
            format!(
                "home = {}\nversion = {}\ninclude-system-site-packages = false\n",
                python_path.display(),
                env.python_version()
            ),
        )?;

        info!("Environment reinitialized successfully");
        Ok(())
    }

    pub async fn restore_essential_packages(&self, _env: &PythonEnvironment) -> DaemonResult<()> {
        info!("Restoring essential packages");
        
        // Install pip and setuptools with transactions
        let essential_packages = vec![
            Package::new(
                "pip".to_string(),
                "latest".to_string(),
                PackageMetadata::new(
                    "pip".to_string(),
                    "latest".to_string(),
                    HashMap::new(),
                    VersionConstraint::any(),
                ),
                VersionConstraint::any(),
            )?,
            Package::new(
                "setuptools".to_string(),
                "latest".to_string(),
                PackageMetadata::new(
                    "setuptools".to_string(),
                    "latest".to_string(),
                    HashMap::new(),
                    VersionConstraint::any(),
                ),
                VersionConstraint::any(),
            )?,
        ];

        for package in essential_packages {
            self.install_package(&package).await?;
        }

        info!("Essential packages restored successfully");
        Ok(())
    }

    /// Run the daemon in the background
    pub async fn run(self) -> DaemonResult<()> {
        info!("Starting daemon service");
        
        // Create a channel for startup completion
        let (startup_tx, startup_rx) = oneshot::channel();
        let startup_signal = Arc::new(TokioMutex::new(Some(startup_tx)));

        // Take ownership of the update manager
        let update_manager = Arc::clone(&self.update_manager);
        
        // Spawn the update manager in a separate task
        let update_task = {
            let startup_signal = Arc::clone(&startup_signal);
            tokio::spawn(async move {
                // Get the update manager lock inside the task
                let mut update_manager = update_manager.lock().await;
                
                // Signal successful startup immediately after getting the lock
                if let Some(tx) = startup_signal.lock().await.take() {
                    let _ = tx.send(());
                }
                
                // Run the update manager
                update_manager.run().await
            })
        };

        // Wait for startup completion or timeout
        tokio::select! {
            _ = startup_rx => {
                info!("Daemon startup completed successfully");
                
                // Keep running until update task completes or error occurs
                match update_task.await {
                    Ok(Ok(_)) => info!("Update manager completed normally"),
                    Ok(Err(e)) => {
                        error!("Update manager error: {}", e);
                        return Err(e);
                    }
                    Err(e) => {
                        error!("Update manager task failed: {}", e);
                        return Err(DaemonError::service(format!("Update manager task failed: {}", e)));
                    }
                }
            }
            _ = tokio::time::sleep(Duration::from_secs(5)) => {
                error!("Daemon startup timed out after 5 seconds");
                return Err(DaemonError::service("Daemon startup timed out".to_string()));
            }
        }

        Ok(())
    }

    /// Register an environment as active and start monitoring
    pub async fn register_active_environment(&self, _env_name: String) -> DaemonResult<()> {
        let state_manager = self.state_manager.clone();
        
        // Update active status in state
        {
            let state_manager = state_manager.write().await;
            let mut current_state = state_manager.get_current_state().await?;
            current_state.set_active(true);
            state_manager.update_current_state(current_state).await?;
        }

        // Start monitoring task
        let monitor_tx = self.monitor_tx.clone();
        tokio::spawn(async move {
            let mut interval = tokio::time::interval(Duration::from_secs(60));
            loop {
                interval.tick().await;
                if let Err(e) = monitor_tx.send(MonitorEvent::ResourceCheck).await {
                    error!("Failed to send resource check event: {}", e);
                    break;
                }
            }
        });

        Ok(())
    }

    /// Deactivate the current environment
    pub async fn deactivate_environment(&self) -> DaemonResult<()> {
        info!("Deactivating environment");
        
        // Clear activation state
        {
            let mut activation_state = self.activation_state.write().await;
            activation_state.active_env_name = None;
            activation_state.active_env_path = None;
            activation_state.active_python_version = None;
            activation_state.activated_at = None;
        }

        // Update state manager
        {
            let state_manager = self.state_manager.write().await;
            state_manager.clear_active_environment().await?;
        }

        info!("Environment deactivated successfully");
        Ok(())
    }

    /// Verify daemon has necessary permissions and access
    pub async fn verify_access(&self) -> DaemonResult<()> {
        // Verify environment path access
        let env_path = &self.config.env_path;
        if !env_path.exists() {
            std::fs::create_dir_all(env_path).map_err(|e| {
                DaemonError::Access(format!("Failed to create environment directory: {}", e))
            })?;
        }

        // Verify cache path access
        let cache_path = &self.config.cache_path;
        if !cache_path.exists() {
            std::fs::create_dir_all(cache_path).map_err(|e| {
                DaemonError::Access(format!("Failed to create cache directory: {}", e))
            })?;
        }

        // Verify state file access
        let state_manager = self.state_manager.read().await;
        state_manager.verify().await.map_err(|e| {
            DaemonError::Access(format!("Failed to verify state access: {}", e))
        })?;

        // Verify we can write to the environment directory
        let test_file = env_path.join(".blast_write_test");
        tokio::fs::write(&test_file, b"test").await.map_err(|e| {
            DaemonError::Access(format!("Failed to write to environment directory: {}", e))
        })?;
        tokio::fs::remove_file(&test_file).await.map_err(|e| {
            DaemonError::Access(format!("Failed to clean up test file: {}", e))
        })?;

        // Verify we can write to the cache directory
        let test_file = cache_path.join(".blast_write_test");
        tokio::fs::write(&test_file, b"test").await.map_err(|e| {
            DaemonError::Access(format!("Failed to write to cache directory: {}", e))
        })?;
        tokio::fs::remove_file(&test_file).await.map_err(|e| {
            DaemonError::Access(format!("Failed to clean up test file: {}", e))
        })?;

        // Verify monitor channel
        if self.monitor_tx.is_closed() {
            return Err(DaemonError::Access("Monitor channel is closed".to_string()));
        }

        Ok(())
    }

    /// Activate an environment
    pub async fn activate_environment(&self, env_name: &str, python_version: PythonVersion) -> DaemonResult<()> {
        info!("Activating environment: {}", env_name);
        
        let env_path = self.config.env_path.join(env_name);
        
        // Ensure environment exists and is properly initialized
        if !env_path.exists() {
            // Create environment using environment manager
            self.environment_manager.create_environment(
                env_name,
                &python_version,
            ).await?;
        }

        // Update activation state
        {
            let mut activation_state = self.activation_state.write().await;
            activation_state.active_env_name = Some(env_name.to_string());
            activation_state.active_env_path = Some(env_path.clone());
            activation_state.active_python_version = Some(python_version.clone());
            activation_state.activated_at = Some(SystemTime::now());
        }

        // Update state manager
        {
            let state_manager = self.state_manager.write().await;
            state_manager.set_active_environment(
                env_name.to_string(),
                env_path,
                python_version,
            ).await?;
        }

        // Start monitoring
        self.monitor_tx.send(MonitorEvent::ResourceCheck).await.map_err(|e| {
            DaemonError::monitor(format!("Failed to send resource check event: {}", e))
        })?;

        info!("Environment activated successfully");
        Ok(())
    }

    /// Get current activation state
    pub async fn get_activation_state(&self) -> DaemonResult<ActivationState> {
        Ok(self.activation_state.read().await.clone())
    }

    /// Start the daemon in the background
    pub async fn start_background(&self) -> BlastResult<()> {
        // Clone necessary components for the background task
        let service = self.service.clone();
        let config = self.config.clone();
        
        // Spawn the background task
        tokio::spawn(async move {
            let mut last_update = std::time::Instant::now();
            
            loop {
                let mut service = service.lock().await;
                
                // Only process updates every few seconds to avoid unnecessary transactions
                if last_update.elapsed() >= Duration::from_secs(5) {
                    // Check if there are any pending updates before creating a transaction
                    if service.has_pending_updates().await {
                        if let Err(e) = service.process_updates().await {
                            // Only log as error if it's not a "Transaction not found" error
                            if !e.to_string().contains("Transaction not found") {
                                error!("Error processing updates: {}", e);
                            }
                        }
                    }
                    last_update = std::time::Instant::now();
                }
                
                // Sleep for a short duration to prevent busy-waiting
                tokio::time::sleep(Duration::from_secs(1)).await;
            }
        });

        // Create socket directory if it doesn't exist
        let socket_dir = std::path::Path::new("/tmp/blast");
        if !socket_dir.exists() {
            std::fs::create_dir_all(socket_dir)?;
        }

        // Create socket file
        let socket_path = socket_dir.join(format!("{}.sock", config.env_path.file_name().unwrap_or_default().to_string_lossy()));
        if socket_path.exists() {
            std::fs::remove_file(&socket_path)?;
        }
        std::fs::write(&socket_path, "")?;

        Ok(())
    }

    /// Check if there are any pending updates
    pub async fn has_pending_updates(&self) -> bool {
        let service = self.service.lock().await;
        service.has_pending_updates().await
    }

    /// Begin a new transaction
    pub async fn begin_transaction(&self, description: String) -> DaemonResult<TransactionContext> {
        let transaction_manager = self.transaction_manager.lock().await;
        transaction_manager.begin_transaction(description).await
    }

    /// Commit a transaction
    pub async fn commit_transaction(&self, id: uuid::Uuid) -> DaemonResult<()> {
        let transaction_manager = self.transaction_manager.lock().await;
        transaction_manager.commit_transaction(id).await
    }

    /// Rollback a transaction
    pub async fn rollback_transaction(&self, id: uuid::Uuid) -> DaemonResult<()> {
        let transaction_manager = self.transaction_manager.lock().await;
        transaction_manager.rollback_transaction(id).await
    }

    /// Install a package with transaction handling
    pub async fn install_package(&self, package: &Package) -> DaemonResult<()> {
        info!("Installing package {} with transaction", package.name());
        
        // Create checkpoint before installation
        let checkpoint_id = uuid::Uuid::new_v4();
        self.state_manager.write().await.create_checkpoint(
            checkpoint_id,
            format!("Pre-install state for {}", package.name()),
            None,
        ).await?;

        // Begin transaction
        let mut ctx = self.begin_transaction(format!("Install package {}", package.name())).await?;
        ctx.add_operation(TransactionOperation::Install(package.clone()))?;

        // Attempt to commit
        match self.commit_transaction(ctx.id).await {
            Ok(_) => {
                info!("Successfully installed {}", package.name());
                Ok(())
            }
            Err(e) => {
                error!("Failed to install package: {}", e);
                // Restore from checkpoint
                if let Err(restore_err) = self.state_manager.write().await.restore_checkpoint(&checkpoint_id.to_string()).await {
                    error!("Failed to restore from checkpoint: {}", restore_err);
                }
                if let Err(e) = self.rollback_transaction(ctx.id).await {
                    error!("Failed to rollback installation: {}", e);
                }
                Err(e)
            }
        }
    }

    /// Update a package with transaction handling
    pub async fn update_package(&self, package: &Package, force: bool) -> DaemonResult<()> {
        info!("Updating package {} with transaction", package.name());
        
        // Create checkpoint before update
        let checkpoint_id = uuid::Uuid::new_v4();
        self.state_manager.write().await.create_checkpoint(
            checkpoint_id,
            format!("Pre-update state for {}", package.name()),
            None,
        ).await?;

        // Begin transaction
        let mut ctx = self.begin_transaction(format!("Update package {}", package.name())).await?;
        
        // Add update operation
        let operation = if force {
            TransactionOperation::Update {
                from: package.clone(),
                to: package.clone(),
            }
        } else {
            TransactionOperation::Install(package.clone())
        };
        ctx.add_operation(operation)?;

        // Attempt to commit
        match self.commit_transaction(ctx.id).await {
            Ok(_) => {
                info!("Successfully updated {}", package.name());
                Ok(())
            }
            Err(e) => {
                error!("Failed to update package: {}", e);
                // Restore from checkpoint
                if let Err(restore_err) = self.state_manager.write().await.restore_checkpoint(&checkpoint_id.to_string()).await {
                    error!("Failed to restore from checkpoint: {}", restore_err);
                }
                if let Err(e) = self.rollback_transaction(ctx.id).await {
                    error!("Failed to rollback update: {}", e);
                }
                Err(e)
            }
        }
    }

    /// Remove a package with transaction handling
    pub async fn remove_package(&self, package: &Package) -> DaemonResult<()> {
        info!("Removing package {} with transaction", package.name());
        
        // Create checkpoint before removal
        let checkpoint_id = uuid::Uuid::new_v4();
        self.state_manager.write().await.create_checkpoint(
            checkpoint_id,
            format!("Pre-remove state for {}", package.name()),
            None,
        ).await?;

        // Begin transaction
        let mut ctx = self.begin_transaction(format!("Remove package {}", package.name())).await?;
        ctx.add_operation(TransactionOperation::Uninstall(package.clone()))?;

        // Attempt to commit
        match self.commit_transaction(ctx.id).await {
            Ok(_) => {
                info!("Successfully removed {}", package.name());
                Ok(())
            }
            Err(e) => {
                error!("Failed to remove package: {}", e);
                // Restore from checkpoint
                if let Err(restore_err) = self.state_manager.write().await.restore_checkpoint(&checkpoint_id.to_string()).await {
                    error!("Failed to restore from checkpoint: {}", restore_err);
                }
                if let Err(e) = self.rollback_transaction(ctx.id).await {
                    error!("Failed to rollback removal: {}", e);
                }
                Err(e)
            }
        }
    }

    /// Add an environment with transaction handling
    pub async fn add_environment(&self, name: String, state: EnvironmentState) -> DaemonResult<()> {
        info!("Adding environment {} with transaction", name);
        
        // Create checkpoint
        let checkpoint_id = uuid::Uuid::new_v4();
        self.state_manager.write().await.create_checkpoint(
            checkpoint_id,
            format!("Pre-add environment state for {}", name),
            None,
        ).await?;

        // Begin transaction
        let mut ctx = self.begin_transaction(format!("Add environment {}", name)).await?;
        ctx.add_operation(TransactionOperation::AddEnvironment {
            name: name.clone(),
            state: state.clone(),
        })?;

        // Attempt to commit
        match self.commit_transaction(ctx.id).await {
            Ok(_) => {
                info!("Successfully added environment {}", name);
                Ok(())
            }
            Err(e) => {
                error!("Failed to add environment: {}", e);
                // Restore from checkpoint
                if let Err(restore_err) = self.state_manager.write().await.restore_checkpoint(&checkpoint_id.to_string()).await {
                    error!("Failed to restore from checkpoint: {}", restore_err);
                }
                if let Err(e) = self.rollback_transaction(ctx.id).await {
                    error!("Failed to rollback environment addition: {}", e);
                }
                Err(e)
            }
        }
    }

    /// Remove an environment with transaction handling
    pub async fn remove_environment_with_transaction(&self, name: &str) -> DaemonResult<()> {
        info!("Removing environment {} with transaction", name);
        
        // Create checkpoint
        let checkpoint_id = uuid::Uuid::new_v4();
        self.state_manager.write().await.create_checkpoint(
            checkpoint_id,
            format!("Pre-remove environment state for {}", name),
            None,
        ).await?;

        // Begin transaction
        let mut ctx = self.begin_transaction(format!("Remove environment {}", name)).await?;
        ctx.add_operation(TransactionOperation::RemoveEnvironment {
            name: name.to_string(),
        })?;

        // Attempt to commit
        match self.commit_transaction(ctx.id).await {
            Ok(_) => {
                info!("Successfully removed environment {}", name);
                Ok(())
            }
            Err(e) => {
                error!("Failed to remove environment: {}", e);
                // Restore from checkpoint
                if let Err(restore_err) = self.state_manager.write().await.restore_checkpoint(&checkpoint_id.to_string()).await {
                    error!("Failed to restore from checkpoint: {}", restore_err);
                }
                if let Err(e) = self.rollback_transaction(ctx.id).await {
                    error!("Failed to rollback environment removal: {}", e);
                }
                Err(e)
            }
        }
    }
}

/// Performance metrics snapshot
#[derive(Debug, Clone)]
pub struct PerformanceSnapshot {
    /// Average pip install time
    pub avg_pip_install_time: Duration,
    /// Average sync time
    pub avg_sync_time: Duration,
    /// Cache hit rate
    pub cache_hit_rate: f32,
    /// Timestamp of snapshot
    pub timestamp: Instant,
}

#[derive(Debug, Clone)]
pub struct DaemonEnvironment {
    pub name: String,
    pub python_version: String,
    pub path: PathBuf,
    pub last_accessed: SystemTime,
    pub active: bool,
}

impl From<Box<dyn Environment>> for DaemonEnvironment {
    fn from(env: Box<dyn Environment>) -> Self {
        Self {
            name: env.name().unwrap_or("unnamed").to_string(),
            python_version: env.python_version().to_string(),
            path: env.path().to_path_buf(),
            last_accessed: SystemTime::now(),
            active: false,
        }
    }
}

#[derive(Debug, Clone)]
pub struct EnvironmentImage {
    pub name: String,
    pub python_version: String,
    pub created: chrono::DateTime<chrono::Utc>,
}
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-daemon/src/manifest.rs

```rs
//! Daemon manifest management implementation

use std::path::PathBuf;
use std::sync::Arc;
use tokio::sync::RwLock;
use async_trait::async_trait;

use blast_core::{
    BlastResult,
    ManifestManager,
    Package,
    SystemDependency,
    Manifest,
};

/// Daemon manifest manager
#[derive(Clone)]
pub struct DaemonManifestManager {
    manifest: Arc<RwLock<Manifest>>,
    manifest_path: PathBuf,
}

impl DaemonManifestManager {
    /// Create new manifest manager
    pub async fn new(manifest_path: PathBuf) -> BlastResult<Self> {
        let manifest = if manifest_path.exists() {
            Manifest::load(&manifest_path)?
        } else {
            // Create default manifest
            let env = blast_core::python::PythonEnvironment::new(
                manifest_path.parent().unwrap().to_path_buf(),
                blast_core::python::PythonVersion::default(),
            );
            Manifest::from_environment(&env)?
        };

        Ok(Self {
            manifest: Arc::new(RwLock::new(manifest)),
            manifest_path,
        })
    }

    /// Save manifest to disk
    async fn save_manifest(&self, manifest: &Manifest) -> BlastResult<()> {
        manifest.save(&self.manifest_path)
    }
}

#[async_trait]
impl ManifestManager for DaemonManifestManager {
    async fn get_manifest(&self) -> BlastResult<Manifest> {
        Ok(self.manifest.read().await.clone())
    }

    async fn update_manifest(&self, manifest: &Manifest) -> BlastResult<()> {
        *self.manifest.write().await = manifest.clone();
        self.save_manifest(manifest).await
    }

    async fn record_package_install(&self, package: &Package) -> BlastResult<()> {
        let mut manifest = self.manifest.write().await;
        manifest.record_package_install(
            package.name.clone(),
            package.version.to_string(),
        );
        self.save_manifest(&manifest).await
    }

    async fn record_package_removal(&self, package: &Package) -> BlastResult<()> {
        let mut manifest = self.get_manifest().await?;
        manifest.remove_package(package);
        self.save_manifest(&manifest).await
    }

    async fn record_env_var_change(&self, key: &str, value: &str) -> BlastResult<()> {
        let mut manifest = self.manifest.write().await;
        manifest.record_env_var_change(key.to_string(), value.to_string());
        self.save_manifest(&manifest).await
    }

    async fn record_system_dependency(&self, dependency: &SystemDependency) -> BlastResult<()> {
        let mut manifest = self.manifest.write().await;
        manifest.record_system_dependency(dependency.clone());
        self.save_manifest().await
    }

    async fn record_hook_addition(&self, hook_type: &str, command: &str) -> BlastResult<()> {
        let mut manifest = self.manifest.write().await;
        manifest.record_hook_addition(hook_type, command.to_string());
        self.save_manifest().await
    }

    async fn verify_manifest(&self) -> BlastResult<bool> {
        let manifest = self.manifest.read().await;
        manifest.metadata.verify()
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-daemon/src/update.rs

```rs
//! Update request types and handling

use blast_core::{
    package::Package,
    state::EnvironmentState,
    python::PythonVersion,
};
use tokio::sync::{mpsc, RwLock};
use tracing::{info, debug, error};
use std::path::PathBuf;
use std::collections::HashMap;
use std::sync::Arc;
use crate::{DaemonError, DaemonResult};
use crate::monitor::{MonitorEvent, PythonResourceMonitor, PythonResourceLimits};
use crate::state::StateManager;

/// Update manager for Python environments
pub struct UpdateManager {
    /// Python resource monitor
    monitor: PythonResourceMonitor,
    /// Environment path
    env_path: PathBuf,
    /// Cache path
    cache_path: PathBuf,
    /// Channel for receiving monitor events
    monitor_rx: mpsc::Receiver<MonitorEvent>,
    /// State manager
    state_manager: Arc<RwLock<StateManager>>,
}

impl std::fmt::Debug for UpdateManager {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("UpdateManager")
            .field("monitor", &self.monitor)
            .field("env_path", &self.env_path)
            .field("cache_path", &self.cache_path)
            .field("state_manager", &self.state_manager)
            // Skip monitor_rx since it doesn't implement Debug
            .finish()
    }
}

impl UpdateManager {
    /// Create a new update manager
    pub fn new(env_path: PathBuf, cache_path: PathBuf, monitor_rx: mpsc::Receiver<MonitorEvent>) -> Self {
        debug!("Creating new UpdateManager");
        debug!("Environment path: {}", env_path.display());
        debug!("Cache path: {}", cache_path.display());
        
        Self {
            monitor: PythonResourceMonitor::new(
                env_path.clone(),
                cache_path.clone(),
                PythonResourceLimits::default(),
            ),
            env_path: env_path.clone(),
            cache_path,
            monitor_rx,
            state_manager: Arc::new(RwLock::new(StateManager::new(env_path))),
        }
    }

    /// Start processing updates
    pub async fn run(&mut self) -> DaemonResult<()> {
        info!("Starting update manager");

        // Verify paths exist
        if !self.env_path.exists() {
            debug!("Creating environment directory: {}", self.env_path.display());
            tokio::fs::create_dir_all(&self.env_path).await.map_err(|e| {
                error!("Failed to create environment directory: {}", e);
                DaemonError::environment(format!("Failed to create environment directory: {}", e))
            })?;
        }

        if !self.cache_path.exists() {
            debug!("Creating cache directory: {}", self.cache_path.display());
            tokio::fs::create_dir_all(&self.cache_path).await.map_err(|e| {
                error!("Failed to create cache directory: {}", e);
                DaemonError::environment(format!("Failed to create cache directory: {}", e))
            })?;
        }

        // Perform initial resource check
        self.handle_resource_check().await?;

        // Main event loop
        while let Some(event) = self.monitor_rx.recv().await {
            match event {
                MonitorEvent::ResourceCheck => {
                    if let Err(e) = self.handle_resource_check().await {
                        error!("Failed to handle resource check: {}", e);
                    }
                }
                MonitorEvent::StopMonitoring { env_path } => {
                    info!("Stopping monitoring for environment: {}", env_path.display());
                    break;
                }
                MonitorEvent::PackageChanged => {
                    if let Err(e) = self.sync_environment_state().await {
                        error!("Failed to sync environment state: {}", e);
                    }
                }
                MonitorEvent::FileChanged(path) => {
                    if path.starts_with(&self.env_path) && 
                       path.starts_with(self.env_path.join("lib").join("python3").join("site-packages")) {
                        if let Err(e) = self.sync_environment_state().await {
                            error!("Failed to sync environment state: {}", e);
                        }
                    }
                }
                MonitorEvent::ResourceUpdate(usage) => {
                    info!(
                        "Resource update - Env Size: {} MB, Cache Size: {} MB, Packages: {}",
                        usage.env_disk_usage.total_size / 1_048_576,
                        usage.cache_usage.total_size / 1_048_576,
                        usage.cache_usage.package_count
                    );
                }
            }
        }

        info!("Update manager shutting down");
        Ok(())
    }

    /// Sync environment state with daemon
    async fn sync_environment_state(&self) -> DaemonResult<()> {
        // Create new environment state
        let env_state = EnvironmentState::new(
            "default".to_string(),
            PythonVersion::parse("3.8.0").unwrap(),
            HashMap::new(),
            HashMap::new(),
        );

        // Update state manager
        let state_manager = self.state_manager.clone();
        let state = state_manager.write().await;
        state.update_current_state(env_state).await?;

        Ok(())
    }

    /// Check environment state
    async fn handle_resource_check(&self) -> DaemonResult<()> {
        // Check environment structure
        let required_dirs = ["bin", "lib", "include"];
        for dir in required_dirs {
            let path = self.env_path.join(dir);
            if !path.exists() {
                return Err(DaemonError::Service(
                    format!("Required directory not found: {}", path.display())
                ));
            }
        }

        Ok(())
    }
}

/// Update request types
#[derive(Debug)]
pub enum UpdateType {
    /// Package installation
    PackageInstall(Package),
    /// Package removal
    PackageRemove(Package),
    /// Environment sync
    EnvironmentSync,
    /// Package update
    PackageUpdate {
        package: Package,
        force: bool,
        update_deps: bool,
    }
}

/// Update request structure
#[derive(Debug)]
pub struct UpdateRequest {
    /// Request ID
    pub id: String,
    /// Update type
    pub update_type: UpdateType,
}

impl UpdateRequest {
    /// Create a new package update request
    pub fn new_update(package: Package, force: bool, update_deps: bool) -> Self {
        Self {
            id: uuid::Uuid::new_v4().to_string(),
            update_type: UpdateType::PackageUpdate {
                package,
                force,
                update_deps,
            },
        }
    }

    /// Create a new package install request
    pub fn new_install(package: Package) -> Self {
        Self {
            id: uuid::Uuid::new_v4().to_string(),
            update_type: UpdateType::PackageInstall(package),
        }
    }

    /// Create a new package remove request
    pub fn new_remove(package: Package) -> Self {
        Self {
            id: uuid::Uuid::new_v4().to_string(),
            update_type: UpdateType::PackageRemove(package),
        }
    }

    /// Create a new environment sync request
    pub fn new_sync() -> Self {
        Self {
            id: uuid::Uuid::new_v4().to_string(),
            update_type: UpdateType::EnvironmentSync,
        }
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-daemon/src/state_manager.rs

```rs
use std::collections::HashMap;
use std::path::PathBuf;
use std::sync::Arc;
use tokio::sync::RwLock;
use uuid::Uuid;
use chrono::{DateTime, Utc};
use tokio::fs;
use serde_json;

use blast_core::{
    error::BlastResult,
    package::Package,
    state::{EnvironmentState, StateVerification},
    python::PythonVersion,
};

use crate::{
    DaemonError,
    DaemonResult,
    metrics::MetricsManager,
};

const STATE_FILE: &str = "daemon_state.json";

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
struct PersistentState {
    current_state: EnvironmentState,
    history: Vec<StateSnapshot>,
}

/// State manager for the daemon
#[derive(Debug)]
pub struct StateManager {
    /// Current environment state
    state: Arc<RwLock<EnvironmentState>>,
    /// State history for rollbacks
    history: Arc<RwLock<Vec<StateSnapshot>>>,
    /// Metrics manager
    metrics: Arc<MetricsManager>,
    /// Environment path
    env_path: PathBuf,
    /// State file path
    state_file: PathBuf,
}

/// Snapshot of daemon state
#[derive(Debug, Clone)]
pub struct StateSnapshot {
    /// Snapshot ID
    pub id: Uuid,
    /// Snapshot timestamp
    pub timestamp: DateTime<Utc>,
    /// Environment state
    pub state: EnvironmentState,
    /// Verification result
    pub verification: Option<StateVerification>,
    /// Description
    pub description: String,
}

impl StateManager {
    /// Create a new state manager
    pub fn new(env_path: PathBuf, metrics: Arc<MetricsManager>) -> Self {
        let state_file = env_path.join(STATE_FILE);
        let initial_state = EnvironmentState::new(
            "default".to_string(),
            PythonVersion::parse("3.8.0").unwrap(),
            HashMap::new(),
            HashMap::new(),
        );

        let instance = Self {
            state: Arc::new(RwLock::new(initial_state)),
            history: Arc::new(RwLock::new(Vec::new())),
            metrics,
            env_path: env_path.clone(),
            state_file,
        };

        // Try to load existing state
        tokio::spawn(async move {
            if let Err(e) = instance.load_state().await {
                tracing::error!("Failed to load state: {}", e);
            }
        });

        instance
    }

    /// Load state from disk
    async fn load_state(&self) -> DaemonResult<()> {
        if self.state_file.exists() {
            let contents = fs::read_to_string(&self.state_file).await
                .map_err(|e| DaemonError::State(format!("Failed to read state file: {}", e)))?;
            
            let persistent_state: PersistentState = serde_json::from_str(&contents)
                .map_err(|e| DaemonError::State(format!("Failed to parse state file: {}", e)))?;
            
            *self.state.write().await = persistent_state.current_state;
            *self.history.write().await = persistent_state.history;
        }
        Ok(())
    }

    /// Save state to disk
    async fn save_state(&self) -> DaemonResult<()> {
        let persistent_state = PersistentState {
            current_state: self.state.read().await.clone(),
            history: self.history.read().await.clone(),
        };

        let contents = serde_json::to_string_pretty(&persistent_state)
            .map_err(|e| DaemonError::State(format!("Failed to serialize state: {}", e)))?;
        
        fs::write(&self.state_file, contents).await
            .map_err(|e| DaemonError::State(format!("Failed to write state file: {}", e)))?;
        
        Ok(())
    }

    /// Update current state
    pub async fn update_current_state(&self, new_state: EnvironmentState) -> DaemonResult<()> {
        *self.state.write().await = new_state;
        self.save_state().await
    }

    /// Get current state
    pub async fn get_current_state(&self) -> DaemonResult<EnvironmentState> {
        Ok(self.state.read().await.clone())
    }

    /// Create a state snapshot
    pub async fn create_snapshot(&self, description: String) -> DaemonResult<Uuid> {
        let state = self.state.read().await.clone();
        let snapshot = StateSnapshot {
            id: Uuid::new_v4(),
            timestamp: Utc::now(),
            state,
            verification: None,
            description,
        };

        self.history.write().await.push(snapshot.clone());
        Ok(snapshot.id)
    }

    /// Get a state snapshot
    pub async fn get_snapshot(&self, id: Uuid) -> DaemonResult<Option<StateSnapshot>> {
        Ok(self.history.read().await.iter()
            .find(|s| s.id == id)
            .cloned())
    }

    /// Restore from a snapshot
    pub async fn restore_snapshot(&self, id: Uuid) -> DaemonResult<()> {
        let snapshot = self.get_snapshot(id).await?
            .ok_or_else(|| DaemonError::State(format!("Snapshot {} not found", id)))?;

        // Create a new snapshot of current state before restoring
        self.create_snapshot("Pre-restore state".to_string()).await?;

        // Restore state
        *self.state.write().await = snapshot.state;

        // Record metrics
        self.metrics.record_state_restore(id).await;

        Ok(())
    }

    /// Update environment state
    pub async fn update_state(&self, packages: &[Package]) -> DaemonResult<()> {
        let mut state = self.state.write().await;
        
        // Create snapshot before update
        let snapshot_id = self.create_snapshot("Pre-update state".to_string()).await?;

        // Update packages
        for package in packages {
            state.packages.insert(
                package.name().to_string(),
                package.version().clone(),
            );
        }

        // Record metrics
        self.metrics.record_state_update(snapshot_id, packages.len()).await;

        Ok(())
    }

    /// Verify current state
    pub async fn verify_state(&self) -> DaemonResult<StateVerification> {
        let state = self.state.read().await;
        let mut verification = StateVerification::default();

        // Verify environment structure
        if !self.env_path.exists() {
            verification.add_error(
                "Environment directory not found".to_string(),
                None,
            );
        }

        // Verify Python installation
        let python_path = self.env_path.join("bin").join("python");
        if !python_path.exists() {
            verification.add_error(
                "Python executable not found".to_string(),
                None,
            );
        }

        // Verify package installations
        for (name, version) in &state.packages {
            let site_packages = self.env_path
                .join("lib")
                .join("python3")
                .join("site-packages")
                .join(name);

            if !site_packages.exists() {
                verification.add_warning(
                    format!("Package {} installation not found", name),
                    Some(format!("Version: {}", version)),
                );
            }
        }

        Ok(verification)
    }

    /// Clean up old snapshots
    pub async fn cleanup_snapshots(&self, max_age: chrono::Duration) -> DaemonResult<usize> {
        let now = Utc::now();
        let mut history = self.history.write().await;
        let initial_len = history.len();

        history.retain(|snapshot| {
            now.signed_duration_since(snapshot.timestamp) <= max_age
        });

        Ok(initial_len - history.len())
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-daemon/src/service.rs

```rs
//! Update service for processing package updates

use std::sync::Arc;
use std::time::Duration;
use std::path::PathBuf;
use tokio::sync::{broadcast, mpsc, Mutex as TokioMutex};
use tracing::{error, info};
use uuid::Uuid;
use chrono::Utc;
use std::collections::HashMap;

use blast_core::{
    package::Package,
    python::PythonVersion,
    state::EnvironmentState,
    version_history::{VersionEvent, VersionImpact},
    error::BlastResult,
};

use blast_core::version_control::{VersionManager, VersionPolicy};
use blast_resolver::{DependencyResolver, PyPIClient, Cache};

use crate::{
    DaemonError,
    DaemonResult,
    update::{UpdateType, UpdateRequest},
    transaction::{TransactionOperation, TransactionManager, TransactionContext, TransactionStatus},
    monitor::{MonitorEvent, EnvironmentUsage, PythonResourceMonitor},
    state::{StateManager, Checkpoint},
    metrics::MetricsManager,
    environment::EnvironmentManager,
};

/// Internal state for the update service
pub(crate) struct UpdateServiceState {
    /// Python resource monitor
    monitor: PythonResourceMonitor,
    /// Dependency resolver
    resolver: Arc<DependencyResolver>,
    /// Transaction manager
    transaction_manager: TransactionManager,
    /// Version manager
    version_manager: VersionManager,
    /// State manager
    state_manager: StateManager,
    /// Environment manager
    environment_manager: Arc<EnvironmentManager>,
}

// Manual Debug implementation to handle non-Debug DependencyResolver
impl std::fmt::Debug for UpdateServiceState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("UpdateServiceState")
            .field("monitor", &self.monitor)
            .field("resolver", &"<DependencyResolver>")
            .field("transaction_manager", &self.transaction_manager)
            .field("version_manager", &"<VersionManager>")
            .field("state_manager", &"<StateManager>")
            .field("environment_manager", &"<EnvironmentManager>")
            .finish()
    }
}

impl UpdateServiceState {
    /// Create a new instance with the given paths and default configuration
    fn new(env_path: PathBuf, cache_path: PathBuf) -> DaemonResult<Self> {
        // Initialize PyPI client with reasonable timeouts
        let pypi_client = PyPIClient::new(
            30, // connect timeout in seconds
            60, // request timeout in seconds
            false, // don't verify SSL (set to true in production)
        ).map_err(|e| DaemonError::Resolver(e.to_string()))?;
        
        let cache = Cache::new(cache_path.clone());
        let _metrics = Arc::new(MetricsManager::new(1000)); // Keep last 1000 operations
        
        Ok(Self {
            monitor: PythonResourceMonitor::new(
                env_path.clone(),
                cache_path,
                Default::default(),
            ),
            resolver: Arc::new(DependencyResolver::new(pypi_client, cache)),
            transaction_manager: TransactionManager::new(EnvironmentState::new(
                "default".to_string(),
                PythonVersion::parse("3.8.0").unwrap(),
                Default::default(),
                Default::default(),
            )),
            version_manager: VersionManager::new(VersionPolicy::default()),
            state_manager: StateManager::new(env_path.clone()),
            environment_manager: Arc::new(EnvironmentManager::new(env_path)),
        })
    }
}

/// Service for managing Python environment updates
#[derive(Debug)]
pub struct UpdateService {
    /// Shared service state
    state: Arc<TokioMutex<UpdateServiceState>>,
    /// Channel for receiving update requests
    update_rx: mpsc::Receiver<UpdateRequest>,
    /// Channel for sending shutdown signals
    shutdown_rx: broadcast::Receiver<()>,
}

/// Daemon service for handling updates and monitoring
#[derive(Debug)]
pub struct DaemonService {
    /// Channel for sending monitor events
    monitor_tx: mpsc::Sender<MonitorEvent>,
    /// Update service state
    state: Arc<TokioMutex<UpdateServiceState>>,
    /// Channel for sending update requests
    update_tx: Option<mpsc::Sender<UpdateRequest>>,
    /// Channel for sending shutdown signals
    shutdown_tx: Option<broadcast::Sender<()>>,
}

impl UpdateService {
    /// Create a new update service
    pub(crate) fn new(env_path: PathBuf, cache_path: PathBuf) -> DaemonResult<(Self, Arc<TokioMutex<UpdateServiceState>>, mpsc::Sender<UpdateRequest>, broadcast::Sender<()>)> {
        let (update_tx, update_rx) = mpsc::channel(100);
        let (shutdown_tx, shutdown_rx) = broadcast::channel(1);
        
        let state = Arc::new(TokioMutex::new(UpdateServiceState::new(env_path, cache_path)?));

        Ok((Self {
            state: state.clone(),
            update_rx,
            shutdown_rx,
        }, state, update_tx, shutdown_tx))
    }

    /// Run the update service
    pub(crate) async fn run(mut self) -> DaemonResult<()> {
        info!("Starting update service");

        let mut update_interval = tokio::time::interval(Duration::from_secs(60));

        loop {
            tokio::select! {
                _ = update_interval.tick() => {
                    let mut state = self.state.lock().await;
                    if !state.monitor.check_limits() {
                        let usage = state.monitor.get_current_usage();
                        error!(
                            "Resource limits exceeded - Env Size: {} MB, Cache Size: {} MB",
                            usage.env_disk_usage.total_size / 1_048_576,
                            usage.cache_usage.total_size / 1_048_576
                        );
                        return Err(DaemonError::ResourceLimit(
                            "Python environment resource limits exceeded".to_string()
                        ));
                    }

                    // Verify environment state periodically
                    if let Err(e) = state.state_manager.verify_state().await {
                        error!("State verification failed: {}", e);
                    }

                    // Clean up old snapshots
                    if let Err(e) = state.state_manager.cleanup_old_snapshots(7).await {
                        error!("Failed to clean up old snapshots: {}", e);
                    }
                }
                
                Some(request) = self.update_rx.recv() => {
                    if let Err(e) = self.handle_update_request(request).await {
                        error!("Update processing failed: {}", e);
                    }
                }
                
                _ = self.shutdown_rx.recv() => {
                    info!("Received shutdown signal");
                    break;
                }
            }
        }

        Ok(())
    }

    /// Handle an update request
    async fn handle_update_request(&mut self, request: UpdateRequest) -> DaemonResult<()> {
        match &request.update_type {
            UpdateType::PackageUpdate { package, force, update_deps } => {
                self.handle_package_update(package, *force, *update_deps).await
            },
            UpdateType::PackageInstall(package) => {
                self.handle_package_install(package).await
            },
            UpdateType::PackageRemove(package) => {
                self.handle_package_remove(package).await
            },
            UpdateType::EnvironmentSync => {
                self.handle_environment_sync().await
            }
        }
    }

    async fn handle_package_update(&mut self, package: &Package, force: bool, update_deps: bool) -> DaemonResult<()> {
        info!("Processing update request for {}", package.name());
        
        let mut state = self.state.lock().await;
        
        // Check version policy
        if !force {
            if let Some(history) = state.version_manager.get_history(package.name()) {
                if let Some(current_version) = &history.current_version {
                    if !state.version_manager.check_upgrade_allowed(package, package.version())? {
                        return Err(DaemonError::Version(format!(
                            "Upgrade from {} to {} is not allowed by version policy",
                            current_version,
                            package.version()
                        )));
                    }
                }
            }
        }
        
        // Create checkpoint before update
        let checkpoint_id = Uuid::new_v4();
        state.state_manager.create_checkpoint(
            checkpoint_id,
            format!("Pre-update state for {}", package.name()),
            None,
        ).await?;
        
        // Begin transaction
        let mut ctx = state.transaction_manager.begin_transaction(format!("Update package {}", package.name())).await?;
        
        // Resolve dependencies
        let dependencies = state.resolver.resolve(package).await
            .map_err(|e| DaemonError::Resolver(format!("Failed to resolve dependencies: {}", e)))?;
        
        // Add operations
        let operation = if force {
            TransactionOperation::Update {
                from: package.clone(),
                to: package.clone(),
            }
        } else {
            TransactionOperation::Install(package.clone())
        };
        
        ctx.add_operation(operation)?;
        
        if update_deps {
            for dep in &dependencies {
                ctx.add_operation(TransactionOperation::Install(dep.clone()))?;
            }
        }
        
        // Commit transaction
        match state.transaction_manager.commit_transaction(ctx.id).await {
            Ok(_) => {
                // Update state
                let current_state = state.state_manager.get_current_state().await?;
                let event = VersionEvent {
                    timestamp: Utc::now(),
                    from_version: None,
                    to_version: package.version().clone(),
                    impact: VersionImpact::None,
                    reason: format!("Installation via direct request"),
                    python_version: current_state.python_version.clone(),
                    is_direct: true,
                    affected_dependencies: Default::default(),
                    approved: true,
                    approved_by: None,
                    policy_snapshot: None,
                };
                state.state_manager.add_package_with_event(package, event).await?;
                
                state.version_manager.add_installation(
                    package,
                    true,
                    &PythonVersion::parse("3.8").unwrap(),
                    "User requested update".to_string(),
                );
                info!("Successfully processed update for {}", package.name());
                Ok(())
            }
            Err(e) => {
                error!("Failed to commit transaction: {}", e);
                // Restore from checkpoint
                if let Err(restore_err) = state.state_manager.restore_checkpoint(&checkpoint_id.to_string()).await {
                    error!("Failed to restore from snapshot: {}", restore_err);
                }
                if let Err(e) = state.transaction_manager.rollback_transaction(ctx.id).await {
                    error!("Failed to rollback transaction: {}", e);
                }
                Err(e)
            }
        }
    }

    async fn handle_package_install(&mut self, package: &Package) -> DaemonResult<()> {
        info!("Processing install request for {}", package.name());
        
        let mut state = self.state.lock().await;
        
        // Create checkpoint
        let checkpoint_id = Uuid::new_v4();
        state.state_manager.create_checkpoint(
            checkpoint_id,
            format!("Pre-install state for {}", package.name()),
            None,
        ).await?;
        
        let mut ctx = state.transaction_manager.begin_transaction(format!("Install package {}", package.name())).await?;
        ctx.add_operation(TransactionOperation::Install(package.clone()))?;
        
        match state.transaction_manager.commit_transaction(ctx.id).await {
            Ok(_) => {
                // Update state
                let current_state = state.state_manager.get_current_state().await?;
                let event = VersionEvent {
                    timestamp: Utc::now(),
                    from_version: None,
                    to_version: package.version().clone(),
                    impact: VersionImpact::None,
                    reason: format!("Installation via direct request"),
                    python_version: current_state.python_version.clone(),
                    is_direct: true,
                    affected_dependencies: Default::default(),
                    approved: true,
                    approved_by: None,
                    policy_snapshot: None,
                };
                state.state_manager.add_package_with_event(package, event).await?;
                
                state.version_manager.add_installation(
                    package,
                    true,
                    &PythonVersion::parse("3.8").unwrap(),
                    "User requested install".to_string(),
                );
                info!("Successfully installed {}", package.name());
                Ok(())
            }
            Err(e) => {
                error!("Failed to install package: {}", e);
                // Restore from checkpoint
                if let Err(restore_err) = state.state_manager.restore_checkpoint(&checkpoint_id.to_string()).await {
                    error!("Failed to restore from checkpoint: {}", restore_err);
                }
                if let Err(e) = state.transaction_manager.rollback_transaction(ctx.id).await {
                    error!("Failed to rollback installation: {}", e);
                }
                Err(e.into())
            }
        }
    }

    async fn handle_package_remove(&mut self, package: &Package) -> DaemonResult<()> {
        info!("Processing remove request for {}", package.name());
        
        let state = self.state.lock().await;
        
        // Create checkpoint
        let checkpoint_id = Uuid::new_v4();
        state.state_manager.create_checkpoint(
            checkpoint_id,
            format!("Pre-remove state for {}", package.name()),
            None,
        ).await?;
        
        let mut ctx = state.transaction_manager.begin_transaction(format!("Remove package {}", package.name())).await?;
        ctx.add_operation(TransactionOperation::Uninstall(package.clone()))?;
        
        match state.transaction_manager.commit_transaction(ctx.id).await {
            Ok(_) => {
                info!("Successfully removed {}", package.name());
                Ok(())
            }
            Err(e) => {
                error!("Failed to remove package: {}", e);
                // Restore from checkpoint
                if let Err(restore_err) = state.state_manager.restore_checkpoint(&checkpoint_id.to_string()).await {
                    error!("Failed to restore from checkpoint: {}", restore_err);
                }
                if let Err(e) = state.transaction_manager.rollback_transaction(ctx.id).await {
                    error!("Failed to rollback removal: {}", e);
                }
                Err(e)
            }
        }
    }

    async fn handle_environment_sync(&mut self) -> DaemonResult<()> {
        info!("Processing environment sync request");
        
        let state = self.state.lock().await;
        
        // Create checkpoint
        let checkpoint_id = Uuid::new_v4();
        state.state_manager.create_checkpoint(
            checkpoint_id,
            "Pre-sync state".to_string(),
            None,
        ).await?;
        
        // Verify current state
        if let Err(e) = state.state_manager.verify_state().await {
            error!("State verification failed: {}", e);
            // Restore from checkpoint
            if let Err(restore_err) = state.state_manager.restore_checkpoint(&checkpoint_id.to_string()).await {
                error!("Failed to restore from checkpoint: {}", restore_err);
            }
            return Err(e.into());
        }
        
        Ok(())
    }
}

impl DaemonService {
    /// Create a new daemon service
    pub fn new(monitor_tx: mpsc::Sender<MonitorEvent>) -> DaemonResult<Self> {
        let env_path = PathBuf::from("environments/default");
        let cache_path = PathBuf::from("cache");
        
        let state = Arc::new(TokioMutex::new(UpdateServiceState::new(env_path, cache_path)?));
        
        Ok(Self {
            monitor_tx,
            state,
            update_tx: None,
            shutdown_tx: None,
        })
    }

    /// Start the daemon service
    pub async fn start(&mut self) -> DaemonResult<()> {
        info!("Starting daemon service");
        
        // Create and start update service
        let env_path = PathBuf::from("environments/default");
        let cache_path = PathBuf::from("cache");
        
        let (service, state, update_tx, shutdown_tx) = UpdateService::new(env_path, cache_path)?;
        
        // Store shared state and channels
        self.state = state;
        self.update_tx = Some(update_tx);
        self.shutdown_tx = Some(shutdown_tx);
        
        // Spawn the service task
        let service_handle = tokio::spawn(async move {
            if let Err(e) = service.run().await {
                error!("Update service error: {}", e);
            }
        });
        
        // Monitor service handle
        tokio::spawn(async move {
            if let Err(e) = service_handle.await {
                error!("Update service task error: {}", e);
            }
        });
        
        Ok(())
    }

    /// Stop the daemon service
    pub async fn stop(&mut self) -> DaemonResult<()> {
        info!("Stopping daemon service");
        
        // Send shutdown signal
        if let Some(shutdown_tx) = self.shutdown_tx.take() {
            let _ = shutdown_tx.send(());
        }
        
        // Clear state
        let env_path = PathBuf::from("environments/default");
        let cache_path = PathBuf::from("cache");
        self.state = Arc::new(TokioMutex::new(UpdateServiceState::new(env_path, cache_path)?));
        self.update_tx = None;
        
        Ok(())
    }

    /// Notify about resource usage
    pub async fn notify_resource_usage(&self, usage: EnvironmentUsage) -> DaemonResult<()> {
        self.monitor_tx.send(MonitorEvent::ResourceUpdate(usage))
            .await
            .map_err(|e| DaemonError::Monitor(e.to_string()))?;
        Ok(())
    }

    /// Notify about package changes
    pub async fn notify_package_change(&self) -> DaemonResult<()> {
        self.monitor_tx.send(MonitorEvent::PackageChanged)
            .await
            .map_err(|e| DaemonError::Monitor(e.to_string()))?;
        Ok(())
    }

    /// Send an update request
    pub async fn send_update_request(&self, request: UpdateRequest) -> DaemonResult<()> {
        if let Some(tx) = &self.update_tx {
            tx.send(request).await.map_err(|_| DaemonError::Service("Update channel closed".to_string()))?;
            Ok(())
        } else {
            Err(DaemonError::Service("Service not started".to_string()))
        }
    }

    pub async fn cleanup_old_snapshots(&self, max_age_days: u64) -> DaemonResult<()> {
        let state = self.state.lock().await;
        state.state_manager.cleanup_old_snapshots(max_age_days).await?;
        Ok(())
    }

    pub async fn begin_transaction(&self, description: String) -> DaemonResult<TransactionContext> {
        let state = self.state.lock().await;
        state.transaction_manager.begin_transaction(description).await
    }

    pub async fn commit_transaction(&self, id: Uuid) -> DaemonResult<()> {
        let state = self.state.lock().await;
        state.transaction_manager.commit_transaction(id).await
    }

    pub async fn rollback_transaction(&self, id: Uuid) -> DaemonResult<()> {
        let state = self.state.lock().await;
        state.transaction_manager.rollback_transaction(id).await
    }

    pub async fn get_current_state(&self) -> DaemonResult<EnvironmentState> {
        let state = self.state.lock().await;
        state.state_manager.get_current_state().await.map_err(Into::into)
    }

    pub async fn list_checkpoints(&self) -> DaemonResult<Vec<Checkpoint>> {
        let state = self.state.lock().await;
        state.state_manager.list_checkpoints().await.map_err(Into::into)
    }

    pub async fn get_checkpoint(&self, id: &str) -> DaemonResult<Option<Checkpoint>> {
        let state = self.state.lock().await;
        state.state_manager.get_checkpoint(id).await.map_err(Into::into)
    }

    pub async fn create_environment(&self, name: String, python_version: PythonVersion) -> DaemonResult<()> {
        let state = self.state.lock().await;
        
        // Create environment using environment manager
        let _env = state.environment_manager.create_environment(&name, &python_version).await.map_err(|e: blast_core::error::BlastError| DaemonError::from(e))?;
        
        let env_state = EnvironmentState::new(
            name.clone(),
            python_version,
            HashMap::new(),
            HashMap::new(),
        );

        state.state_manager.add_environment(name, env_state).await.map_err(|e: blast_core::error::BlastError| DaemonError::from(e))?;
        Ok(())
    }

    pub async fn remove_environment(&self, name: &str) -> DaemonResult<()> {
        let state = self.state.lock().await;
        state.state_manager.remove_environment(name).await.map_err(|e: blast_core::error::BlastError| DaemonError::from(e))
    }

    pub async fn activate_environment(&self, name: String) -> DaemonResult<()> {
        let state = self.state.lock().await;
        let env_state = state.state_manager.get_current_state().await.map_err(|e: blast_core::error::BlastError| DaemonError::from(e))?;
        
        // Create environment using environment manager
        let env = state.environment_manager.create_environment(&name, &env_state.python_version).await.map_err(|e: blast_core::error::BlastError| DaemonError::from(e))?;
        
        state.state_manager.set_active_environment(
            name,
            env.path().to_path_buf(),
            env_state.python_version.clone(),
        ).await.map_err(|e: blast_core::error::BlastError| DaemonError::from(e))
    }

    pub async fn deactivate_environment(&self) -> DaemonResult<()> {
        let state = self.state.lock().await;
        state.state_manager.clear_active_environment().await.map_err(Into::into)
    }

    /// Check if there are any pending updates
    pub async fn has_pending_updates(&self) -> bool {
        let state = self.state.lock().await;
        
        // Get current state
        let current_state = match state.state_manager.get_current_state().await {
            Ok(state) => state,
            Err(_) => return false,
        };
        
        // Check current state against blast.toml config
        let config_path = state.environment_manager.as_ref().root_path().join("blast.toml");
        if let Ok(config) = blast_core::config::BlastConfig::from_file(&config_path) {
            // Check Python version mismatch
            if current_state.python_version != config.python_version {
                return true;
            }

            // Check package version mismatches
            for package in &config.dependencies.packages {
                if let Some(current_version) = current_state.packages.get(&package.name) {
                    if current_version.to_string() != package.version {
                        return true;
                    }
                } else {
                    return true;
                }
            }

            // Check for packages installed but not in config
            for name in current_state.packages.keys() {
                if !config.dependencies.packages.iter().any(|p| &p.name == name) {
                    return true;
                }
            }
        }

        // Check for pending transactions
        let transactions = state.transaction_manager.list_active_transactions().await;
        if let Ok(transactions) = transactions {
            if transactions.values().any(|t| matches!(t.status, TransactionStatus::Pending)) {
                return true;
            }
        }

        false
    }

    /// Process pending updates
    pub async fn process_updates(&mut self) -> BlastResult<()> {
        // Check for resource usage
        self.monitor_tx.send(MonitorEvent::ResourceCheck).await
            .map_err(|e| DaemonError::monitor(format!("Failed to send resource check: {}", e)))?;

        // Begin a new transaction for processing updates
        let transaction_id = {
            let state = self.state.lock().await;
            let ctx = state.transaction_manager.begin_transaction("Process pending updates".to_string()).await?;
            ctx.id
        };
        
        // Process the transaction
        self.process_transaction_by_id(transaction_id).await?;
        
        // Commit the transaction if successful
        let state = self.state.lock().await;
        state.transaction_manager.commit_transaction(transaction_id).await?;

        Ok(())
    }

    async fn process_transaction_by_id(&mut self, transaction_id: Uuid) -> BlastResult<()> {
        let transaction = {
            let state = self.state.lock().await;
            // Get the transaction details
            let mut ctx = state.transaction_manager.begin_transaction("Get transaction details".to_string()).await?;
            ctx.id = transaction_id;
            ctx
        };

        self.process_transaction(&transaction).await
    }

    async fn process_transaction(&mut self, transaction: &TransactionContext) -> BlastResult<()> {
        let _state = self.state.lock().await;
        for operation in &transaction.operations {
            match operation {
                TransactionOperation::Install(package) => {
                    // Handle package installation
                    info!("Processing install transaction for package: {:?}", package);
                }
                TransactionOperation::Uninstall(package) => {
                    // Handle package uninstallation
                    info!("Processing uninstall transaction for package: {:?}", package);
                }
                TransactionOperation::Update { from, to } => {
                    // Handle package update
                    info!("Processing update transaction from {:?} to {:?}", from, to);
                }
                TransactionOperation::AddEnvironment { name, state: env_state, .. } => {
                    // Handle environment addition
                    info!("Processing add environment: {} with state: {:?}", name, env_state);
                }
                TransactionOperation::RemoveEnvironment { name } => {
                    // Handle environment removal
                    info!("Processing remove environment: {}", name);
                }
            }
        }
        Ok(())
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-daemon/src/metrics.rs

```rs
use std::collections::HashMap;
use std::sync::Arc;
use std::time::{Duration, Instant};
use tokio::sync::RwLock;
use tracing::info;
use uuid::Uuid;

/// Performance metrics for package operations
#[derive(Debug, Clone)]
pub struct PackageMetrics {
    /// Time taken for pip installation
    pub pip_install_duration: Duration,
    /// Time taken for environment synchronization
    pub sync_duration: Duration,
    /// Package name
    pub package_name: String,
    /// Package version
    pub package_version: String,
    /// Number of dependencies
    pub dependency_count: usize,
    /// Cache hit rate
    pub cache_hit_rate: f32,
    /// Memory usage during operation
    pub memory_usage: u64,
    /// Timestamp of operation
    pub timestamp: Instant,
}

/// Metrics for environment operations
#[derive(Debug, Clone)]
pub struct EnvironmentMetrics {
    /// Total number of packages
    pub total_packages: usize,
    /// Environment size
    pub env_size: u64,
    /// Cache size
    pub cache_size: u64,
    /// Average sync duration
    pub avg_sync_duration: Duration,
    /// Last update timestamp
    pub last_update: Instant,
}

/// Performance metrics manager
#[derive(Debug)]
pub struct MetricsManager {
    /// Package operation metrics
    package_metrics: Arc<RwLock<HashMap<Uuid, PackageMetrics>>>,
    /// Environment metrics
    environment_metrics: Arc<RwLock<HashMap<String, EnvironmentMetrics>>>,
    /// Rolling average window (in operations)
    metrics_window: usize,
}

impl MetricsManager {
    /// Create a new metrics manager
    pub fn new(metrics_window: usize) -> Self {
        Self {
            package_metrics: Arc::new(RwLock::new(HashMap::new())),
            environment_metrics: Arc::new(RwLock::new(HashMap::new())),
            metrics_window,
        }
    }

    /// Record package installation metrics
    pub async fn record_package_install(
        &self,
        operation_id: Uuid,
        package_name: String,
        package_version: String,
        pip_duration: Duration,
        sync_duration: Duration,
        dependency_count: usize,
        cache_hits: usize,
        memory_usage: u64,
    ) {
        let metrics = PackageMetrics {
            pip_install_duration: pip_duration,
            sync_duration,
            package_name,
            package_version,
            dependency_count,
            cache_hit_rate: if dependency_count > 0 {
                cache_hits as f32 / dependency_count as f32
            } else {
                0.0
            },
            memory_usage,
            timestamp: Instant::now(),
        };

        let mut package_metrics = self.package_metrics.write().await;
        package_metrics.insert(operation_id, metrics.clone());

        // Maintain rolling window
        if package_metrics.len() > self.metrics_window {
            let oldest = package_metrics.iter()
                .min_by_key(|(_, m)| m.timestamp)
                .map(|(k, _)| *k);
            if let Some(key) = oldest {
                package_metrics.remove(&key);
            }
        }

        info!(
            "Package install metrics - Package: {} v{}, Pip: {:?}, Sync: {:?}, Deps: {}, Cache hit rate: {:.2}",
            metrics.package_name,
            metrics.package_version,
            metrics.pip_install_duration,
            metrics.sync_duration,
            metrics.dependency_count,
            metrics.cache_hit_rate
        );
    }

    /// Update environment metrics
    pub async fn update_environment_metrics(
        &self,
        env_name: String,
        total_packages: usize,
        env_size: u64,
        cache_size: u64,
        sync_duration: Duration,
    ) {
        let mut env_metrics = self.environment_metrics.write().await;
        
        let metrics = env_metrics
            .entry(env_name.clone())
            .or_insert_with(|| EnvironmentMetrics {
                total_packages: 0,
                env_size: 0,
                cache_size: 0,
                avg_sync_duration: Duration::from_secs(0),
                last_update: Instant::now(),
            });

        // Update rolling average for sync duration
        metrics.avg_sync_duration = Duration::from_nanos(
            ((metrics.avg_sync_duration.as_nanos() as f64 * 0.9) +
             (sync_duration.as_nanos() as f64 * 0.1)) as u64
        );

        metrics.total_packages = total_packages;
        metrics.env_size = env_size;
        metrics.cache_size = cache_size;
        metrics.last_update = Instant::now();

        info!(
            "Environment metrics - Env: {}, Packages: {}, Size: {} MB, Cache: {} MB, Avg sync: {:?}",
            env_name,
            metrics.total_packages,
            metrics.env_size / 1_048_576,
            metrics.cache_size / 1_048_576,
            metrics.avg_sync_duration
        );
    }

    /// Get package metrics for an operation
    pub async fn get_package_metrics(&self, operation_id: &Uuid) -> Option<PackageMetrics> {
        self.package_metrics.read().await.get(operation_id).cloned()
    }

    /// Get environment metrics
    pub async fn get_environment_metrics(&self, env_name: &str) -> Option<EnvironmentMetrics> {
        self.environment_metrics.read().await.get(env_name).cloned()
    }

    /// Get average package installation times
    pub async fn get_average_install_times(&self) -> (Duration, Duration) {
        let metrics = self.package_metrics.read().await;
        
        if metrics.is_empty() {
            return (Duration::from_secs(0), Duration::from_secs(0));
        }

        let total: (Duration, Duration) = metrics.values()
            .fold((Duration::from_secs(0), Duration::from_secs(0)), |acc, m| {
                (acc.0 + m.pip_install_duration, acc.1 + m.sync_duration)
            });

        let count = metrics.len() as u32;
        (
            Duration::from_nanos(total.0.as_nanos() as u64 / count as u64),
            Duration::from_nanos(total.1.as_nanos() as u64 / count as u64)
        )
    }

    /// Get overall cache hit rate
    pub async fn get_cache_hit_rate(&self) -> f32 {
        let metrics = self.package_metrics.read().await;
        let total_hits: usize = metrics.values()
            .map(|m| (m.cache_hit_rate * m.dependency_count as f32) as usize)
            .sum();
        let total_deps: usize = metrics.values()
            .map(|m| m.dependency_count)
            .sum();
        
        if total_deps > 0 {
            total_hits as f32 / total_deps as f32
        } else {
            0.0
        }
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-daemon/src/validation.rs

```rs
use std::collections::{HashMap, HashSet};
use petgraph::{Graph, Directed};
use petgraph::graph::NodeIndex;
use petgraph::algo::kosaraju_scc;

use blast_core::{
    error::BlastResult,
    package::Package,
    version::Version,
};

use crate::error::DaemonResult;

/// Result of dependency validation
#[derive(Debug, Clone)]
pub struct ValidationResult {
    /// Whether the graph is valid
    pub is_valid: bool,
    /// List of validation issues found
    pub issues: Vec<ValidationIssue>,
    /// Graph metrics
    pub metrics: ValidationMetrics,
}

/// Validation issue types
#[derive(Debug, Clone)]
pub enum ValidationIssue {
    /// Circular dependency detected
    CircularDependency {
        packages: Vec<String>,
    },
    /// Version conflict detected
    VersionConflict {
        package: String,
        required_versions: Vec<Version>,
    },
    /// Missing dependency
    MissingDependency {
        package: String,
        required_by: String,
    },
    /// Python version conflict
    PythonVersionConflict {
        package: String,
        version_constraints: Vec<String>,
    },
}

/// Validation metrics
#[derive(Debug, Clone)]
pub struct ValidationMetrics {
    /// Number of packages checked
    pub packages_checked: usize,
    /// Number of dependencies checked
    pub dependencies_checked: usize,
    /// Maximum dependency depth
    pub max_depth: usize,
    /// Number of version constraints checked
    pub version_constraints_checked: usize,
}

/// Dependency validator
pub struct DependencyValidator {
    /// Graph representation of dependencies
    graph: Graph<Package, (), Directed>,
    /// Map of package names to node indices
    package_map: HashMap<String, NodeIndex>,
    /// Validation metrics
    metrics: ValidationMetrics,
}

impl DependencyValidator {
    /// Create a new validator
    pub fn new() -> Self {
        Self {
            graph: Graph::new(),
            package_map: HashMap::new(),
            metrics: ValidationMetrics {
                packages_checked: 0,
                dependencies_checked: 0,
                max_depth: 0,
                version_constraints_checked: 0,
            },
        }
    }

    /// Add a package to the graph
    pub fn add_package(&mut self, package: Package) -> NodeIndex {
        let idx = self.graph.add_node(package.clone());
        self.package_map.insert(package.name().to_string(), idx);
        idx
    }

    /// Add a dependency between packages
    pub fn add_dependency(&mut self, from: NodeIndex, to: NodeIndex) {
        self.graph.add_edge(from, to, ());
    }

    /// Validate the dependency graph
    pub fn validate(&mut self) -> DaemonResult<ValidationResult> {
        let mut issues = Vec::new();
        
        // Check for circular dependencies
        let cycles = self.find_cycles();
        for cycle in cycles {
            let packages = cycle.iter()
                .map(|&idx| self.graph[idx].name().to_string())
                .collect();
            issues.push(ValidationIssue::CircularDependency { packages });
        }
        
        // Check for version conflicts
        issues.extend(self.check_version_conflicts());
        
        // Check for Python version conflicts
        issues.extend(self.check_python_version_conflicts());
        
        // Update metrics
        self.metrics.packages_checked = self.graph.node_count();
        self.metrics.dependencies_checked = self.graph.edge_count();
        self.metrics.max_depth = self.calculate_max_depth();
        
        Ok(ValidationResult {
            is_valid: issues.is_empty(),
            issues,
            metrics: self.metrics.clone(),
        })
    }

    /// Find cycles in the dependency graph
    fn find_cycles(&self) -> Vec<Vec<NodeIndex>> {
        let mut cycles = Vec::new();
        let mut visited = HashSet::new();
        let mut stack = Vec::new();
        
        for node in self.graph.node_indices() {
            if !visited.contains(&node) {
                self.find_cycles_recursive(
                    node,
                    &mut visited,
                    &mut stack,
                    &mut cycles,
                );
            }
        }
        
        cycles
    }

    /// Recursive helper for cycle detection
    fn find_cycles_recursive(
        &self,
        node: NodeIndex,
        visited: &mut HashSet<NodeIndex>,
        stack: &mut Vec<NodeIndex>,
        cycles: &mut Vec<Vec<NodeIndex>>,
    ) {
        visited.insert(node);
        stack.push(node);
        
        for neighbor in self.graph.neighbors(node) {
            if !visited.contains(&neighbor) {
                self.find_cycles_recursive(neighbor, visited, stack, cycles);
            } else if stack.contains(&neighbor) {
                // Found a cycle
                let cycle_start = stack.iter().position(|&n| n == neighbor).unwrap();
                cycles.push(stack[cycle_start..].to_vec());
            }
        }
        
        stack.pop();
    }

    /// Check for version conflicts
    fn check_version_conflicts(&self) -> Vec<ValidationIssue> {
        let mut issues = Vec::new();
        let mut version_map: HashMap<String, Vec<Version>> = HashMap::new();
        
        for node in self.graph.node_indices() {
            let package = &self.graph[node];
            version_map.entry(package.name().to_string())
                .or_default()
                .push(package.version().clone());
        }
        
        for (package, versions) in version_map {
            if versions.len() > 1 {
                issues.push(ValidationIssue::VersionConflict {
                    package,
                    required_versions: versions,
                });
            }
        }
        
        issues
    }

    /// Check for Python version conflicts
    fn check_python_version_conflicts(&self) -> Vec<ValidationIssue> {
        let mut issues = Vec::new();
        
        for node in self.graph.node_indices() {
            let package = &self.graph[node];
            let mut constraints = Vec::new();
            
            for neighbor in self.graph.neighbors(node) {
                let dep = &self.graph[neighbor];
                constraints.push(dep.python_version().to_string());
                
                if !package.python_version().is_compatible_with(dep.python_version()) {
                    issues.push(ValidationIssue::PythonVersionConflict {
                        package: package.name().to_string(),
                        version_constraints: constraints.clone(),
                    });
                }
            }
        }
        
        issues
    }

    /// Calculate maximum dependency depth
    fn calculate_max_depth(&self) -> usize {
        let mut max_depth = 0;
        let mut visited = HashSet::new();
        
        for node in self.graph.node_indices() {
            if !visited.contains(&node) {
                let depth = self.calculate_depth(node, &mut visited);
                max_depth = max_depth.max(depth);
            }
        }
        
        max_depth
    }

    /// Calculate depth for a node
    fn calculate_depth(&self, node: NodeIndex, visited: &mut HashSet<NodeIndex>) -> usize {
        if visited.contains(&node) {
            return 0;
        }
        
        visited.insert(node);
        let mut max_child_depth = 0;
        
        for neighbor in self.graph.neighbors(node) {
            let depth = self.calculate_depth(neighbor, visited);
            max_child_depth = max_child_depth.max(depth);
        }
        
        max_child_depth + 1
    }
}

impl Default for DependencyValidator {
    fn default() -> Self {
        Self::new()
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-daemon/src/state.rs

```rs
use std::collections::HashMap;
use std::path::PathBuf;
use std::sync::Arc;
use tokio::sync::RwLock;
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};
use uuid::Uuid;
use blast_core::{
    error::{BlastError, BlastResult},
    state::EnvironmentState,
    python::PythonVersion,
    package::Package,
    version_history::{VersionEvent, VersionHistory},
};

const STATE_FILE: &str = ".blast/state.json";

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BlastState {
    version: u32,
    timestamp: DateTime<Utc>,
    active_environment: Option<ActiveEnvironment>,
    environments: HashMap<String, EnvironmentState>,
}

impl BlastState {
    pub fn new() -> Self {
        Self {
            version: 1,
            timestamp: Utc::now(),
            active_environment: None,
            environments: HashMap::new(),
        }
    }

    pub fn active_environment(&self) -> Option<&ActiveEnvironment> {
        self.active_environment.as_ref()
    }

    pub fn environments(&self) -> &HashMap<String, EnvironmentState> {
        &self.environments
    }

    pub fn update_timestamp(&mut self) {
        self.timestamp = Utc::now();
    }

    pub fn update_environment(&mut self, name: String, state: EnvironmentState) {
        self.environments.insert(name, state);
        self.update_timestamp();
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ActiveEnvironment {
    name: String,
    path: PathBuf,
    python_version: PythonVersion,
    activated_at: DateTime<Utc>,
}

impl ActiveEnvironment {
    pub fn new(name: String, path: PathBuf, python_version: PythonVersion) -> Self {
        Self {
            name,
            path,
            python_version,
            activated_at: Utc::now(),
        }
    }

    pub fn name(&self) -> &str {
        &self.name
    }

    pub fn path(&self) -> &PathBuf {
        &self.path
    }

    pub fn python_version(&self) -> &PythonVersion {
        &self.python_version
    }

    pub fn activated_at(&self) -> DateTime<Utc> {
        self.activated_at
    }
}

#[derive(Debug, Clone)]
pub enum StateEvent {
    EnvironmentCreated(String),
    EnvironmentUpdated(String),
    EnvironmentRemoved(String),
    ActiveEnvironmentChanged(Option<String>),
    StateReloaded,
}

/// Checkpoint for environment state
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Checkpoint {
    /// Checkpoint ID
    pub id: Uuid,
    /// Checkpoint description
    pub description: String,
    /// Transaction ID if associated with a transaction
    pub transaction_id: Option<Uuid>,
    /// Environment state at checkpoint
    pub state: EnvironmentState,
    /// Checkpoint creation time
    pub created_at: DateTime<Utc>,
}

/// Manager for environment state and checkpoints
#[derive(Debug)]
pub struct StateManager {
    state: Arc<RwLock<BlastState>>,
    root_path: PathBuf,
}

impl StateManager {
    /// Create new state manager
    pub fn new(root_path: PathBuf) -> Self {
        Self {
            state: Arc::new(RwLock::new(BlastState::new())),
            root_path,
        }
    }

    pub async fn load(&self) -> BlastResult<()> {
        let state_path = self.root_path.join(STATE_FILE);
        if state_path.exists() {
            let contents = tokio::fs::read_to_string(&state_path).await?;
            let state: BlastState = serde_json::from_str(&contents)?;
            *self.state.write().await = state;
        }
        Ok(())
    }

    pub async fn save(&self) -> BlastResult<()> {
        let state = self.state.read().await;
        let state_path = self.root_path.join(STATE_FILE);
        
        // Ensure parent directory exists
        if let Some(parent) = state_path.parent() {
            tokio::fs::create_dir_all(parent).await?;
        }
        
        let contents = serde_json::to_string_pretty(&*state)?;
        tokio::fs::write(&state_path, contents).await?;
        Ok(())
    }

    pub async fn get_current_state(&self) -> BlastResult<EnvironmentState> {
        let state = self.state.read().await;
        if let Some(active) = &state.active_environment {
            if let Some(env_state) = state.environments.get(&active.name) {
                return Ok(env_state.clone());
            }
        }
        Ok(EnvironmentState::new(
            "default".to_string(),
            PythonVersion::parse("3.8.0").unwrap(),
            HashMap::new(),
            HashMap::new(),
        ))
    }

    pub async fn update_current_state(&self, env_state: EnvironmentState) -> BlastResult<()> {
        let mut state = self.state.write().await;
        if let Some(active) = &state.active_environment {
            let name = active.name.clone();
            state.update_environment(name, env_state);
            self.save().await?;
        }
        Ok(())
    }

    pub async fn set_active_environment(
        &self,
        name: String,
        path: PathBuf,
        python_version: PythonVersion,
    ) -> BlastResult<()> {
        let mut state = self.state.write().await;
        state.active_environment = Some(ActiveEnvironment::new(name.clone(), path, python_version));
        state.update_timestamp();
        self.save().await?;
        Ok(())
    }

    pub async fn clear_active_environment(&self) -> BlastResult<()> {
        let mut state = self.state.write().await;
        state.active_environment = None;
        state.update_timestamp();
        self.save().await?;
        Ok(())
    }

    pub async fn list_environments(&self) -> BlastResult<HashMap<String, EnvironmentState>> {
        let state = self.state.read().await;
        Ok(state.environments.clone())
    }

    pub async fn verify(&self) -> BlastResult<()> {
        let state_path = self.root_path.join(STATE_FILE);
        if state_path.exists() {
            let contents = tokio::fs::read_to_string(&state_path).await?;
            let _: BlastState = serde_json::from_str(&contents)?;
        }
        Ok(())
    }

    pub async fn create_checkpoint(
        &self,
        id: Uuid,
        description: String,
        transaction_id: Option<Uuid>,
    ) -> BlastResult<()> {
        let state = self.state.read().await;
        let checkpoint = Checkpoint {
            id,
            description,
            transaction_id,
            state: state.active_environment()
                .and_then(|active| state.environments.get(&active.name))
                .cloned()
                .unwrap_or_else(|| EnvironmentState::new(
                    "default".to_string(),
                    PythonVersion::parse("3.8.0").unwrap(),
                    HashMap::new(),
                    HashMap::new(),
                )),
            created_at: Utc::now(),
        };

        let checkpoint_path = self.root_path.join(".blast").join("checkpoints");
        tokio::fs::create_dir_all(&checkpoint_path).await?;
        
        let checkpoint_file = checkpoint_path.join(format!("{}.json", id));
        let contents = serde_json::to_string_pretty(&checkpoint)?;
        tokio::fs::write(checkpoint_file, contents).await?;
        
        Ok(())
    }

    pub async fn restore_checkpoint(&self, id: &str) -> BlastResult<()> {
        let checkpoint_path = self.root_path
            .join(".blast")
            .join("checkpoints")
            .join(format!("{}.json", id));
            
        if !checkpoint_path.exists() {
            return Err(BlastError::environment(format!("Checkpoint {} not found", id)));
        }

        let contents = tokio::fs::read_to_string(checkpoint_path).await?;
        let checkpoint: Checkpoint = serde_json::from_str(&contents)?;

        let mut state = self.state.write().await;
        let env_name = state.active_environment.as_ref()
            .map(|active| active.name.clone());

        if let Some(name) = env_name {
            state.environments.insert(name, checkpoint.state);
            state.update_timestamp();
            self.save().await?;
        }

        Ok(())
    }

    pub async fn list_checkpoints(&self) -> BlastResult<Vec<Checkpoint>> {
        let checkpoint_path = self.root_path.join(".blast").join("checkpoints");
        if !checkpoint_path.exists() {
            return Ok(Vec::new());
        }

        let mut checkpoints = Vec::new();
        let mut entries = tokio::fs::read_dir(checkpoint_path).await?;
        while let Some(entry) = entries.next_entry().await? {
            if entry.file_type().await?.is_file() {
                if let Some(ext) = entry.path().extension() {
                    if ext == "json" {
                        let contents = tokio::fs::read_to_string(entry.path()).await?;
                        if let Ok(checkpoint) = serde_json::from_str(&contents) {
                            checkpoints.push(checkpoint);
                        }
                    }
                }
            }
        }

        Ok(checkpoints)
    }

    pub async fn get_checkpoint(&self, id: &str) -> BlastResult<Option<Checkpoint>> {
        let checkpoint_path = self.root_path
            .join(".blast")
            .join("checkpoints")
            .join(format!("{}.json", id));
            
        if !checkpoint_path.exists() {
            return Ok(None);
        }

        let contents = tokio::fs::read_to_string(checkpoint_path).await?;
        let checkpoint = serde_json::from_str(&contents)?;
        Ok(Some(checkpoint))
    }

    pub async fn cleanup_old_snapshots(&self, max_age_days: u64) -> BlastResult<()> {
        let checkpoint_path = self.root_path.join(".blast").join("checkpoints");
        if !checkpoint_path.exists() {
            return Ok(());
        }

        let cutoff = Utc::now() - chrono::Duration::days(max_age_days as i64);
        let mut entries = tokio::fs::read_dir(checkpoint_path).await?;
        
        while let Some(entry) = entries.next_entry().await? {
            if entry.file_type().await?.is_file() {
                if let Some(ext) = entry.path().extension() {
                    if ext == "json" {
                        let contents = tokio::fs::read_to_string(entry.path()).await?;
                        if let Ok(checkpoint) = serde_json::from_str::<Checkpoint>(&contents) {
                            if checkpoint.created_at < cutoff {
                                tokio::fs::remove_file(entry.path()).await?;
                            }
                        }
                    }
                }
            }
        }

        Ok(())
    }

    pub async fn add_package_with_event(
        &self,
        package: &Package,
        event: VersionEvent,
    ) -> BlastResult<()> {
        let mut state = self.state.write().await;
        let env_name = state.active_environment.as_ref()
            .map(|active| active.name.clone());

        if let Some(name) = env_name {
            if let Some(env_state) = state.environments.get_mut(&name) {
                env_state.packages.insert(
                    package.id().name().to_string(),
                    package.version().clone(),
                );
                // Store version event in version_history map
                let pkg_name = package.id().name().to_string();
                env_state.version_histories
                    .entry(pkg_name.clone())
                    .or_insert_with(|| VersionHistory::new(pkg_name))
                    .add_event(event);
                state.update_timestamp();
                self.save().await?;
            }
        }
        Ok(())
    }

    pub async fn remove_package(&self, package: &Package) -> BlastResult<()> {
        let mut state = self.state.write().await;
        if let Some(active) = &state.active_environment {
            let name = active.name.clone();
            if let Some(env_state) = state.environments.get_mut(&name) {
                env_state.packages.remove(package.id().name());
                state.update_timestamp();
                self.save().await?;
            }
        }
        Ok(())
    }

    pub async fn update_package_with_event(
        &self,
        _from: &Package,
        to: &Package,
        event: VersionEvent,
    ) -> BlastResult<()> {
        let mut state = self.state.write().await;
        let env_name = state.active_environment.as_ref()
            .map(|active| active.name.clone());

        if let Some(name) = env_name {
            if let Some(env_state) = state.environments.get_mut(&name) {
                env_state.packages.insert(
                    to.id().name().to_string(),
                    to.version().clone(),
                );
                // Store version event in version_history map
                let pkg_name = to.id().name().to_string();
                env_state.version_histories
                    .entry(pkg_name.clone())
                    .or_insert_with(|| VersionHistory::new(pkg_name))
                    .add_event(event);
                state.update_timestamp();
                self.save().await?;
            }
        }
        Ok(())
    }

    pub async fn add_environment(&self, name: String, _env_state: EnvironmentState) -> BlastResult<()> {
        let mut state = self.state.write().await;
        state.environments.insert(name, _env_state);
        state.update_timestamp();
        self.save().await?;
        Ok(())
    }

    pub async fn remove_environment(&self, name: &str) -> BlastResult<()> {
        let mut state = self.state.write().await;
        state.environments.remove(name);
        state.update_timestamp();
        self.save().await?;
        Ok(())
    }

    pub async fn verify_state(&self) -> BlastResult<()> {
        self.verify().await?;
        
        // Additional state verification logic
        let state = self.state.read().await;
        
        // Verify all environments exist
        for (name, _env_state) in &state.environments {
            let env_path = self.root_path.join(name);
            if !env_path.exists() {
                return Err(BlastError::environment(
                    format!("Environment directory not found: {}", env_path.display())
                ));
            }
            
            // Verify Python version
            if !env_path.join("bin").join("python").exists() {
                return Err(BlastError::environment(
                    format!("Python executable not found in environment: {}", name)
                ));
            }
            
            // Verify package state
            let site_packages = env_path.join("lib").join("python3").join("site-packages");
            if !site_packages.exists() {
                return Err(BlastError::environment(
                    format!("Site-packages directory not found: {}", site_packages.display())
                ));
            }
        }
        
        Ok(())
    }

    pub async fn verify_environment(&self, _env_state: &EnvironmentState) -> BlastResult<()> {
        // Implementation of verify_environment method
        Ok(())
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-daemon/src/environment.rs

```rs
use std::path::PathBuf;
use tokio::fs;
use blast_core::{
    error::BlastResult,
    python::{PythonVersion, PythonEnvironment},
    ActivationScripts,
};
use crate::error::DaemonError;

/// Environment management trait
pub trait Environment {
    /// Get environment path
    fn path(&self) -> &PathBuf;

    /// Get Python version
    fn python_version(&self) -> &PythonVersion;

    /// Start monitoring the environment
    fn start_monitoring(&self) -> impl std::future::Future<Output = BlastResult<()>> + Send;
}

pub trait PythonEnvironmentExt {
    fn create(&self) -> impl std::future::Future<Output = BlastResult<()>> + Send;
}

impl PythonEnvironmentExt for PythonEnvironment {
    fn create(&self) -> impl std::future::Future<Output = BlastResult<()>> + Send {
        async move {
            // Create the virtual environment directory
            tokio::fs::create_dir_all(self.path()).await?;

            // Create bin directory
            let bin_dir = self.path().join("bin");
            tokio::fs::create_dir_all(&bin_dir).await?;

            // Create lib directory
            let lib_dir = self.path().join("lib");
            tokio::fs::create_dir_all(&lib_dir).await?;

            // Create include directory
            let include_dir = self.path().join("include");
            tokio::fs::create_dir_all(&include_dir).await?;

            // Create site-packages directory
            let site_packages = lib_dir.join("python3").join("site-packages");
            tokio::fs::create_dir_all(&site_packages).await?;

            // Create pyvenv.cfg
            let python_path = bin_dir.join("python");
            let pyvenv_cfg = format!(
                "home = {}\nversion = {}\ninclude-system-site-packages = false\n",
                python_path.display(),
                self.python_version()
            );
            tokio::fs::write(self.path().join("pyvenv.cfg"), pyvenv_cfg).await?;

            Ok(())
        }
    }
}

#[derive(Debug)]
pub struct EnvironmentManager {
    root_path: PathBuf,
}

impl EnvironmentManager {
    pub fn new(root_path: PathBuf) -> Self {
        Self { root_path }
    }

    pub fn root_path(&self) -> &PathBuf {
        &self.root_path
    }

    /// Install activation scripts for all supported shells
    async fn install_activation_scripts(&self, env_path: &PathBuf, env_name: &str) -> BlastResult<()> {
        let scripts = ActivationScripts::generate(env_path, env_name);
        let bin_path = env_path.join("bin");

        // Create scripts directory if it doesn't exist
        fs::create_dir_all(&bin_path).await.map_err(|e| {
            DaemonError::environment(format!("Failed to create bin directory: {}", e))
        })?;

        // Write activation scripts
        let script_files = [
            ("activate", scripts.bash),
            ("activate.fish", scripts.fish),
            ("activate.ps1", scripts.powershell),
        ];

        for (filename, content) in script_files.iter() {
            let script_path = bin_path.join(filename);
            fs::write(&script_path, content).await.map_err(|e| {
                DaemonError::environment(format!("Failed to write {} script: {}", filename, e))
            })?;

            // Set executable permissions on Unix systems
            #[cfg(unix)]
            {
                use std::os::unix::fs::PermissionsExt;
                let mut perms = fs::metadata(&script_path).await?.permissions();
                perms.set_mode(0o755);
                fs::set_permissions(&script_path, perms).await?;
            }
        }

        Ok(())
    }

    /// Create a new Python environment
    pub async fn create_environment(
        &self,
        name: &str,
        python_version: &PythonVersion,
    ) -> BlastResult<PythonEnvironment> {
        let env_path = self.root_path.join(name);

        // Create environment directory
        fs::create_dir_all(&env_path).await.map_err(|e| {
            DaemonError::environment(format!("Failed to create environment directory: {}", e))
        })?;

        // Initialize Python environment
        let env = PythonEnvironment::new(env_path.clone(), python_version.clone());
        PythonEnvironmentExt::create(&env).await?;

        // Create standard directories
        for dir in ["bin", "lib", "include"] {
            fs::create_dir_all(env.path().join(dir)).await.map_err(|e| {
                DaemonError::environment(format!("Failed to create {} directory: {}", dir, e))
            })?;
        }

        // Create site-packages directory
        fs::create_dir_all(env.path().join("lib").join("python3").join("site-packages"))
            .await
            .map_err(|e| {
                DaemonError::environment(format!("Failed to create site-packages directory: {}", e))
            })?;

        // Install activation scripts
        self.install_activation_scripts(&env_path, name).await?;

        Ok(env)
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-core/Cargo.toml

```toml
[package]
name = "blast-core"
version = "0.1.0"
edition = "2021"
authors = ["Blast Contributors"]
description = "Core types and traits for the Blast Python environment manager"
license = "MIT"

[features]
default = ["serde-support"]
serde-support = ["dep:serde", "dep:serde_json", "dep:toml", "chrono/serde"]

[dependencies]
tokio = { version = "1.36", features = ["full"] }
async-trait = "0.1"
thiserror = "1.0"
serde = { version = "1.0", features = ["derive"], optional = true }
serde_json = { version = "1.0", optional = true }
serde_yaml = "0.9"
toml = { version = "0.8", optional = true }
chrono = { version = "0.4", features = ["serde"] }
glob = "0.3"
petgraph = "0.6"

# Error handling
anyhow = { workspace = true }

# Logging
tracing = { workspace = true }
tracing-subscriber = { workspace = true, features = ["env-filter", "json", "chrono"] }

# Version handling
semver = { version = "1.0", features = ["serde"] }

# Async
futures = { version = "0.3", features = ["executor"] }

# Filesystem
dirs = "5.0"
notify = "6.1"

# Pattern matching
regex = "1.10"

# UUID generation
uuid = { version = "1.6", features = ["v4", "serde"] }

# UI components
termcolor = "1.4"
indicatif = "0.17"
console = "0.15"

[dev-dependencies]
proptest = { workspace = true }
mockall = { workspace = true }
tempfile = "3.10"
tokio-test = "0.4"
assert_fs = "1.1"
predicates = "3.1"
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-core/src/types.rs

```rs
use std::path::PathBuf;
use std::time::Duration;
use serde::{Deserialize, Serialize};

/// Strategy for updating packages
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum UpdateStrategy {
    /// Never update packages automatically
    Never,
    /// Update only when explicitly requested
    Manual,
    /// Update packages in the background
    Automatic {
        /// Interval between update checks
        #[serde(with = "duration_serde")]
        interval: Duration,
        /// Whether to update only direct dependencies
        direct_only: bool,
    },
}

impl Default for UpdateStrategy {
    fn default() -> Self {
        Self::Manual
    }
}

/// Settings for package caching
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CacheSettings {
    /// Directory for storing cached packages
    pub cache_dir: PathBuf,
    /// Maximum cache size in bytes
    pub max_size: u64,
    /// Time to keep unused packages in cache
    #[serde(with = "duration_serde")]
    pub ttl: Duration,
    /// Whether to use hardlinks when possible
    pub use_hardlinks: bool,
    /// Whether to use copy-on-write when possible
    pub use_cow: bool,
}

impl Default for CacheSettings {
    fn default() -> Self {
        Self {
            cache_dir: default_cache_dir(),
            max_size: 10 * 1024 * 1024 * 1024, // 10 GB
            ttl: Duration::from_secs(30 * 24 * 60 * 60), // 30 days
            use_hardlinks: true,
            use_cow: true,
        }
    }
}

/// Get the default cache directory
fn default_cache_dir() -> PathBuf {
    dirs::cache_dir()
        .unwrap_or_else(|| PathBuf::from("~/.cache"))
        .join("blast")
}

mod duration_serde {
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::time::Duration;

    pub fn serialize<S>(duration: &Duration, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        duration.as_secs().serialize(serializer)
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Duration, D::Error>
    where
        D: Deserializer<'de>,
    {
        let secs = u64::deserialize(deserializer)?;
        Ok(Duration::from_secs(secs))
    }
}

/// Logging level for Blast operations
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum LogLevel {
    Error = 0,
    Warn = 1,
    Info = 2,
    Debug = 3,
    Trace = 4,
}

impl Default for LogLevel {
    fn default() -> Self {
        Self::Info
    }
}

impl From<LogLevel> for tracing::Level {
    fn from(level: LogLevel) -> Self {
        match level {
            LogLevel::Error => tracing::Level::ERROR,
            LogLevel::Warn => tracing::Level::WARN,
            LogLevel::Info => tracing::Level::INFO,
            LogLevel::Debug => tracing::Level::DEBUG,
            LogLevel::Trace => tracing::Level::TRACE,
        }
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-core/src/diagnostics.rs

```rs
use std::fmt;
use std::path::PathBuf;
use serde::{Serialize, Deserialize};

/// Diagnostic severity levels
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum DiagnosticLevel {
    /// Critical errors that prevent operation
    Error,
    /// Important issues that don't prevent operation
    Warning,
    /// Informational messages about operations
    Info,
    /// Detailed debug information
    Debug,
    /// Very detailed trace information
    Trace,
}

/// Categories of diagnostics for better organization
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum DiagnosticCategory {
    /// Version-related issues
    Version,
    /// Dependency resolution problems
    Dependency,
    /// Transaction and rollback issues
    Transaction,
    /// Environment state issues
    Environment,
    /// Package management issues
    Package,
    /// Performance-related issues
    Performance,
    /// Security-related issues
    Security,
    /// Configuration problems
    Configuration,
    /// Custom category with string identifier
    Custom(String),
}

impl fmt::Display for DiagnosticCategory {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Version => write!(f, "Version"),
            Self::Dependency => write!(f, "Dependency"),
            Self::Transaction => write!(f, "Transaction"),
            Self::Environment => write!(f, "Environment"),
            Self::Package => write!(f, "Package"),
            Self::Performance => write!(f, "Performance"),
            Self::Security => write!(f, "Security"),
            Self::Configuration => write!(f, "Configuration"),
            Self::Custom(s) => write!(f, "{}", s),
        }
    }
}

/// Code context for diagnostics
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CodeContext {
    /// File where the issue occurred
    pub file: PathBuf,
    /// Line number in the file
    pub line: Option<u32>,
    /// Column number in the file
    pub column: Option<u32>,
    /// Relevant code snippet
    pub snippet: Option<String>,
    /// Function or method name
    pub function: Option<String>,
}

/// Suggestion for resolving diagnostic issues
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DiagnosticSuggestion {
    /// Description of the suggestion
    pub description: String,
    /// Code or command to fix the issue
    pub fix: Option<String>,
    /// Additional context about the fix
    pub context: Option<String>,
    /// Estimated time to implement fix
    pub estimated_time: Option<String>,
    /// Whether the fix can be applied automatically
    pub auto_fixable: bool,
}

/// Diagnostic information for operations
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Diagnostic {
    /// Severity level of the diagnostic
    pub level: DiagnosticLevel,
    /// Main error message or description
    pub message: String,
    /// Category of the diagnostic
    pub category: DiagnosticCategory,
    /// Detailed explanation of the issue
    pub details: Option<String>,
    /// Suggestions for resolving the issue
    pub suggestions: Vec<DiagnosticSuggestion>,
    /// Code context if available
    pub code_context: Option<CodeContext>,
    /// Operation context (e.g. package name, version)
    pub operation_context: Option<String>,
    /// Timestamp when the diagnostic was created
    pub timestamp: chrono::DateTime<chrono::Utc>,
    /// Unique identifier for the diagnostic
    pub id: uuid::Uuid,
}

impl Diagnostic {
    /// Create a new diagnostic
    pub fn new(
        level: DiagnosticLevel,
        message: String,
        category: DiagnosticCategory,
    ) -> Self {
        Self {
            level,
            message,
            category,
            details: None,
            suggestions: Vec::new(),
            code_context: None,
            operation_context: None,
            timestamp: chrono::Utc::now(),
            id: uuid::Uuid::new_v4(),
        }
    }

    /// Add detailed explanation
    pub fn with_details(mut self, details: String) -> Self {
        self.details = Some(details);
        self
    }

    /// Add a suggestion
    pub fn with_suggestion(mut self, suggestion: DiagnosticSuggestion) -> Self {
        self.suggestions.push(suggestion);
        self
    }

    /// Add code context
    pub fn with_code_context(mut self, context: CodeContext) -> Self {
        self.code_context = Some(context);
        self
    }

    /// Add operation context
    pub fn with_operation_context(mut self, context: String) -> Self {
        self.operation_context = Some(context);
        self
    }
}

/// Collection of diagnostics with query capabilities
#[derive(Debug, Default)]
pub struct DiagnosticCollection {
    diagnostics: Vec<Diagnostic>,
}

impl DiagnosticCollection {
    /// Create a new empty collection
    pub fn new() -> Self {
        Self {
            diagnostics: Vec::new(),
        }
    }

    /// Add a diagnostic to the collection
    pub fn add(&mut self, diagnostic: Diagnostic) {
        self.diagnostics.push(diagnostic);
    }

    /// Get all diagnostics
    pub fn all(&self) -> &[Diagnostic] {
        &self.diagnostics
    }

    /// Get diagnostics by level
    pub fn by_level(&self, level: DiagnosticLevel) -> Vec<&Diagnostic> {
        self.diagnostics
            .iter()
            .filter(|d| d.level == level)
            .collect()
    }

    /// Get diagnostics by category
    pub fn by_category(&self, category: &DiagnosticCategory) -> Vec<&Diagnostic> {
        self.diagnostics
            .iter()
            .filter(|d| d.category == *category)
            .collect()
    }

    /// Get diagnostics within a time range
    pub fn in_time_range(
        &self,
        start: chrono::DateTime<chrono::Utc>,
        end: chrono::DateTime<chrono::Utc>,
    ) -> Vec<&Diagnostic> {
        self.diagnostics
            .iter()
            .filter(|d| d.timestamp >= start && d.timestamp <= end)
            .collect()
    }

    /// Clear all diagnostics
    pub fn clear(&mut self) {
        self.diagnostics.clear();
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-core/src/ui.rs

```rs
use std::io::Write;
use termcolor::{Color, ColorChoice, ColorSpec, StandardStream, WriteColor};
use indicatif::{ProgressBar, ProgressStyle, MultiProgress};
use console::Term;
use serde::{Serialize, Deserialize};
use crate::logging::{LogLevel, StructuredLogger};
use tracing::Level;
use tracing_subscriber::fmt::format::FmtSpan;

use crate::error::BlastResult;

/// User interface style configuration
#[derive(Clone)]
pub struct UiStyle {
    /// Color scheme for different elements
    pub colors: ColorScheme,
    /// Progress bar style
    #[allow(dead_code)]
    progress_style: ProgressStyle,
    /// Whether to use unicode characters
    pub use_unicode: bool,
    /// Whether to use colors
    pub use_colors: bool,
}

impl std::fmt::Debug for UiStyle {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("UiStyle")
            .field("colors", &self.colors)
            .field("use_unicode", &self.use_unicode)
            .field("use_colors", &self.use_colors)
            // Skip progress_style since it doesn't implement Debug
            .finish()
    }
}

/// Color scheme for UI elements
#[derive(Debug, Clone)]
pub struct ColorScheme {
    /// Primary color for main elements
    pub primary: Color,
    /// Secondary color for less important elements
    pub secondary: Color,
    /// Success color for completed operations
    pub success: Color,
    /// Error color for failures
    pub error: Color,
    /// Warning color for potential issues
    pub warning: Color,
    /// Info color for general information
    pub info: Color,
}

impl Default for ColorScheme {
    fn default() -> Self {
        Self {
            primary: Color::Cyan,
            secondary: Color::Blue,
            success: Color::Green,
            error: Color::Red,
            warning: Color::Yellow,
            info: Color::White,
        }
    }
}

/// Progress indicator types
#[derive(Debug, Clone)]
pub enum ProgressType {
    /// Simple spinner
    Spinner,
    /// Progress bar with percentage
    Bar,
    /// Download progress with speed
    Download,
    /// Installation progress with steps
    Installation,
}

/// User interface manager
#[derive(Debug)]
pub struct UiManager {
    style: UiStyle,
    term: Term,
    multi_progress: MultiProgress,
    stdout: StandardStream,
}

impl UiManager {
    /// Create a new UI manager
    pub fn new() -> Self {
        let style = UiStyle {
            colors: ColorScheme::default(),
            progress_style: ProgressStyle::default_bar()
                .template("{spinner:.green} [{elapsed_precise}] {bar:40.cyan/blue} {pos:>7}/{len:7} {msg}")
                .unwrap()
                .progress_chars("=>-"),
            use_unicode: true,
            use_colors: true,
        };

        Self {
            style,
            term: Term::stdout(),
            multi_progress: MultiProgress::new(),
            stdout: StandardStream::stdout(ColorChoice::Auto),
        }
    }

    /// Create a new progress indicator
    pub fn create_progress(&self, total: u64, progress_type: ProgressType) -> ProgressBar {
        let pb = self.multi_progress.add(ProgressBar::new(total));
        
        let style = match progress_type {
            ProgressType::Spinner => ProgressStyle::default_spinner()
                .template("{spinner:.green} {msg}")
                .unwrap(),
            ProgressType::Bar => self.style.progress_style.clone(),
            ProgressType::Download => ProgressStyle::default_bar()
                .template("{spinner:.green} [{elapsed_precise}] {bar:40.cyan/blue} {bytes}/{total_bytes} ({bytes_per_sec}) {msg}")
                .unwrap(),
            ProgressType::Installation => ProgressStyle::default_bar()
                .template("{spinner:.green} [{elapsed_precise}] {bar:40.cyan/blue} {pos}/{len} {prefix:.bold.dim} {msg}")
                .unwrap(),
        };

        pb.set_style(style);
        pb
    }

    /// Print a colored message
    pub fn print_colored(&mut self, message: &str, color: Color) -> std::io::Result<()> {
        if self.style.use_colors {
            self.stdout.set_color(ColorSpec::new().set_fg(Some(color)))?;
            write!(self.stdout, "{}", message)?;
            self.stdout.reset()?;
        } else {
            write!(self.stdout, "{}", message)?;
        }
        Ok(())
    }

    /// Print a success message
    pub fn success(&mut self, message: &str) -> std::io::Result<()> {
        self.print_colored("✓ ", self.style.colors.success)?;
        writeln!(self.stdout, "{}", message)
    }

    /// Print an error message
    pub fn error(&mut self, message: &str) -> std::io::Result<()> {
        self.print_colored("✗ ", self.style.colors.error)?;
        writeln!(self.stdout, "{}", message)
    }

    /// Print a warning message
    pub fn warning(&mut self, message: &str) -> std::io::Result<()> {
        self.print_colored("! ", self.style.colors.warning)?;
        writeln!(self.stdout, "{}", message)
    }

    /// Print an info message
    pub fn info(&mut self, message: &str) -> std::io::Result<()> {
        self.print_colored("i ", self.style.colors.info)?;
        writeln!(self.stdout, "{}", message)
    }

    /// Create an interactive error navigator
    pub fn error_navigator(&mut self, errors: Vec<crate::diagnostics::Diagnostic>) -> std::io::Result<()> {
        if errors.is_empty() {
            return Ok(());
        }

        let mut current = 0;
        loop {
            self.term.clear_screen()?;
            
            // Display current error
            let error = &errors[current];
            self.print_colored("Error Navigator ", self.style.colors.primary)?;
            writeln!(self.stdout, "({}/{})", current + 1, errors.len())?;
            writeln!(self.stdout)?;

            // Print error details
            self.print_colored("Error: ", self.style.colors.error)?;
            writeln!(self.stdout, "{}", error.message)?;
            
            if let Some(details) = &error.details {
                writeln!(self.stdout)?;
                self.print_colored("Details: ", self.style.colors.secondary)?;
                writeln!(self.stdout, "{}", details)?;
            }

            // Print suggestions
            if !error.suggestions.is_empty() {
                writeln!(self.stdout)?;
                self.print_colored("Suggestions:", self.style.colors.info)?;
                for suggestion in &error.suggestions {
                    writeln!(self.stdout)?;
                    writeln!(self.stdout, "  • {}", suggestion.description)?;
                    if let Some(fix) = &suggestion.fix {
                        writeln!(self.stdout, "    Try: {}", fix)?;
                    }
                }
            }

            // Navigation instructions
            writeln!(self.stdout)?;
            writeln!(self.stdout, "Navigation: [p]revious | [n]ext | [q]uit")?;

            // Handle input
            match self.term.read_char()? {
                'p' | 'P' if current > 0 => current -= 1,
                'n' | 'N' if current < errors.len() - 1 => current += 1,
                'q' | 'Q' => break,
                _ => {}
            }
        }

        self.term.clear_screen()?;
        Ok(())
    }
}

/// Machine-readable output formatter
#[derive(Debug)]
pub struct MachineOutput {
    format: OutputFormat,
}

/// Output format for machine-readable output
#[derive(Debug, Clone, Copy)]
pub enum OutputFormat {
    /// JSON output
    Json,
    /// YAML output
    Yaml,
    /// Custom format
    Custom,
}

impl MachineOutput {
    /// Create a new machine output formatter
    pub fn new(format: OutputFormat) -> Self {
        Self { format }
    }

    /// Format data for machine consumption
    pub fn format<T: Serialize + std::fmt::Debug>(&self, data: &T) -> Result<String, serde_json::Error> {
        match self.format {
            OutputFormat::Json => serde_json::to_string_pretty(data),
            OutputFormat::Yaml => Ok(serde_yaml::to_string(data).unwrap()),
            OutputFormat::Custom => Ok(format!("{data:?}")),
        }
    }
}

/// UI theme configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Theme {
    /// Primary color (hex)
    pub primary_color: String,
    /// Secondary color (hex)
    pub secondary_color: String,
    /// Success color (hex)
    pub success_color: String,
    /// Warning color (hex)
    pub warning_color: String,
    /// Error color (hex)
    pub error_color: String,
}

impl Default for Theme {
    fn default() -> Self {
        Self {
            primary_color: "#4A90E2".to_string(),
            secondary_color: "#86C1B9".to_string(),
            success_color: "#7ED321".to_string(),
            warning_color: "#F5A623".to_string(),
            error_color: "#D0021B".to_string(),
        }
    }
}

/// Progress indicator for long-running operations
#[derive(Debug)]
pub struct ProgressIndicator {
    bar: ProgressBar,
}

impl ProgressIndicator {
    /// Create a new progress indicator
    pub fn new(total: u64, message: &str) -> Self {
        let bar = ProgressBar::new(total);
        bar.set_style(ProgressStyle::default_bar()
            .template("{spinner:.green} [{elapsed_precise}] [{bar:40.cyan/blue}] {pos}/{len} ({eta})")
            .unwrap()
            .progress_chars("#>-"));
        
        bar.set_message(message.to_string());
        
        Self { bar }
    }

    /// Update progress
    pub fn update(&self, progress: u64) {
        self.bar.set_position(progress);
    }

    /// Set progress message
    pub fn set_message(&self, message: &str) {
        self.bar.set_message(message.to_string());
    }

    /// Mark as finished
    pub fn finish(&self) {
        self.bar.finish_with_message("Done!");
    }
}

/// Console output formatter
#[derive(Debug)]
pub struct Console {
    stdout: StandardStream,
    theme: Theme,
}

impl Console {
    /// Create a new console with default theme
    pub fn new() -> Self {
        Self {
            stdout: StandardStream::stdout(ColorChoice::Auto),
            theme: Theme::default(),
        }
    }

    /// Set console theme
    pub fn set_theme(&mut self, theme: Theme) {
        self.theme = theme;
    }

    /// Print success message
    pub fn success(&mut self, message: &str) -> BlastResult<()> {
        self.stdout.reset()?;
        self.stdout.set_color(ColorSpec::new().set_fg(Some(termcolor::Color::Green)))?;
        writeln!(&mut self.stdout, "✓ {}", message)?;
        self.stdout.reset()?;
        Ok(())
    }

    /// Print warning message
    pub fn warning(&mut self, message: &str) -> BlastResult<()> {
        self.stdout.reset()?;
        self.stdout.set_color(ColorSpec::new().set_fg(Some(termcolor::Color::Yellow)))?;
        writeln!(&mut self.stdout, "⚠ {}", message)?;
        self.stdout.reset()?;
        Ok(())
    }

    /// Print error message
    pub fn error(&mut self, message: &str) -> BlastResult<()> {
        self.stdout.reset()?;
        self.stdout.set_color(ColorSpec::new().set_fg(Some(termcolor::Color::Red)))?;
        writeln!(&mut self.stdout, "✗ {}", message)?;
        self.stdout.reset()?;
        Ok(())
    }

    /// Print info message
    pub fn info(&mut self, message: &str) -> BlastResult<()> {
        self.stdout.reset()?;
        self.stdout.set_color(ColorSpec::new().set_fg(Some(termcolor::Color::Blue)))?;
        writeln!(&mut self.stdout, "ℹ {}", message)?;
        self.stdout.reset()?;
        Ok(())
    }

    /// Print debug message
    pub fn debug(&mut self, message: &str) -> BlastResult<()> {
        self.stdout.reset()?;
        self.stdout.set_color(ColorSpec::new().set_fg(Some(termcolor::Color::Magenta)))?;
        writeln!(&mut self.stdout, "🔍 {}", message)?;
        self.stdout.reset()?;
        Ok(())
    }

    /// Create a new progress indicator
    pub fn progress(&self, total: u64, message: &str) -> ProgressIndicator {
        ProgressIndicator::new(total, message)
    }

    /// Clear the screen
    pub fn clear(&mut self) -> BlastResult<()> {
        Term::stdout().clear_screen()?;
        Ok(())
    }

    /// Move cursor up
    pub fn move_up(&mut self, lines: u16) -> BlastResult<()> {
        Term::stdout().move_cursor_up(lines.into())?;
        Ok(())
    }

    /// Move cursor down
    pub fn move_down(&mut self, lines: u16) -> BlastResult<()> {
        Term::stdout().move_cursor_down(lines.into())?;
        Ok(())
    }
}

impl Default for Console {
    fn default() -> Self {
        Self::new()
    }
}

/// Format data for display
pub trait DisplayFormat {
    /// Format data as string
    fn format(&self) -> String;
}

impl<T: std::fmt::Display + Serialize + std::fmt::Debug> DisplayFormat for T {
    fn format(&self) -> String {
        format!("{self}")
    }
}

pub fn init_logging(level: LogLevel) -> StructuredLogger {
    let tracing_level: Level = level.clone().into();
    
    // Set up tracing subscriber with JSON formatting
    tracing_subscriber::fmt()
        .with_level(true)
        .with_target(true)
        .with_thread_ids(true)
        .with_file(true)
        .with_line_number(true)
        .with_span_events(FmtSpan::FULL)
        .with_timer(tracing_subscriber::fmt::time::ChronoLocal::new("%Y-%m-%d %H:%M:%S%.3f".to_string()))
        .with_env_filter(tracing_level.to_string())
        .json()
        .flatten_event(true)
        .try_init()
        .expect("Failed to set global subscriber");

    StructuredLogger::new(level)
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-core/src/security.rs

```rs
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

use crate::error::BlastResult;
use crate::package::Package;
use crate::python::PythonEnvironment;
use crate::python::PythonVersion;

/// Isolation level for Python environments
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum IsolationLevel {
    /// Process-level isolation
    Process,
    /// Container-level isolation
    Container,
    /// None (minimal isolation)
    None,
}

impl Default for IsolationLevel {
    fn default() -> Self {
        IsolationLevel::Process
    }
}

/// Security policy for Python environments
#[derive(Debug, Clone)]
pub struct SecurityPolicy {
    /// Isolation level
    pub isolation_level: IsolationLevel,
    /// Python version
    pub python_version: PythonVersion,
    /// Resource limits
    pub resource_limits: ResourceLimits,
}

impl Default for SecurityPolicy {
    fn default() -> Self {
        Self {
            isolation_level: IsolationLevel::default(),
            python_version: PythonVersion::parse("3.8.0").unwrap(),
            resource_limits: ResourceLimits::default(),
        }
    }
}

/// Resource limits for Python environments
#[derive(Debug, Clone)]
pub struct ResourceLimits {
    /// Maximum memory usage in bytes
    pub max_memory: u64,
    /// Maximum disk usage in bytes
    pub max_disk: u64,
    /// Maximum number of processes
    pub max_processes: u32,
}

impl Default for ResourceLimits {
    fn default() -> Self {
        Self {
            max_memory: 1024 * 1024 * 1024 * 2, // 2GB
            max_disk: 1024 * 1024 * 1024 * 10,  // 10GB
            max_processes: 32,
        }
    }
}

/// Security audit record
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuditRecord {
    /// Record ID
    pub id: String,
    /// Timestamp
    pub timestamp: DateTime<Utc>,
    /// Event type
    pub event_type: AuditEventType,
    /// Event details
    pub details: String,
    /// User or process that triggered the event
    pub actor: String,
    /// Resource affected
    pub resource: String,
    /// Result of the operation
    pub result: AuditResult,
}

/// Type of audit event
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AuditEventType {
    /// Package installation
    PackageInstall,
    /// Package verification
    PackageVerify,
    /// Environment creation
    EnvironmentCreate,
    /// Policy violation
    PolicyViolation,
    /// Access control
    AccessControl,
    /// Resource limit
    ResourceLimit,
}

/// Result of an audited operation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AuditResult {
    /// Operation succeeded
    Success,
    /// Operation failed
    Failure(String),
    /// Operation was denied
    Denied(String),
}

/// Trait for environment isolation implementations
pub trait EnvironmentIsolation: Send + Sync {
    /// Create an isolated environment
    fn create_environment(&self, config: &SecurityPolicy) -> BlastResult<PythonEnvironment>;
    
    /// Destroy an isolated environment
    fn destroy_environment(&self, env: &PythonEnvironment) -> BlastResult<()>;
    
    /// Execute command in isolated environment
    fn execute_command(&self, env: &PythonEnvironment, command: &str) -> BlastResult<String>;
    
    /// Get resource usage for environment
    fn get_resource_usage(&self, env: &PythonEnvironment) -> BlastResult<ResourceUsage>;
}

/// Current resource usage
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceUsage {
    /// Current memory usage (bytes)
    pub memory_usage: u64,
    /// Current CPU usage (percentage)
    pub cpu_usage: f32,
    /// Current disk usage (bytes)
    pub disk_usage: u64,
    /// Current network bandwidth (bytes/sec)
    pub bandwidth_usage: u64,
}

/// Trait for package verification
pub trait PackageVerification: Send + Sync {
    /// Verify package signature and integrity
    fn verify_package(&self, package: &Package) -> BlastResult<VerificationResult>;
    
    /// Scan package for known vulnerabilities
    fn scan_vulnerabilities(&self, package: &Package) -> BlastResult<Vec<Vulnerability>>;
    
    /// Verify package against security policy
    fn verify_policy(&self, package: &Package, policy: &SecurityPolicy) -> BlastResult<PolicyResult>;
}

/// Result of package verification
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VerificationResult {
    /// Whether verification passed
    pub verified: bool,
    /// Verification details
    pub details: String,
    /// Signature information if available
    pub signature: Option<SignatureInfo>,
    /// Any warnings found
    pub warnings: Vec<String>,
}

/// Package signature information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SignatureInfo {
    /// Signature type (e.g., GPG, X509)
    pub signature_type: String,
    /// Key identifier
    pub key_id: String,
    /// Signature timestamp
    pub timestamp: DateTime<Utc>,
    /// Signature validity
    pub valid: bool,
}

/// Known vulnerability
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vulnerability {
    /// Vulnerability ID (e.g., CVE)
    pub id: String,
    /// Severity level
    pub severity: VulnerabilitySeverity,
    /// Description
    pub description: String,
    /// Affected versions
    pub affected_versions: Vec<String>,
    /// Fix versions
    pub fixed_versions: Vec<String>,
    /// References
    pub references: Vec<String>,
}

/// Severity level for security vulnerabilities
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
pub enum VulnerabilitySeverity {
    /// Low severity
    Low,
    /// Medium severity
    Medium,
    /// High severity
    High,
    /// Critical severity
    Critical,
}

/// Result of policy verification
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PolicyResult {
    /// Whether policy check passed
    pub allowed: bool,
    /// Policy violations found
    pub violations: Vec<PolicyViolation>,
    /// Required actions
    pub required_actions: Vec<String>,
}

/// Policy violation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PolicyViolation {
    /// Rule that was violated
    pub rule: String,
    /// Violation details
    pub details: String,
    /// Severity of violation
    pub severity: VulnerabilitySeverity,
    /// Recommended actions
    pub recommendations: Vec<String>,
}

impl PolicyViolation {
    // ... existing implementation ...
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-core/src/error.rs

```rs
use std::path::PathBuf;
use std::io;
use glob::PatternError;
use thiserror::Error;

/// Custom result type for Blast operations
pub type BlastResult<T> = Result<T, BlastError>;

/// Custom error type for Blast operations
#[derive(Debug, Error)]
pub enum BlastError {
    #[error("IO error: {0}")]
    Io(String),

    #[error("Python error: {0}")]
    Python(String),

    #[error("Package error: {0}")]
    Package(String),

    #[error("Environment error: {0}")]
    Environment(String),

    #[error("Cache error: {0}")]
    Cache(String),

    #[error("Resolution error: {0}")]
    Resolution(String),

    #[error("Configuration error: {0}")]
    Config(String),

    #[error("Snapshot error: {0}")]
    Snapshot(String),

    #[error("Import hook error: {0}")]
    ImportHook(String),

    #[error("Invalid path: {0}")]
    InvalidPath(PathBuf),

    #[error("Network error: {0}")]
    Network(String),

    #[error("Serialization error: {0}")]
    Serialization(String),

    #[error("Version error: {0}")]
    Version(String),

    #[error("Lock error: {0}")]
    Lock(String),

    #[error("Pattern error: {0}")]
    Pattern(String),

    #[error("Daemon error: {0}")]
    Daemon(String),

    #[error("Command failed: {0} - {1}")]
    CommandFailed(String, String),

    #[error("Parse error: {0}")]
    ParseError(String),

    #[error("Other error: {0}")]
    Other(String),

    #[error("Sync error: {0}")]
    Sync(String),

    #[error("Security error: {0}")]
    Security(String),

    #[error("Manifest error: {0}")]
    Manifest(String),

    #[error("Unknown error: {0}")]
    Unknown(String),

    #[error("State error: {0}")]
    State(String),
}

impl BlastError {
    /// Create a new Python error
    pub fn python<S: Into<String>>(msg: S) -> Self {
        BlastError::Python(msg.into())
    }

    /// Create a new package error
    pub fn package<S: Into<String>>(msg: S) -> Self {
        BlastError::Package(msg.into())
    }

    /// Create a new environment error
    pub fn environment<S: Into<String>>(msg: S) -> Self {
        BlastError::Environment(msg.into())
    }

    /// Create a new cache error
    pub fn cache<S: Into<String>>(msg: S) -> Self {
        BlastError::Cache(msg.into())
    }

    /// Create a new resolution error
    pub fn resolution<S: Into<String>>(msg: S) -> Self {
        BlastError::Resolution(msg.into())
    }

    /// Create a new configuration error
    pub fn config<S: Into<String>>(msg: S) -> Self {
        BlastError::Config(msg.into())
    }

    /// Create a new snapshot error
    pub fn snapshot<S: Into<String>>(msg: S) -> Self {
        BlastError::Snapshot(msg.into())
    }

    /// Create a new import hook error
    pub fn import_hook<S: Into<String>>(msg: S) -> Self {
        BlastError::ImportHook(msg.into())
    }

    /// Create a new network error
    pub fn network<S: Into<String>>(msg: S) -> Self {
        BlastError::Network(msg.into())
    }

    /// Create a new serialization error
    pub fn serialization<S: Into<String>>(msg: S) -> Self {
        BlastError::Serialization(msg.into())
    }

    /// Create a new version error
    pub fn version<S: Into<String>>(msg: S) -> Self {
        BlastError::Version(msg.into())
    }

    /// Create a new lock error
    pub fn lock<S: Into<String>>(msg: S) -> Self {
        BlastError::Lock(msg.into())
    }

    /// Create a new other error
    pub fn other<S: Into<String>>(msg: S) -> Self {
        BlastError::Other(msg.into())
    }

    /// Create a new daemon error
    pub fn daemon<S: Into<String>>(msg: S) -> Self {
        BlastError::Daemon(msg.into())
    }

    /// Create a new sync error
    pub fn sync<S: Into<String>>(msg: S) -> Self {
        Self::Sync(msg.into())
    }

    /// Create a new security error
    pub fn security<S: Into<String>>(msg: S) -> Self {
        BlastError::Security(msg.into())
    }

    /// Create a new state error
    pub fn state<S: Into<String>>(msg: S) -> Self {
        Self::State(msg.into())
    }
}

impl From<serde_json::Error> for BlastError {
    fn from(err: serde_json::Error) -> Self {
        Self::Serialization(err.to_string())
    }
}

impl From<toml::de::Error> for BlastError {
    fn from(err: toml::de::Error) -> Self {
        Self::Serialization(err.to_string())
    }
}

impl From<toml::ser::Error> for BlastError {
    fn from(err: toml::ser::Error) -> Self {
        Self::Serialization(err.to_string())
    }
}

impl From<io::Error> for BlastError {
    fn from(err: io::Error) -> Self {
        Self::Io(err.to_string())
    }
}

impl From<PatternError> for BlastError {
    fn from(err: PatternError) -> Self {
        Self::Pattern(err.to_string())
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-core/src/config.rs

```rs
use std::path::{Path, PathBuf};
use serde::{Deserialize, Serialize};

use crate::error::{BlastError, BlastResult};
use crate::python::PythonVersion;
use crate::types::{CacheSettings, UpdateStrategy};

/// Configuration for a Blast environment
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BlastConfig {
    /// Project name
    pub name: String,
    /// Project version
    pub version: String,
    /// Required Python version
    pub python_version: PythonVersion,
    /// Update strategy
    pub update_strategy: UpdateStrategy,
    /// Cache settings
    pub cache_settings: CacheSettings,
    /// Project root directory
    pub project_root: PathBuf,
    /// Environment directory (relative to project root)
    pub env_dir: PathBuf,
    /// Dependencies configuration
    pub dependencies: DependenciesConfig,
    /// Development dependencies configuration
    pub dev_dependencies: Option<DependenciesConfig>,
}

impl BlastConfig {
    /// Create a new configuration
    pub fn new(
        name: impl Into<String>,
        version: impl Into<String>,
        python_version: PythonVersion,
        project_root: PathBuf,
    ) -> Self {
        Self {
            name: name.into(),
            version: version.into(),
            python_version,
            update_strategy: UpdateStrategy::default(),
            cache_settings: CacheSettings::default(),
            project_root,
            env_dir: PathBuf::from(".venv"),
            dependencies: DependenciesConfig::default(),
            dev_dependencies: None,
        }
    }

    /// Load configuration from a TOML file
    pub fn from_file<P: AsRef<Path>>(path: P) -> BlastResult<Self> {
        let contents = std::fs::read_to_string(path)?;
        Ok(toml::from_str(&contents)?)
    }

    /// Save configuration to a TOML file
    pub fn save(&self) -> BlastResult<()> {
        let config_path = self.project_root.join("blast.toml");
        let contents = toml::to_string_pretty(self)?;
        std::fs::write(config_path, contents)?;
        Ok(())
    }

    /// Get the absolute path to the environment directory
    pub fn env_path(&self) -> PathBuf {
        self.project_root.join(&self.env_dir)
    }

    /// Validate the configuration
    pub fn validate(&self) -> BlastResult<()> {
        if !self.env_dir.exists() {
            return Err(BlastError::config(format!(
                "Environment directory does not exist: {}",
                self.env_dir.display()
            )));
        }

        if self.env_dir.is_absolute() {
            return Err(BlastError::config(
                "Environment directory must be relative to project root"
            ));
        }

        Ok(())
    }

    pub fn name(&self) -> &str {
        &self.name
    }

    pub fn version(&self) -> &str {
        &self.version
    }

    pub fn python_version(&self) -> &PythonVersion {
        &self.python_version
    }

    pub fn root_dir(&self) -> &Path {
        &self.project_root
    }

    /// Convert config to TOML string
    pub fn to_toml(&self) -> BlastResult<String> {
        toml::to_string(self).map_err(|e| BlastError::Config(format!("Failed to serialize config: {}", e)))
    }

    /// Create config from TOML string
    pub fn from_toml(content: &str) -> BlastResult<Self> {
        toml::from_str(content).map_err(|e| BlastError::Config(format!("Failed to parse config: {}", e)))
    }
}

/// Configuration for dependencies
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct DependenciesConfig {
    /// Package dependencies with version constraints
    pub packages: Vec<DependencySpec>,
    /// Additional package indexes
    pub package_index: Option<Vec<String>>,
    /// Allow pre-releases
    pub allow_prereleases: bool,
}

/// Specification for a package dependency
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DependencySpec {
    /// Package name
    pub name: String,
    /// Version constraint
    pub version: String,
    /// Optional extras
    pub extras: Option<Vec<String>>,
    /// Optional package index
    pub index: Option<String>,
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-core/src/version.rs

```rs
use std::cmp::Ordering;
use std::fmt;
use std::str::FromStr;
use serde::{Deserialize, Serialize};
use semver::{Version as SemVer, VersionReq};

use crate::error::{BlastError, BlastResult};

/// Package version following PEP 440
#[derive(Debug, Clone, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub struct Version(SemVer);

impl Version {
    /// Create a new version
    pub fn new(version: SemVer) -> Self {
        Self(version)
    }

    /// Parse a version string
    pub fn parse(version: &str) -> BlastResult<Self> {
        Ok(Self(SemVer::parse(version).map_err(|e| {
            BlastError::version(format!("Invalid version '{}': {}", version, e))
        })?))
    }

    /// Get the underlying semver version
    pub fn as_semver(&self) -> &SemVer {
        &self.0
    }
}

impl FromStr for Version {
    type Err = BlastError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::parse(s)
    }
}

impl fmt::Display for Version {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.0.fmt(f)
    }
}

impl PartialOrd for Version {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for Version {
    fn cmp(&self, other: &Self) -> Ordering {
        self.0.cmp(&other.0)
    }
}

/// Version constraint following PEP 440
#[derive(Debug, Clone, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub struct VersionConstraint(VersionReq);

impl Default for VersionConstraint {
    fn default() -> Self {
        Self::any()
    }
}

impl VersionConstraint {
    /// Create a new version constraint
    pub fn new(req: VersionReq) -> Self {
        Self(req)
    }

    /// Create a constraint that matches any version
    pub fn any() -> Self {
        Self(VersionReq::STAR)
    }

    /// Parse a version constraint string
    pub fn parse(constraint: &str) -> BlastResult<Self> {
        Ok(Self(VersionReq::parse(constraint).map_err(|e| {
            BlastError::version(format!("Invalid version constraint '{}': {}", constraint, e))
        })?))
    }

    /// Check if a version matches this constraint
    pub fn matches(&self, version: &Version) -> bool {
        self.0.matches(version.as_semver())
    }
}

impl FromStr for VersionConstraint {
    type Err = BlastError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::parse(s)
    }
}

impl fmt::Display for VersionConstraint {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.0.fmt(f)
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-core/src/metadata.rs

```rs
use std::collections::HashMap;
use serde::{Deserialize, Serialize};

use crate::version::VersionConstraint;
use crate::error::BlastResult;

/// Package metadata information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PackageMetadata {
    /// Package name
    pub name: String,
    /// Package version
    pub version: String,
    /// Package description
    pub description: Option<String>,
    /// Package author
    pub author: Option<String>,
    /// Package homepage
    pub homepage: Option<String>,
    /// Package license
    pub license: Option<String>,
    /// Package keywords
    pub keywords: Vec<String>,
    /// Package classifiers
    pub classifiers: Vec<String>,
    /// Package documentation URL
    pub documentation: Option<String>,
    /// Package repository URL
    pub repository: Option<String>,
    /// Package dependencies
    pub dependencies: HashMap<String, VersionConstraint>,
    /// Package extras
    pub extras: HashMap<String, HashMap<String, VersionConstraint>>,
    /// Required Python version
    pub python_version: VersionConstraint,
    /// Package platform tags
    pub platform_tags: Vec<String>,
    /// Package is yanked
    pub yanked: bool,
    /// Yanked reason if applicable
    pub yanked_reason: Option<String>,
}

impl PackageMetadata {
    /// Create new package metadata
    pub fn new(
        name: String,
        version: String,
        dependencies: HashMap<String, VersionConstraint>,
        python_version: VersionConstraint,
    ) -> Self {
        Self {
            name,
            version,
            description: None,
            author: None,
            homepage: None,
            license: None,
            keywords: Vec::new(),
            classifiers: Vec::new(),
            documentation: None,
            repository: None,
            dependencies,
            extras: HashMap::new(),
            python_version,
            platform_tags: Vec::new(),
            yanked: false,
            yanked_reason: None,
        }
    }

    /// Check if package is compatible with the given Python version
    pub fn is_python_compatible(&self, version: &str) -> BlastResult<bool> {
        let version = crate::version::Version::parse(version)?;
        Ok(self.python_version.matches(&version))
    }

    /// Check if package is compatible with the given platform
    pub fn is_platform_compatible(&self, platform: &str) -> bool {
        if self.platform_tags.is_empty() {
            return true; // No platform restrictions
        }
        self.platform_tags.iter().any(|tag| tag == platform || tag == "any")
    }

    /// Get all dependencies including specified extras
    pub fn all_dependencies(&self, extras: &[String]) -> HashMap<String, VersionConstraint> {
        let mut deps = self.dependencies.clone();
        for extra in extras {
            if let Some(extra_deps) = self.extras.get(extra) {
                deps.extend(extra_deps.clone());
            }
        }
        deps
    }

    /// Check if package has a specific extra
    pub fn has_extra(&self, extra: &str) -> bool {
        self.extras.contains_key(extra)
    }

    /// Get dependencies for a specific extra
    pub fn extra_dependencies(&self, extra: &str) -> Option<&HashMap<String, VersionConstraint>> {
        self.extras.get(extra)
    }
}

/// Build metadata for a package
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BuildMetadata {
    /// Build system requirements
    pub build_requires: Vec<String>,
    /// Backend requirements
    pub backend_requires: Vec<String>,
    /// Build backend
    pub build_backend: String,
    /// Backend options
    pub backend_options: HashMap<String, String>,
}

impl Default for BuildMetadata {
    fn default() -> Self {
        Self {
            build_requires: vec!["setuptools>=40.8.0".to_string(), "wheel".to_string()],
            backend_requires: Vec::new(),
            build_backend: "setuptools.build_meta".to_string(),
            backend_options: HashMap::new(),
        }
    }
}

/// Package distribution metadata
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DistributionMetadata {
    /// Distribution type (wheel, sdist)
    pub dist_type: DistributionType,
    /// Python tags
    pub python_tags: Vec<String>,
    /// ABI tags
    pub abi_tags: Vec<String>,
    /// Platform tags
    pub platform_tags: Vec<String>,
    /// Build number
    pub build_number: Option<u32>,
    /// Build metadata
    pub build_metadata: Option<BuildMetadata>,
}

/// Type of distribution
#[derive(Debug, Clone, Eq, PartialEq, Serialize, Deserialize)]
pub enum DistributionType {
    /// Wheel distribution
    Wheel,
    /// Source distribution
    Sdist,
    /// Egg distribution (legacy)
    Egg,
}

impl DistributionType {
    // ... existing code ...
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-core/src/lib.rs

```rs
//! Core types and traits for the Blast Python environment manager.
//!
//! This crate provides the fundamental types, traits, and utilities that are used
//! throughout the Blast ecosystem.

use std::path::PathBuf;

use async_trait::async_trait;
use serde::{Deserialize, Serialize};

pub mod config;
pub mod error;
pub mod environment;
pub mod package;
pub mod python;
pub mod types;
pub mod utils;
pub mod version_control;
pub mod state;
pub mod sync;
pub mod version_history;
pub mod security;
pub mod manifest;
pub mod bindings;
pub mod version;
pub mod metadata;
pub mod layer;
pub mod resolution;
pub mod logging;
pub mod diagnostics;
pub mod ui;
pub mod debug;
pub mod hot_reload;
pub mod shell_scripts;

// Re-export commonly used types
pub use crate::config::BlastConfig;
pub use crate::error::{BlastError, BlastResult};
pub use crate::package::{Package, PackageId};
pub use crate::version::{Version, VersionConstraint};
pub use crate::python::{PythonEnvironment, PythonVersion};
pub use crate::types::{CacheSettings, UpdateStrategy};
pub use crate::version_control::{VersionManager, VersionPolicy, UpgradeStrategy};
pub use crate::version_history::{VersionHistory, VersionEvent, VersionImpact};
pub use crate::state::{EnvironmentState, StateCheckpoint, StateDiff, StateVerification};
pub use crate::sync::{SyncManager, SyncOperation, SyncStatus, SyncChange, SyncConflict, ConflictResolution};
pub use crate::manifest::{
    Manifest, BlastMetadata, SystemDependency, ResourceRequirements,
    VenvConfig, LayerInfo, LayerType, CompressionType,
};
pub use crate::security::SecurityPolicy;
pub use crate::bindings::{NativeEnvironment, NativePackage, NativeManifest};
pub use crate::metadata::{
    PackageMetadata, BuildMetadata, DistributionMetadata,
    DistributionType,
};
pub use crate::shell_scripts::ActivationScripts;

/// Core trait for environment management
#[async_trait]
pub trait EnvironmentManager: Send + Sync + 'static {
    /// Create a new Python environment
    async fn create_environment(&self, config: &BlastConfig) -> BlastResult<PythonEnvironment>;

    /// Update an existing environment
    async fn update_environment(&self, env: &PythonEnvironment) -> BlastResult<()>;

    /// Activate an environment
    async fn activate_environment(&self, env: &PythonEnvironment) -> BlastResult<()>;

    /// Deactivate an environment
    async fn deactivate_environment(&self, env: &PythonEnvironment) -> BlastResult<()>;
}

/// Core trait for dependency resolution
#[async_trait]
pub trait DependencyResolver: Send + Sync + 'static {
    /// Resolve dependencies for a package
    async fn resolve_dependencies(&self, package: &Package) -> BlastResult<Vec<Package>>;

    /// Check for updates to a package
    async fn check_updates(&self, package: &Package) -> BlastResult<Option<Package>>;

    /// Get package metadata from PyPI
    async fn get_package_metadata(&self, package_id: &PackageId) -> BlastResult<Package>;
}

/// Core trait for caching
#[async_trait]
pub trait Cache: Send + Sync + 'static {
    /// Store package in cache
    async fn store_package(&self, package: &Package, data: Vec<u8>) -> BlastResult<()>;

    /// Retrieve package from cache
    async fn get_package(&self, package: &Package) -> BlastResult<Option<Vec<u8>>>;

    /// Check if package exists in cache
    async fn has_package(&self, package: &Package) -> BlastResult<bool>;

    /// Clear cache
    async fn clear(&self) -> BlastResult<()>;
}

/// Core trait for environment snapshots
#[async_trait]
pub trait SnapshotManager: Send + Sync + 'static {
    /// Create a snapshot of an environment
    async fn create_snapshot(&self, env: &PythonEnvironment) -> BlastResult<PathBuf>;

    /// Restore an environment from a snapshot
    async fn restore_snapshot(&self, snapshot_path: &PathBuf) -> BlastResult<PythonEnvironment>;

    /// List available snapshots
    async fn list_snapshots(&self) -> BlastResult<Vec<PathBuf>>;
}

/// Core trait for monitoring Python imports
#[async_trait]
pub trait ImportMonitor: Send + Sync + 'static {
    /// Start monitoring imports
    async fn start_monitoring(&self) -> BlastResult<()>;

    /// Stop monitoring imports
    async fn stop_monitoring(&self) -> BlastResult<()>;

    /// Get current import statistics
    async fn get_statistics(&self) -> BlastResult<ImportStatistics>;
}

/// Statistics for Python imports
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ImportStatistics {
    /// Total number of imports
    pub total_imports: usize,
    /// Number of cached imports
    pub cached_imports: usize,
    /// Number of imports that triggered updates
    pub update_triggers: usize,
    /// Average import time in milliseconds
    pub average_import_time_ms: f64,
}

/// Core trait for manifest management
#[async_trait]
pub trait ManifestManager: Send + Sync + 'static {
    /// Get current manifest
    async fn get_manifest(&self) -> BlastResult<Manifest>;
    
    /// Update manifest
    async fn update_manifest(&self, manifest: &Manifest) -> BlastResult<()>;
    
    /// Record package installation
    async fn record_package_install(&self, package: &Package) -> BlastResult<()>;
    
    /// Record package removal
    async fn record_package_removal(&self, package: &Package) -> BlastResult<()>;
    
    /// Record environment variable change
    async fn record_env_var_change(&self, key: &str, value: &str) -> BlastResult<()>;
    
    /// Record system dependency
    async fn record_system_dependency(&self, dependency: &SystemDependency) -> BlastResult<()>;
    
    /// Record hook addition
    async fn record_hook_addition(&self, hook_type: &str, command: &str) -> BlastResult<()>;
    
    /// Verify manifest integrity
    async fn verify_manifest(&self) -> BlastResult<bool>;
}

/// Initialize the library
pub fn init() {
    // Set up logging if not already configured
    if std::env::var("RUST_LOG").is_err() {
        std::env::set_var("RUST_LOG", "info");
    }
    tracing_subscriber::fmt::init();
}
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-core/src/manifest.rs

```rs
/// Blast environment manifest module
/// Contains types and functions for managing Blast environment manifests
/// Provides functionality for serializing and deserializing environment configurations
/// Core manifest types and traits for managing environment manifests

use std::path::PathBuf;
use std::collections::HashMap;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use tokio::fs;

use crate::python::PythonVersion;
use crate::security::SecurityPolicy;
use crate::environment::Environment;
use crate::error::{BlastError, BlastResult};
use crate::package::Package;

/// Layer type for image layers
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum LayerType {
    /// Base Python installation
    Base,
    /// Package installations
    Packages,
    /// Custom files
    Custom,
    /// Configuration
    Config,
}

/// Compression type for layers
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum CompressionType {
    /// No compression
    None,
    /// Zstandard compression
    Zstd,
    /// GZIP compression
    Gzip,
}

/// Comprehensive metadata for Blast environments
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BlastMetadata {
    /// Environment name
    pub name: Option<String>,
    /// Environment version
    pub version: String,
    /// Creation timestamp
    pub created_at: DateTime<Utc>,
    /// Last modified timestamp
    pub modified_at: DateTime<Utc>,
    /// Python version with exact patch level
    pub python_version: PythonVersion,
    /// Author information
    pub author: Option<String>,
    /// Environment description
    pub description: Option<String>,
    /// License
    pub license: Option<String>,
    /// Environment variables required
    pub env_vars: HashMap<String, String>,
    /// Tags for categorization
    pub tags: Vec<String>,
    /// Direct dependencies with exact versions
    pub dependencies: HashMap<String, String>,
    /// All transitive dependencies with versions
    pub transitive_deps: HashMap<String, String>,
    /// System packages required (apt, brew, etc)
    pub system_deps: Vec<SystemDependency>,
    /// Platform requirements
    pub platform_requirements: PlatformRequirements,
    /// Security policy
    #[serde(skip)]
    pub security_policy: SecurityPolicy,
    /// Resource requirements
    pub resources: ResourceRequirements,
    /// Environment hooks (pre/post activation)
    pub env_hooks: HashMap<String, Vec<String>>,
    /// Virtual environment configuration
    pub venv_config: VenvConfig,
    /// Content hash for integrity verification
    pub content_hash: String,
    /// Custom metadata
    pub custom: HashMap<String, String>,
    /// Image layers information
    pub layers: Vec<LayerInfo>,
}

/// System dependency information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SystemDependency {
    /// Package name
    pub name: String,
    /// Version constraint
    pub version: String,
    /// Package manager (apt, brew, etc)
    pub package_manager: String,
    /// Installation commands if custom
    pub install_commands: Option<Vec<String>>,
}

/// Platform requirements for the environment
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlatformRequirements {
    /// Operating system requirements
    pub os: Vec<String>,
    /// CPU architecture
    pub arch: Vec<String>,
    /// Minimum CPU cores
    pub min_cores: u32,
    /// Minimum memory in bytes
    pub min_memory: u64,
    /// Minimum disk space in bytes
    pub min_disk_space: u64,
    /// Required system features
    pub required_features: Vec<String>,
}

/// Resource requirements for the environment
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceRequirements {
    /// Maximum memory usage
    pub max_memory: u64,
    /// Maximum disk usage
    pub max_disk: u64,
    /// CPU usage limits
    pub cpu_limit: Option<f64>,
    /// Network bandwidth limits
    pub network_limit: Option<u64>,
    /// Maximum number of processes
    pub max_processes: u32,
    /// Temporary storage requirements
    pub temp_storage: u64,
}

/// Virtual environment configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VenvConfig {
    /// Python executable path
    pub python_path: PathBuf,
    /// Site-packages directory
    pub site_packages: PathBuf,
    /// Include system site-packages
    pub system_site_packages: bool,
    /// Prompt prefix
    pub prompt: String,
    /// Additional paths to add to PYTHONPATH
    pub python_path_additions: Vec<PathBuf>,
    /// Symlinks to create
    pub symlinks: HashMap<PathBuf, PathBuf>,
}

/// Layer information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LayerInfo {
    /// Layer ID
    pub id: String,
    /// Layer type (base, packages, etc.)
    pub layer_type: LayerType,
    /// Layer size in bytes
    pub size: u64,
    /// Layer compression type
    pub compression: CompressionType,
    /// Layer hash for integrity verification
    pub hash: String,
    /// Layer creation timestamp
    pub created_at: DateTime<Utc>,
}

/// Manifest for a Blast environment
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Manifest {
    /// Metadata about the environment
    pub metadata: BlastMetadata,
    /// Installed packages with versions
    pub packages: Vec<Package>,
    /// Manifest format version
    pub format_version: String,
    /// Python version
    pub python_version: PythonVersion,
}

impl Default for PlatformRequirements {
    fn default() -> Self {
        Self {
            os: vec!["linux".to_string(), "darwin".to_string()],
            arch: vec!["x86_64".to_string(), "aarch64".to_string()],
            min_cores: 1,
            min_memory: 1024 * 1024 * 1024, // 1GB
            min_disk_space: 5 * 1024 * 1024 * 1024, // 5GB
            required_features: Vec::new(),
        }
    }
}

impl Default for ResourceRequirements {
    fn default() -> Self {
        Self {
            max_memory: 4 * 1024 * 1024 * 1024, // 4GB
            max_disk: 10 * 1024 * 1024 * 1024,  // 10GB
            cpu_limit: None,
            network_limit: None,
            max_processes: 32,
            temp_storage: 1024 * 1024 * 1024,   // 1GB
        }
    }
}

impl Default for VenvConfig {
    fn default() -> Self {
        Self {
            python_path: PathBuf::from("bin/python"),
            site_packages: PathBuf::from("lib/python/site-packages"),
            system_site_packages: false,
            prompt: "(.venv)".to_string(),
            python_path_additions: Vec::new(),
            symlinks: HashMap::new(),
        }
    }
}

impl Default for Manifest {
    fn default() -> Self {
        Self {
            packages: Vec::new(),
            metadata: BlastMetadata {
                name: None,
                version: "0.1.0".to_string(),
                description: None,
                created_at: Utc::now(),
                modified_at: Utc::now(),
                python_version: PythonVersion::new(3, 8, None),
                author: None,
                license: None,
                env_vars: HashMap::new(),
                tags: Vec::new(),
                dependencies: HashMap::new(),
                transitive_deps: HashMap::new(),
                system_deps: Vec::new(),
                platform_requirements: PlatformRequirements::default(),
                security_policy: SecurityPolicy::default(),
                resources: ResourceRequirements::default(),
                env_hooks: HashMap::new(),
                venv_config: VenvConfig::default(),
                content_hash: String::new(),
                custom: HashMap::new(),
                layers: Vec::new(),
            },
            format_version: "1.0.0".to_string(),
            python_version: PythonVersion::new(3, 8, None),
        }
    }
}

impl Manifest {
    pub fn new() -> Self {
        Self {
            packages: Vec::new(),
            metadata: BlastMetadata {
                name: None,
                version: "0.1.0".to_string(),
                created_at: Utc::now(),
                modified_at: Utc::now(),
                python_version: PythonVersion::new(3, 8, None),
                author: None,
                description: None,
                license: None,
                env_vars: HashMap::new(),
                tags: Vec::new(),
                dependencies: HashMap::new(),
                transitive_deps: HashMap::new(),
                system_deps: Vec::new(),
                platform_requirements: PlatformRequirements::default(),
                security_policy: SecurityPolicy::default(),
                resources: ResourceRequirements::default(),
                env_hooks: HashMap::new(),
                venv_config: VenvConfig::default(),
                content_hash: String::new(),
                custom: HashMap::new(),
                layers: Vec::new(),
            },
            format_version: "1.0.0".to_string(),
            python_version: PythonVersion::new(3, 8, None),
        }
    }

    pub async fn from_environment<E: Environment>(env: &E) -> BlastResult<Self> {
        let packages = env.get_packages().await?;
        Ok(Self {
            packages,
            metadata: BlastMetadata {
                name: env.name().map(ToString::to_string),
                version: "0.1.0".to_string(),
                created_at: Utc::now(),
                modified_at: Utc::now(),
                python_version: env.python_version().clone(),
                author: None,
                description: None,
                license: None,
                env_vars: HashMap::new(),
                tags: Vec::new(),
                dependencies: HashMap::new(),
                transitive_deps: HashMap::new(),
                system_deps: Vec::new(),
                platform_requirements: PlatformRequirements::default(),
                security_policy: SecurityPolicy::default(),
                resources: ResourceRequirements::default(),
                env_hooks: HashMap::new(),
                venv_config: VenvConfig::default(),
                content_hash: String::new(),
                custom: HashMap::new(),
                layers: Vec::new(),
            },
            format_version: "1.0.0".to_string(),
            python_version: env.python_version().clone(),
        })
    }

    pub async fn save(&self, path: PathBuf) -> BlastResult<()> {
        let content = serde_json::to_string_pretty(self)
            .map_err(|e| BlastError::Manifest(e.to_string()))?;
        fs::write(&path, content)
            .await
            .map_err(|e| BlastError::Io(e.to_string()))?;
        Ok(())
    }

    pub async fn load(path: PathBuf) -> BlastResult<Self> {
        let content = fs::read_to_string(&path)
            .await
            .map_err(|e| BlastError::Io(e.to_string()))?;
        serde_json::from_str(&content)
            .map_err(|e| BlastError::Manifest(e.to_string()))
    }

    pub fn packages(&self) -> &[Package] {
        &self.packages
    }

    pub fn add_package(&mut self, package: Package) {
        self.packages.push(package);
    }

    pub fn remove_package(&mut self, name: &str) {
        self.packages.retain(|p| p.name() != name);
    }
}

impl<T: Environment> From<&T> for Manifest {
    fn from(env: &T) -> Self {
        Self {
            metadata: BlastMetadata {
                name: env.name().map(ToString::to_string),
                version: "0.1.0".to_string(),
                description: None,
                created_at: Utc::now(),
                modified_at: Utc::now(),
                python_version: env.python_version().clone(),
                author: None,
                license: None,
                env_vars: HashMap::new(),
                tags: Vec::new(),
                dependencies: HashMap::new(),
                transitive_deps: HashMap::new(),
                system_deps: Vec::new(),
                platform_requirements: PlatformRequirements::default(),
                security_policy: SecurityPolicy::default(),
                resources: ResourceRequirements::default(),
                env_hooks: HashMap::new(),
                venv_config: VenvConfig::default(),
                content_hash: String::new(),
                custom: HashMap::new(),
                layers: Vec::new(),
            },
            packages: Vec::new(),
            format_version: "1.0.0".to_string(),
            python_version: env.python_version().clone(),
        }
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-core/src/version_history.rs

```rs
use std::collections::HashSet;
use std::collections::HashMap;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

use crate::version::{Version, VersionConstraint};
use crate::python::PythonVersion;

/// Version change impact level
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum VersionImpact {
    /// No impact (patch version)
    None,
    /// Minor impact (new features)
    Minor,
    /// Major impact (breaking changes)
    Major,
    /// Breaking change
    Breaking,
}

impl VersionImpact {
    /// Determine impact level from version change
    pub fn from_version_change(from: &Version, to: &Version) -> Self {
        if from.as_semver().major != to.as_semver().major {
            Self::Breaking
        } else if from.as_semver().minor != to.as_semver().minor {
            Self::Major
        } else if from.as_semver().patch != to.as_semver().patch {
            Self::Minor
        } else {
            Self::None
        }
    }

    /// Check if the impact is a breaking change
    pub fn is_breaking(&self) -> bool {
        matches!(self, Self::Breaking)
    }
}

/// Version change event
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VersionEvent {
    /// Event timestamp
    pub timestamp: DateTime<Utc>,
    /// Previous version
    pub from_version: Option<Version>,
    /// New version
    pub to_version: Version,
    /// Change impact level
    pub impact: VersionImpact,
    /// Change reason
    pub reason: String,
    /// Python version at time of change
    pub python_version: PythonVersion,
    /// Whether this was a direct dependency
    pub is_direct: bool,
    /// Dependencies affected by this change
    pub affected_dependencies: HashMap<String, String>,
    /// Whether the change was approved
    pub approved: bool,
    /// Who approved the change
    pub approved_by: Option<String>,
    /// Policy at time of change
    pub policy_snapshot: Option<String>,
}

/// Analysis of version change impact
#[derive(Debug, Clone)]
pub struct VersionChangeAnalysis {
    /// Impact level
    pub impact: VersionImpact,
    /// Affected dependent packages
    pub affected_dependents: HashSet<String>,
    /// Breaking changes
    pub breaking_changes: Vec<String>,
    /// Compatibility issues
    pub compatibility_issues: Vec<String>,
}

impl VersionChangeAnalysis {
    /// Check if change is safe to apply
    pub fn is_safe(&self) -> bool {
        self.impact != VersionImpact::Breaking && 
        self.affected_dependents.is_empty() &&
        self.breaking_changes.is_empty() &&
        self.compatibility_issues.is_empty()
    }

    /// Generate analysis report
    pub fn generate_report(&self) -> String {
        let mut report = String::new();
        report.push_str(&format!("Version Change Impact: {:?}\n\n", self.impact));

        if !self.affected_dependents.is_empty() {
            report.push_str("Affected Dependent Packages:\n");
            for dep in &self.affected_dependents {
                report.push_str(&format!("  - {}\n", dep));
            }
            report.push_str("\n");
        }

        if !self.breaking_changes.is_empty() {
            report.push_str("Breaking Changes:\n");
            for change in &self.breaking_changes {
                report.push_str(&format!("  - {}\n", change));
            }
            report.push_str("\n");
        }

        if !self.compatibility_issues.is_empty() {
            report.push_str("Compatibility Issues:\n");
            for issue in &self.compatibility_issues {
                report.push_str(&format!("  - {}\n", issue));
            }
            report.push_str("\n");
        }

        report.push_str(&format!(
            "Safe to Apply: {}\n",
            if self.is_safe() { "Yes" } else { "No" }
        ));

        report
    }
}

/// Version history for a package
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VersionHistory {
    /// Package name
    pub package_name: String,
    /// Version events
    pub events: Vec<VersionEvent>,
    /// Current version
    pub current_version: Option<Version>,
    /// Version requirements
    pub requirements: HashMap<String, String>,
    /// Dependent packages
    pub dependents: Vec<String>,
}

impl VersionHistory {
    /// Create new version history
    pub fn new(package_name: String) -> Self {
        Self {
            package_name,
            events: Vec::new(),
            current_version: None,
            requirements: HashMap::new(),
            dependents: Vec::new(),
        }
    }

    /// Add a version event
    pub fn add_event(&mut self, event: VersionEvent) {
        self.current_version = Some(event.to_version.clone());
        self.events.push(event);
    }

    /// Check if a version exists in the history
    pub fn has_version(&self, version: &Version) -> bool {
        self.events.iter().any(|e| &e.to_version == version)
    }

    /// Get version events
    pub fn get_events(&self) -> &[VersionEvent] {
        &self.events
    }

    /// Get version requirements
    pub fn get_requirements(&self) -> &HashMap<String, String> {
        &self.requirements
    }

    /// Get dependent packages
    pub fn get_dependents(&self) -> &Vec<String> {
        &self.dependents
    }

    /// Check if version satisfies all requirements
    pub fn check_version(&self, version: &Version) -> bool {
        self.requirements.iter().all(|(_, req_str)| {
            if let Ok(req) = VersionConstraint::parse(req_str) {
                req.matches(version)
            } else {
                false
            }
        })
    }

    /// Find the latest compatible version
    pub fn find_latest_compatible(&self) -> Option<&Version> {
        self.events
            .iter()
            .rev()
            .find(|event| {
                self.check_version(&event.to_version)
            })
            .map(|event| &event.to_version)
    }

    /// Analyze impact of version change
    pub fn analyze_change_impact(&self, from: &Version, to: &Version) -> VersionChangeAnalysis {
        let mut analysis = VersionChangeAnalysis {
            impact: VersionImpact::from_version_change(from, to),
            affected_dependents: HashSet::new(),
            breaking_changes: Vec::new(),
            compatibility_issues: Vec::new(),
        };

        // Check for breaking changes
        if analysis.impact.is_breaking() {
            analysis.breaking_changes.push(format!(
                "Breaking version change from {} to {} may introduce breaking changes",
                from, to
            ));
        }

        // Check dependent packages
        for dependent in &self.dependents {
            if let Some(req) = self.requirements.get(dependent) {
                if !VersionConstraint::parse(req).unwrap().matches(to) {
                    analysis.affected_dependents.insert(dependent.clone());
                    analysis.compatibility_issues.push(format!(
                        "Package {} requires version {}, which is incompatible with {}",
                        dependent, req, to
                    ));
                }
            }
        }

        analysis
    }

    /// Generate version history report
    pub fn generate_report(&self) -> String {
        let mut report = format!("Version History Report for {}\n", self.package_name);
        report.push_str("=====================================\n\n");

        for event in &self.events {
            report.push_str(&format!(
                "Version Change: {} -> {}\n",
                event.from_version.as_ref().map(|v| v.to_string()).unwrap_or_else(|| "None".to_string()),
                event.to_version
            ));
            report.push_str(&format!("Timestamp: {}\n", event.timestamp));
            report.push_str(&format!("Impact: {:?}\n", event.impact));
            report.push_str(&format!("Reason: {}\n", event.reason));
            report.push_str(&format!("Python Version: {}\n", event.python_version));
            report.push_str(&format!("Direct Dependency: {}\n", event.is_direct));
            
            if !event.affected_dependencies.is_empty() {
                report.push_str("Affected Dependencies:\n");
                for (dep, _) in &event.affected_dependencies {
                    report.push_str(&format!("  - {}\n", dep));
                }
            }

            if event.approved {
                report.push_str(&format!(
                    "Approved by: {}\n",
                    event.approved_by.as_deref().unwrap_or("Unknown")
                ));
            }

            report.push_str("\n");
        }

        if !self.requirements.is_empty() {
            report.push_str("\nVersion Requirements:\n");
            for (pkg, req) in &self.requirements {
                report.push_str(&format!("  - {} requires {}\n", pkg, req));
            }
        }

        if !self.dependents.is_empty() {
            report.push_str("\nDependent Packages:\n");
            for dep in &self.dependents {
                report.push_str(&format!("  - {}\n", dep));
            }
        }

        report
    }

    /// Add a requirement to the version history
    pub fn add_requirement(&mut self, requirement: VersionConstraint) {
        self.requirements.insert(
            self.package_name.clone(),
            requirement.to_string()
        );
    }

    /// Add a dependent package to the version history
    pub fn add_dependent(&mut self, package: String, version: Version) {
        let package_name = package.clone();
        self.dependents.push(package_name);
        self.requirements.insert(package, version.to_string());
    }
}
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-core/src/logging.rs

```rs
use std::collections::HashMap;
use std::time::Instant;
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};
use tracing::Level;
use tracing_subscriber::fmt::format::FmtSpan;
use std::cmp::Ordering;

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum LogLevel {
    Error,
    Warn,
    Info,
    Debug,
    Trace,
}

impl PartialOrd for LogLevel {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for LogLevel {
    fn cmp(&self, other: &Self) -> Ordering {
        // Higher severity = lower number
        match (self, other) {
            (LogLevel::Error, LogLevel::Error) => Ordering::Equal,
            (LogLevel::Error, _) => Ordering::Less,
            (LogLevel::Warn, LogLevel::Error) => Ordering::Greater,
            (LogLevel::Warn, LogLevel::Warn) => Ordering::Equal,
            (LogLevel::Warn, _) => Ordering::Less,
            (LogLevel::Info, LogLevel::Error | LogLevel::Warn) => Ordering::Greater,
            (LogLevel::Info, LogLevel::Info) => Ordering::Equal,
            (LogLevel::Info, _) => Ordering::Less,
            (LogLevel::Debug, LogLevel::Trace) => Ordering::Less,
            (LogLevel::Debug, LogLevel::Debug) => Ordering::Equal,
            (LogLevel::Debug, _) => Ordering::Greater,
            (LogLevel::Trace, LogLevel::Trace) => Ordering::Equal,
            (LogLevel::Trace, _) => Ordering::Greater,
        }
    }
}

impl From<Level> for LogLevel {
    fn from(level: Level) -> Self {
        match level {
            Level::ERROR => LogLevel::Error,
            Level::WARN => LogLevel::Warn,
            Level::INFO => LogLevel::Info,
            Level::DEBUG => LogLevel::Debug,
            Level::TRACE => LogLevel::Trace,
        }
    }
}

impl From<LogLevel> for Level {
    fn from(level: LogLevel) -> Self {
        match level {
            LogLevel::Error => Level::ERROR,
            LogLevel::Warn => Level::WARN,
            LogLevel::Info => Level::INFO,
            LogLevel::Debug => Level::DEBUG,
            LogLevel::Trace => Level::TRACE,
        }
    }
}

/// Log record with structured data
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LogRecord {
    /// Log level
    pub level: LogLevel,
    /// Log message
    pub message: String,
    /// Target module/component
    pub target: String,
    /// Timestamp
    pub timestamp: DateTime<Utc>,
    /// Thread ID
    pub thread_id: u64,
    /// Operation timing information
    pub timing: Option<OperationTiming>,
    /// Memory usage metrics
    pub memory: Option<MemoryMetrics>,
    /// Custom fields
    pub fields: HashMap<String, serde_json::Value>,
}

/// Operation timing information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OperationTiming {
    /// Total duration
    pub duration: std::time::Duration,
    /// CPU time used
    pub cpu_time: std::time::Duration,
    /// Time spent in I/O
    pub io_time: Option<std::time::Duration>,
    /// Time spent in network operations
    pub network_time: Option<std::time::Duration>,
}

/// Memory usage metrics
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MemoryMetrics {
    /// Current memory usage
    pub current_usage: u64,
    /// Peak memory usage
    pub peak_usage: u64,
    /// Allocated memory
    pub allocated: u64,
    /// Memory allocator statistics
    pub allocator_stats: Option<AllocatorStats>,
}

/// Memory allocator statistics
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AllocatorStats {
    /// Total allocations
    pub total_allocations: u64,
    /// Active allocations
    pub active_allocations: u64,
    /// Total deallocations
    pub total_deallocations: u64,
    /// Fragmentation ratio
    pub fragmentation_ratio: f64,
}

/// Performance metrics for operations
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PerformanceMetrics {
    /// Operation throughput
    pub throughput: f64,
    /// Operation latency
    pub latency: std::time::Duration,
    /// Resource utilization
    pub resource_utilization: f64,
    /// Cache hit ratio
    pub cache_hit_ratio: f64,
}

/// Structured logger implementation
#[derive(Debug)]
pub struct StructuredLogger {
    /// Log level filter
    level: LogLevel,
    /// Performance metrics collection
    metrics: HashMap<String, PerformanceMetrics>,
    /// Operation timers
    timers: HashMap<String, Instant>,
    /// Memory tracking
    memory_tracker: Option<MemoryTracker>,
}

impl StructuredLogger {
    /// Create a new structured logger
    pub fn new(level: LogLevel) -> Self {
        Self {
            level,
            metrics: HashMap::new(),
            timers: HashMap::new(),
            memory_tracker: Some(MemoryTracker::new()),
        }
    }

    /// Start timing an operation
    pub fn start_operation(&mut self, operation: &str) {
        self.timers.insert(operation.to_string(), Instant::now());
    }

    /// End timing an operation and record metrics
    pub fn end_operation(&mut self, operation: &str) -> Option<OperationTiming> {
        self.timers.remove(operation).map(|start| {
            let duration = start.elapsed();
            // TODO: Implement CPU time measurement
            let cpu_time = duration; // Placeholder
            
            OperationTiming {
                duration,
                cpu_time,
                io_time: None,
                network_time: None,
            }
        })
    }

    /// Log a message with structured data
    pub fn log(&mut self, record: LogRecord) {
        let tracing_level: Level = record.level.clone().into();
        if record.level <= self.level {
            // Update performance metrics if timing is available
            if let Some(timing) = &record.timing {
                if let Some(metrics) = self.metrics.get_mut(&record.target) {
                    metrics.latency = timing.duration;
                }
            }

            // Format and output the log record
            let target = record.target.clone();
            let message = record.message.clone();
            let timestamp = record.timestamp;
            let thread_id = record.thread_id;
            let timing = record.timing.clone();
            let memory = record.memory.clone();
            let fields = record.fields.clone();

            match tracing_level {
                Level::ERROR => {
                    tracing::error!(
                        target = %target,
                        message = %message,
                        timestamp = %timestamp,
                        thread_id = thread_id,
                        ?timing,
                        ?memory,
                        ?fields,
                    );
                }
                Level::WARN => {
                    tracing::warn!(
                        target = %target,
                        message = %message,
                        timestamp = %timestamp,
                        thread_id = thread_id,
                        ?timing,
                        ?memory,
                        ?fields,
                    );
                }
                Level::INFO => {
                    tracing::info!(
                        target = %target,
                        message = %message,
                        timestamp = %timestamp,
                        thread_id = thread_id,
                        ?timing,
                        ?memory,
                        ?fields,
                    );
                }
                Level::DEBUG => {
                    tracing::debug!(
                        target = %target,
                        message = %message,
                        timestamp = %timestamp,
                        thread_id = thread_id,
                        ?timing,
                        ?memory,
                        ?fields,
                    );
                }
                Level::TRACE => {
                    tracing::trace!(
                        target = %target,
                        message = %message,
                        timestamp = %timestamp,
                        thread_id = thread_id,
                        ?timing,
                        ?memory,
                        ?fields,
                    );
                }
            }
        }
    }

    /// Get current performance metrics
    pub fn get_metrics(&self) -> &HashMap<String, PerformanceMetrics> {
        &self.metrics
    }

    /// Get memory metrics
    pub fn get_memory_metrics(&self) -> Option<MemoryMetrics> {
        self.memory_tracker.as_ref().map(|tracker| tracker.get_metrics())
    }
}

/// Memory usage tracking
#[derive(Debug)]
struct MemoryTracker {
    start_usage: u64,
    peak_usage: u64,
}

impl MemoryTracker {
    fn new() -> Self {
        let current = Self::get_current_memory_usage();
        Self {
            start_usage: current,
            peak_usage: current,
        }
    }

    fn get_metrics(&self) -> MemoryMetrics {
        let current = Self::get_current_memory_usage();
        MemoryMetrics {
            current_usage: current,
            peak_usage: self.peak_usage,
            allocated: current - self.start_usage,
            allocator_stats: Some(self.get_allocator_stats()),
        }
    }

    fn get_current_memory_usage() -> u64 {
        // TODO: Implement platform-specific memory usage tracking
        0
    }

    fn get_allocator_stats(&self) -> AllocatorStats {
        // TODO: Implement allocator statistics collection
        AllocatorStats {
            total_allocations: 0,
            active_allocations: 0,
            total_deallocations: 0,
            fragmentation_ratio: 0.0,
        }
    }
}

/// Initialize the logging system
pub fn init_logging(level: LogLevel) -> StructuredLogger {
    let tracing_level: Level = level.clone().into();
    
    // Set up tracing subscriber with JSON formatting
    tracing_subscriber::fmt()
        .with_level(true)
        .with_target(true)
        .with_thread_ids(true)
        .with_file(true)
        .with_line_number(true)
        .with_span_events(FmtSpan::FULL)
        .with_timer(tracing_subscriber::fmt::time::ChronoLocal::new("%Y-%m-%d %H:%M:%S%.3f".to_string()))
        .with_env_filter(tracing_level.to_string())
        .json()
        .flatten_event(true)
        .try_init()
        .expect("Failed to set global subscriber");

    StructuredLogger::new(level)
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-core/src/package.rs

```rs
use std::collections::HashMap;
use std::fmt;
use serde::{Deserialize, Serialize};

use crate::error::BlastResult;
use crate::version::{Version, VersionConstraint};
use crate::metadata::{PackageMetadata, BuildMetadata, DistributionMetadata};

/// Unique identifier for a package
#[derive(Debug, Clone, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub struct PackageId {
    name: String,
    version: Version,
}

impl PackageId {
    /// Create a new package ID
    pub fn new(name: impl Into<String>, version: Version) -> Self {
        Self {
            name: name.into(),
            version,
        }
    }

    /// Get the package name
    pub fn name(&self) -> &str {
        &self.name
    }

    /// Get the package version
    pub fn version(&self) -> &Version {
        &self.version
    }
}

impl fmt::Display for PackageId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}=={}", self.name, self.version)
    }
}

/// A Python package
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Package {
    /// Package identifier
    id: PackageId,
    /// Package metadata
    metadata: PackageMetadata,
    /// Build metadata
    build_metadata: Option<BuildMetadata>,
    /// Distribution metadata
    dist_metadata: Option<DistributionMetadata>,
}

impl Package {
    /// Create a new package
    pub fn new(
        name: String,
        version_str: String,
        dependencies: impl Into<PackageMetadata>,
        python_version: VersionConstraint,
    ) -> BlastResult<Self> {
        let version = Version::parse(&version_str)?;
        let id = PackageId::new(name.clone(), version.clone());
        let mut metadata = dependencies.into();
        metadata.python_version = python_version;

        Ok(Self {
            id,
            metadata,
            build_metadata: None,
            dist_metadata: None,
        })
    }

    /// Get the package ID
    pub fn id(&self) -> &PackageId {
        &self.id
    }

    /// Get the package name
    pub fn name(&self) -> &str {
        self.id.name()
    }

    /// Get the package version
    pub fn version(&self) -> &Version {
        self.id.version()
    }

    /// Get the package metadata
    pub fn metadata(&self) -> &PackageMetadata {
        &self.metadata
    }

    /// Get mutable package metadata
    pub fn metadata_mut(&mut self) -> &mut PackageMetadata {
        &mut self.metadata
    }

    /// Get the build metadata
    pub fn build_metadata(&self) -> Option<&BuildMetadata> {
        self.build_metadata.as_ref()
    }

    /// Set the build metadata
    pub fn set_build_metadata(&mut self, metadata: BuildMetadata) {
        self.build_metadata = Some(metadata);
    }

    /// Get the distribution metadata
    pub fn dist_metadata(&self) -> Option<&DistributionMetadata> {
        self.dist_metadata.as_ref()
    }

    /// Set the distribution metadata
    pub fn set_dist_metadata(&mut self, metadata: DistributionMetadata) {
        self.dist_metadata = Some(metadata);
    }

    /// Check if package is compatible with the given Python version
    pub fn is_python_compatible(&self, version: &str) -> BlastResult<bool> {
        self.metadata.is_python_compatible(version)
    }

    /// Check if package is compatible with the given platform
    pub fn is_platform_compatible(&self, platform: &str) -> bool {
        self.metadata.is_platform_compatible(platform)
    }

    /// Get all dependencies including specified extras
    pub fn all_dependencies(&self, extras: &[String]) -> HashMap<String, VersionConstraint> {
        self.metadata.all_dependencies(extras)
    }

    /// Check if package has a specific extra
    pub fn has_extra(&self, extra: &str) -> bool {
        self.metadata.has_extra(extra)
    }

    /// Get dependencies for a specific extra
    pub fn extra_dependencies(&self, extra: &str) -> Option<HashMap<String, VersionConstraint>> {
        self.metadata.extra_dependencies(extra).map(|deps| deps.clone())
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-core/src/mod.rs

```rs
pub mod error;
pub mod package;
pub mod python;
pub mod version;
pub mod layer;

// Re-export main types
pub use error::{BlastError, BlastResult};
pub use package::Package;
pub use python::{PythonEnvironment, PythonVersion};
pub use version::{Version, VersionConstraint}; 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-core/src/hot_reload.rs

```rs
use std::{
    collections::{HashMap, HashSet},
    path::Path,
    sync::Arc,
};
use tokio::sync::Mutex;
use notify::{Watcher, RecursiveMode, Event, EventKind};
use tracing::{debug, warn};
use regex::Regex;
use crate::{
    error::{BlastError, BlastResult},
    version::Version,
    python::PythonEnvironment,
    sync::SyncManager,
    package::Package,
};

/// Custom error type for hot reload operations
#[derive(Debug, thiserror::Error)]
pub enum HotReloadError {
    #[error("Notify error: {0}")]
    Notify(#[from] notify::Error),
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    #[error("Python parsing error: {0}")]
    PythonParse(String),
}

impl From<HotReloadError> for BlastError {
    fn from(err: HotReloadError) -> Self {
        BlastError::environment(err.to_string())
    }
}

/// Represents a Python import statement
#[derive(Debug, Clone, PartialEq, Eq)]
struct ImportStatement {
    /// The module being imported
    module: String,
    /// Specific names being imported (for 'from' imports)
    names: Vec<String>,
    /// Whether this is a 'from' import
    is_from: bool,
    /// The full module path for 'from' imports
    from_path: Option<String>,
}

impl ImportStatement {
    fn new(module: String) -> Self {
        Self {
            module,
            names: Vec::new(),
            is_from: false,
            from_path: None,
        }
    }

    fn with_names(module: String, names: Vec<String>, from_path: String) -> Self {
        Self {
            module,
            names,
            is_from: true,
            from_path: Some(from_path),
        }
    }

    /// Get the root package name that needs to be installed
    fn get_package_name(&self) -> String {
        if self.is_from {
            // For 'from' imports, use the first part of the path
            self.from_path.as_ref()
                .and_then(|p| p.split('.').next())
                .unwrap_or(&self.module)
                .to_string()
        } else {
            // For regular imports, use the first part of the module name
            self.module.split('.').next()
                .unwrap_or(&self.module)
                .to_string()
        }
    }
}

/// Hot reload manager for Python environments
pub struct HotReloadManager {
    /// Active environments
    environments: Arc<Mutex<HashMap<String, EnvironmentContext>>>,
    /// File system watcher
    watcher: Arc<Mutex<notify::RecommendedWatcher>>,
    /// Sync manager for version synchronization
    sync_manager: Arc<Mutex<SyncManager>>,
}

/// Environment context for hot reloading
#[derive(Clone)]
struct EnvironmentContext {
    /// Environment reference
    environment: PythonEnvironment,
    /// Package versions
    package_versions: HashMap<String, Version>,
    /// Last sync operation
    last_sync: Option<String>,
}

impl HotReloadManager {
    /// Parse Python imports from a line of code
    fn parse_imports_from_line(line: &str) -> Vec<ImportStatement> {
        let mut imports = Vec::new();
        let line = line.trim();

        // Skip comments and empty lines
        if line.starts_with('#') || line.is_empty() {
            return imports;
        }

        // Handle multiline imports with parentheses
        if line.contains('(') && !line.contains(')') {
            // This is a multiline import - it should be handled by the caller
            return imports;
        }

        // Match 'from ... import ...' statements
        if line.starts_with("from ") {
            let from_re = Regex::new(r"^from\s+([.\w]+)\s+import\s+(.+)$").unwrap();
            if let Some(caps) = from_re.captures(line) {
                let from_path = caps.get(1).unwrap().as_str().to_string();
                let imports_str = caps.get(2).unwrap().as_str();

                // Handle multiple imports
                let names: Vec<String> = imports_str
                    .split(',')
                    .map(|s| s.trim().to_string())
                    .filter(|s| !s.is_empty())
                    .collect();

                if !names.is_empty() {
                    imports.push(ImportStatement::with_names(
                        names[0].clone(),
                        names,
                        from_path,
                    ));
                }
            }
        }
        // Match 'import ...' statements
        else if line.starts_with("import ") {
            let import_re = Regex::new(r"^import\s+(.+)$").unwrap();
            if let Some(caps) = import_re.captures(line) {
                let modules = caps.get(1).unwrap().as_str();
                
                // Handle multiple imports and aliases
                for module in modules.split(',') {
                    let module = module.trim();
                    if module.is_empty() {
                        continue;
                    }

                    // Handle 'as' aliases
                    let module_name = module.split_whitespace()
                        .next()
                        .unwrap_or(module)
                        .to_string();

                    imports.push(ImportStatement::new(module_name));
                }
            }
        }

        imports
    }

    /// Analyze Python file for imports
    pub async fn analyze_file(&self, path: &Path) -> BlastResult<HashSet<String>> {
        let content = tokio::fs::read_to_string(path)
            .await
            .map_err(HotReloadError::from)?;

        let mut imports = HashSet::new();
        let mut in_multiline = false;
        let mut multiline_buffer = String::new();

        // Process the file line by line
        for line in content.lines() {
            let line = line.trim();

            // Skip comments and empty lines
            if line.starts_with('#') || line.is_empty() {
                continue;
            }

            // Handle multiline imports
            if in_multiline {
                multiline_buffer.push_str(line);
                if line.contains(')') {
                    // End of multiline import
                    in_multiline = false;
                    for import in Self::parse_imports_from_line(line) {
                        imports.insert(import.get_package_name());
                    }
                    multiline_buffer.clear();
                }
                continue;
            }

            if line.contains('(') && !line.contains(')') {
                // Start of multiline import
                in_multiline = true;
                multiline_buffer = line.to_string();
                continue;
            }

            // Process single-line imports
            for import in Self::parse_imports_from_line(line) {
                imports.insert(import.get_package_name());
            }
        }

        Ok(imports)
    }

    /// Create new hot reload manager
    pub async fn new() -> BlastResult<Self> {
        let environments = Arc::new(Mutex::new(HashMap::new()));
        let sync_manager = Arc::new(Mutex::new(SyncManager::new()));

        // Create file system watcher with environment reference
        let env_ref = Arc::clone(&environments);
        let sync_ref = Arc::clone(&sync_manager);
        let watcher = notify::recommended_watcher(move |res: Result<Event, _>| {
            if let Ok(event) = res {
                debug!("File system event detected: {:?}", event);
                if let EventKind::Create(_) | EventKind::Modify(_) = event.kind {
                    if let Some(path) = event.paths.first() {
                        if path.extension().map_or(false, |ext| ext == "py") {
                            let env_clone = env_ref.clone();
                            let sync_clone = sync_ref.clone();
                            let path_clone = path.to_path_buf();
                            tokio::spawn(async move {
                                if let Err(e) = Self::handle_python_file_change(&env_clone, &sync_clone, &path_clone).await {
                                    warn!("Failed to handle Python file change: {}", e);
                                }
                            });
                        }
                    }
                }
            }
        }).map_err(HotReloadError::from)?;

        Ok(Self {
            environments,
            watcher: Arc::new(Mutex::new(watcher)),
            sync_manager,
        })
    }

    /// Handle Python file changes
    async fn handle_python_file_change(
        environments: &Arc<Mutex<HashMap<String, EnvironmentContext>>>,
        sync_manager: &Arc<Mutex<SyncManager>>,
        path: &Path,
    ) -> BlastResult<()> {
        let mut envs = environments.lock().await;
        
        // Find environment containing this file
        for context in envs.values_mut() {
            if path.starts_with(context.environment.path()) {
                // Check if we need to sync versions
                if context.last_sync.is_none() {
                    let sync_manager = Arc::clone(sync_manager);
                    let operation = sync_manager.lock().await.plan_sync(
                        &context.environment,
                        &context.environment,
                    ).await?;
                    
                    context.last_sync = Some(operation.id.clone());
                    
                    // Apply sync in background
                    let operation_id = operation.id.clone();
                    let mut env_clone = context.environment.clone();
                    tokio::spawn(async move {
                        if let Err(e) = sync_manager.lock().await.apply_sync(&operation_id, &mut env_clone).await {
                            warn!("Failed to apply sync operation: {}", e);
                        }
                    });
                }
                break;
            }
        }

        Ok(())
    }

    /// Register environment for hot reloading
    pub async fn register_environment(&self, env: PythonEnvironment) -> BlastResult<()> {
        let mut environments = self.environments.lock().await;
        let env_name = env.name().unwrap_or("unnamed").to_string();
        
        // Create context
        let context = EnvironmentContext {
            environment: env.clone(),
            package_versions: HashMap::new(),
            last_sync: None,
        };

        // Add to active environments
        environments.insert(env_name.clone(), context);

        // Start watching environment path
        self.watcher.lock().await.watch(
            env.path(),
            RecursiveMode::Recursive,
        ).map_err(HotReloadError::from)?;

        Ok(())
    }

    /// Handle package installation detection
    pub async fn handle_package_installed(
        &self,
        env_name: &str,
        package: Package,
    ) -> BlastResult<()> {
        let mut environments = self.environments.lock().await;
        let context = environments.get_mut(env_name)
            .ok_or_else(|| BlastError::environment("Environment not found"))?;

        // Update package version
        context.package_versions.insert(package.name().to_string(), package.version().clone());

        // Trigger version sync
        let sync_manager = Arc::clone(&self.sync_manager);
        let operation = sync_manager.lock().await.plan_sync(
            &context.environment,
            &context.environment,
        ).await?;

        context.last_sync = Some(operation.id.clone());

        // Apply sync in background
        let operation_id = operation.id.clone();
        let mut env_clone = context.environment.clone();
        tokio::spawn(async move {
            if let Err(e) = sync_manager.lock().await.apply_sync(&operation_id, &mut env_clone).await {
                warn!("Failed to apply sync operation: {}", e);
            }
        });

        Ok(())
    }

    /// Start monitoring for changes
    pub async fn start_monitoring(&self) -> BlastResult<()> {
        // Implementation is handled by the file system watcher
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_simple_import() {
        let imports = HotReloadManager::parse_imports_from_line("import numpy");
        assert_eq!(imports.len(), 1);
        assert_eq!(imports[0].module, "numpy");
        assert!(!imports[0].is_from);
    }

    #[test]
    fn test_parse_multiple_imports() {
        let imports = HotReloadManager::parse_imports_from_line("import numpy, pandas, tensorflow");
        assert_eq!(imports.len(), 3);
        assert_eq!(imports[0].module, "numpy");
        assert_eq!(imports[1].module, "pandas");
        assert_eq!(imports[2].module, "tensorflow");
    }

    #[test]
    fn test_parse_from_import() {
        let imports = HotReloadManager::parse_imports_from_line("from numpy import array, zeros");
        assert_eq!(imports.len(), 1);
        assert_eq!(imports[0].module, "array");
        assert!(imports[0].is_from);
        assert_eq!(imports[0].names, vec!["array", "zeros"]);
        assert_eq!(imports[0].from_path, Some("numpy".to_string()));
    }

    #[test]
    fn test_parse_import_with_alias() {
        let imports = HotReloadManager::parse_imports_from_line("import numpy as np");
        assert_eq!(imports.len(), 1);
        assert_eq!(imports[0].module, "numpy");
    }

    #[test]
    fn test_parse_nested_import() {
        let imports = HotReloadManager::parse_imports_from_line("from tensorflow.keras import layers");
        assert_eq!(imports.len(), 1);
        assert_eq!(imports[0].get_package_name(), "tensorflow");
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-core/src/state.rs

```rs
use std::collections::{HashMap, HashSet};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use tracing::info;
use uuid::Uuid;
use std::time::Duration;

use crate::{
    error::{BlastError, BlastResult},
    package::Package,
    version::{Version, VersionConstraint},
    version_history::VersionHistory,
    python::{PythonEnvironment, PythonVersion},
    sync::IssueSeverity,
    metadata::PackageMetadata,
};

/// Environment state at a point in time
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EnvironmentState {
    /// State ID
    pub id: String,
    /// Environment name
    pub name: String,
    /// Python version
    /// 
    /// 
    pub python_version: PythonVersion,
    /// Installed packages with their versions
    pub packages: HashMap<String, Version>,
    /// Package version histories
    pub version_histories: HashMap<String, VersionHistory>,
    /// Environment variables
    pub env_vars: HashMap<String, String>,
    /// State creation timestamp
    pub created_at: DateTime<Utc>,
    /// State metadata
    pub metadata: StateMetadata,
    /// Verification status
    pub verification: Option<StateVerification>,
    active: bool,
}

/// Metadata for environment state
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StateMetadata {
    /// State description
    pub description: Option<String>,
    /// State tags
    pub tags: HashSet<String>,
    /// Custom metadata
    pub custom: HashMap<String, String>,
}

/// State verification result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StateVerification {
    /// Whether the state is verified
    pub is_verified: bool,
    /// Verification timestamp
    pub verified_at: Option<DateTime<Utc>>,
    /// Verification issues found
    pub issues: Vec<StateIssue>,
    /// Verification metrics
    pub metrics: Option<VerificationMetrics>,
}

/// State verification issue
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StateIssue {
    /// Description of the issue
    pub description: String,
    /// Severity of the issue
    pub severity: IssueSeverity,
    /// Context of the issue
    pub context: Option<String>,
    /// Recommendation for the issue
    pub recommendation: Option<String>,
}

/// Verification metrics
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VerificationMetrics {
    /// Duration of the verification
    pub duration: Duration,
    /// Number of packages checked
    pub packages_checked: usize,
    /// Number of dependencies checked
    pub dependencies_checked: usize,
}

/// Difference between two environment states
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StateDiff {
    /// Added packages
    pub added_packages: HashMap<String, Version>,
    /// Removed packages
    pub removed_packages: HashMap<String, Version>,
    /// Updated packages
    pub updated_packages: HashMap<String, (Version, Version)>,
    /// Added environment variables
    pub added_env_vars: HashMap<String, String>,
    /// Removed environment variables
    pub removed_env_vars: HashSet<String>,
    /// Changed environment variables
    pub changed_env_vars: HashMap<String, (String, String)>,
    /// Python version change
    pub python_version_change: Option<(PythonVersion, PythonVersion)>,
}

// Helper function to create package metadata from dependencies
fn create_package_metadata(
    name: String,
    version: String,
    dependencies: HashMap<String, VersionConstraint>,
    python_version: VersionConstraint,
) -> PackageMetadata {
    PackageMetadata::new(
        name,
        version,
        dependencies,
        python_version,
    )
}

impl EnvironmentState {
    /// Create a new environment state
    pub fn new(
        name: String,
        python_version: PythonVersion,
        packages: HashMap<String, Version>,
        env_vars: HashMap<String, String>,
    ) -> Self {
        Self {
            id: Uuid::new_v4().to_string(),
            name,
            python_version,
            packages,
            version_histories: HashMap::new(),
            env_vars,
            created_at: Utc::now(),
            metadata: StateMetadata {
                description: None,
                tags: HashSet::new(),
                custom: HashMap::new(),
            },
            verification: None,
            active: false,
        }
    }

    /// Create a new environment state from a Python environment
    pub fn from_environment(env: &PythonEnvironment) -> BlastResult<Self> {
        let packages = env.get_packages()?
            .into_iter()
            .map(|p| (p.name().to_string(), p.version().clone()))
            .collect();

        Ok(Self::new(
            env.name().unwrap_or("unnamed").to_string(),
            env.python_version().clone(),
            packages,
            HashMap::new(), // Environment variables will be added when supported
        ))
    }

    /// Add package to state
    pub fn add_package(&mut self, package: &Package) {
        self.packages.insert(
            package.name().to_string(),
            package.version().clone(),
        );
    }

    /// Remove package from state
    pub fn remove_package(&mut self, package: &Package) {
        self.packages.remove(package.name());
    }

    /// Add version history
    pub fn add_version_history(&mut self, name: String, history: VersionHistory) {
        self.version_histories.insert(name, history);
    }

    /// Verify state
    pub fn verify(&mut self) -> BlastResult<StateVerification> {
        let start_time = std::time::Instant::now();
        let mut issues = Vec::new();
        let mut metrics = VerificationMetrics {
            duration: Duration::from_secs(0),
            packages_checked: 0,
            dependencies_checked: 0,
        };

        // Verify packages
        for (name, version) in &self.packages {
            metrics.packages_checked += 1;

            // Check version history
            if let Some(history) = self.version_histories.get(name) {
                if let Some(current) = &history.current_version {
                    if current != version {
                        issues.push(StateIssue {
                            description: format!("Version mismatch for package {}", name),
                            severity: IssueSeverity::Critical,
                            context: Some(format!("Expected {}, got {}", current, version)),
                            recommendation: None,
                        });
                    }
                }
            }
        }

        // Verify environment variables
        metrics.dependencies_checked = self.env_vars.len();
        
        // Calculate metrics
        metrics.duration = start_time.elapsed();

        let verification = StateVerification {
            is_verified: issues.is_empty(),
            verified_at: Some(Utc::now()),
            issues,
            metrics: Some(metrics),
        };

        self.verification = Some(verification.clone());
        Ok(verification)
    }

    /// Compare with another state
    pub fn diff(&self, other: &EnvironmentState) -> StateDiff {
        let mut diff = StateDiff {
            added_packages: HashMap::new(),
            removed_packages: HashMap::new(),
            updated_packages: HashMap::new(),
            added_env_vars: HashMap::new(),
            removed_env_vars: HashSet::new(),
            changed_env_vars: HashMap::new(),
            python_version_change: None,
        };

        // Check Python version change
        if self.python_version != other.python_version {
            diff.python_version_change = Some((
                self.python_version.clone(),
                other.python_version.clone(),
            ));
        }

        // Check package changes
        for (name, version) in &self.packages {
            match other.packages.get(name) {
                Some(other_version) if other_version != version => {
                    diff.updated_packages.insert(
                        name.clone(),
                        (version.clone(), other_version.clone()),
                    );
                }
                None => {
                    diff.removed_packages.insert(name.clone(), version.clone());
                }
                _ => {}
            }
        }

        for (name, version) in &other.packages {
            if !self.packages.contains_key(name) {
                diff.added_packages.insert(name.clone(), version.clone());
            }
        }

        // Check environment variable changes
        for (name, value) in &self.env_vars {
            match other.env_vars.get(name) {
                Some(other_value) if other_value != value => {
                    diff.changed_env_vars.insert(
                        name.clone(),
                        (value.clone(), other_value.clone()),
                    );
                }
                None => {
                    diff.removed_env_vars.insert(name.clone());
                }
                _ => {}
            }
        }

        for (name, value) in &other.env_vars {
            if !self.env_vars.contains_key(name) {
                diff.added_env_vars.insert(name.clone(), value.clone());
            }
        }

        diff
    }

    /// Create a checkpoint of the current state
    pub fn create_checkpoint(&self) -> BlastResult<StateCheckpoint> {
        Ok(StateCheckpoint {
            state: self.clone(),
            created_at: Utc::now(),
            metadata: CheckpointMetadata {
                description: None,
                tags: HashSet::new(),
                custom: HashMap::new(),
            },
        })
    }

    /// Restore from a checkpoint
    pub fn restore_from_checkpoint(&mut self, checkpoint: StateCheckpoint) -> BlastResult<()> {
        // Verify checkpoint compatibility
        if checkpoint.state.python_version != self.python_version {
            return Err(BlastError::environment(format!(
                "Python version mismatch: checkpoint uses {}, current environment uses {}",
                checkpoint.state.python_version,
                self.python_version,
            )));
        }

        // Apply checkpoint state
        self.packages = checkpoint.state.packages;
        self.version_histories = checkpoint.state.version_histories;
        self.env_vars = checkpoint.state.env_vars;
        self.metadata = checkpoint.state.metadata;

        info!("Restored environment state from checkpoint created at {}", checkpoint.created_at);
        Ok(())
    }

    /// Verify a checkpoint's state
    pub fn verify_checkpoint_state(&self, state: &EnvironmentState) -> BlastResult<StateVerification> {
        let mut verification = StateVerification::default();

        // Verify Python version
        if !state.python_version.is_compatible_with(&PythonVersion::new(3, 6, None)) {
            verification.add_issue(StateIssue {
                description: "Unsupported Python version".to_string(),
                severity: IssueSeverity::Critical,
                context: None,
                recommendation: None,
            });
        }

        // Create a map of packages for easier access
        let packages: HashMap<String, Package> = state.packages.iter()
            .map(|(name, version)| -> BlastResult<(String, Package)> {
                let package = Package::new(
                    name.clone(),
                    version.to_string(),
                    create_package_metadata(
                        name.clone(),
                        version.to_string(),
                        HashMap::new(),
                        VersionConstraint::any(),
                    ),
                    VersionConstraint::any(),
                )?;
                Ok((name.clone(), package))
            })
            .collect::<BlastResult<HashMap<_, _>>>()?;

        // Verify package dependencies
        for (name, package) in &packages {
            // Check if all dependencies are satisfied
            let deps = package.all_dependencies(&[]);
            for (dep_name, constraint) in deps {
                if let Some(dep_version) = state.packages.get(&dep_name) {
                    if !constraint.matches(dep_version) {
                        verification.add_issue(StateIssue {
                            description: format!(
                                "Package {} dependency {} {} not satisfied (found {})",
                                name,
                                dep_name,
                                constraint,
                                dep_version
                            ),
                            severity: IssueSeverity::Critical,
                            context: None,
                            recommendation: None,
                        });
                    }
                } else {
                    verification.add_issue(StateIssue {
                        description: format!(
                            "Package {} dependency {} not found",
                            name,
                            dep_name
                        ),
                        severity: IssueSeverity::Critical,
                        context: None,
                        recommendation: None,
                    });
                }
            }

            // Check Python version compatibility
            let python_version_str = state.python_version.to_string();
            let python_version = Version::parse(&python_version_str).unwrap_or_else(|_| Version::parse("3.6.0").unwrap());
            
            if !package.metadata().python_version.matches(&python_version) {
                verification.add_issue(StateIssue {
                    severity: IssueSeverity::Warning,
                    description: format!(
                        "Package {} requires Python version {} but environment has {}",
                        package.name(),
                        package.metadata().python_version,
                        state.python_version
                    ),
                    context: None,
                    recommendation: Some("Consider upgrading Python version or using a different package version".to_string()),
                });
            }
        }

        // Verify version histories
        for (name, history) in &self.version_histories {
            if let Some(version) = state.packages.get(name) {
                if !history.has_version(version) {
                    verification.add_issue(StateIssue {
                        description: format!(
                            "Package {} version {} not found in version history",
                            name,
                            version
                        ),
                        severity: IssueSeverity::Warning,
                        context: None,
                        recommendation: None,
                    });
                }
            }
        }

        Ok(verification)
    }

    pub fn is_active(&self) -> bool {
        self.active
    }

    pub fn set_active(&mut self, active: bool) {
        self.active = active;
    }
}

/// Checkpoint for environment state
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StateCheckpoint {
    /// Captured state
    pub state: EnvironmentState,
    /// Checkpoint creation timestamp
    pub created_at: DateTime<Utc>,
    /// Checkpoint metadata
    pub metadata: CheckpointMetadata,
}

/// Metadata for state checkpoints
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckpointMetadata {
    /// Checkpoint description
    pub description: Option<String>,
    /// Checkpoint tags
    pub tags: HashSet<String>,
    /// Custom metadata
    pub custom: HashMap<String, String>,
}

impl Default for StateVerification {
    fn default() -> Self {
        Self {
            is_verified: true,
            verified_at: None,
            issues: Vec::new(),
            metrics: None,
        }
    }
}

impl StateVerification {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn add_issue(&mut self, issue: StateIssue) {
        if issue.severity == IssueSeverity::Critical {
            self.is_verified = false;
        }
        self.issues.push(issue);
    }
}

impl StateIssue {
    pub fn new(description: String, severity: IssueSeverity) -> Self {
        Self {
            description,
            severity,
            context: None,
            recommendation: None,
        }
    }

    pub fn with_context(description: String, severity: IssueSeverity, context: String) -> Self {
        Self {
            description,
            severity,
            context: Some(context),
            recommendation: None,
        }
    }
}

impl EnvironmentState {
    pub fn name(&self) -> &str {
        &self.name
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-core/src/resolution.rs

```rs
use serde::{Deserialize, Serialize};

/// Metrics from dependency resolution
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ResolutionMetrics {
    /// Number of packages resolved
    pub package_count: usize,
    /// Time taken for resolution (ms)
    pub resolution_time_ms: u64,
    /// Number of network requests
    pub network_requests: usize,
    /// Number of cache hits
    pub cache_hits: usize,
    /// Number of version conflicts resolved
    pub conflicts_resolved: usize,
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-core/src/shell_scripts.rs

```rs
use std::path::PathBuf;

/// Activation scripts for different shell types
#[derive(Debug, Clone)]
pub struct ActivationScripts {
    pub bash: String,
    pub fish: String,
    pub powershell: String,
}

impl ActivationScripts {
    pub fn generate(env_path: &PathBuf, env_name: &str) -> Self {
        Self {
            bash: Self::bash_zsh(env_path, env_name),
            fish: Self::fish(env_path, env_name),
            powershell: Self::powershell(env_path, env_name),
        }
    }

    fn bash_zsh(env_path: &PathBuf, env_name: &str) -> String {
        format!(
            r#"#!/bin/bash
# Blast environment activation script for bash/zsh

deactivate () {{
    # reset old environment variables
    if [ -n "$_OLD_BLAST_PATH" ] ; then
        PATH="$_OLD_BLAST_PATH"
        export PATH
        unset _OLD_BLAST_PATH
    fi

    if [ -n "$_OLD_BLAST_PYTHONPATH" ] ; then
        PYTHONPATH="$_OLD_BLAST_PYTHONPATH"
        export PYTHONPATH
        unset _OLD_BLAST_PYTHONPATH
    fi

    if [ -n "$_OLD_BLAST_PS1" ] ; then
        PS1="$_OLD_BLAST_PS1"
        export PS1
        unset _OLD_BLAST_PS1
    fi

    if [ -n "$BASH" -o -n "$ZSH_VERSION" ] ; then
        hash -r 2>/dev/null
    fi

    if [ ! "$1" = "nondestructive" ] ; then
        # Self destruct!
        unset -f deactivate
    fi

    # Unset environment variables
    unset BLAST_ENV_NAME
    unset BLAST_ENV_PATH
    unset BLAST_SOCKET_PATH
}}

# Save the old path
_OLD_BLAST_PATH="$PATH"
PATH="{}/bin:$PATH"
export PATH

# Save the old PYTHONPATH
_OLD_BLAST_PYTHONPATH="$PYTHONPATH"
PYTHONPATH="{}/lib/python/site-packages:$PYTHONPATH"
export PYTHONPATH

# Save the old PS1
_OLD_BLAST_PS1="${{PS1-}}"
PS1="(blast:{}) $PS1"
export PS1

# Set environment variables
export BLAST_ENV_NAME="{}"
export BLAST_ENV_PATH="{}"
export BLAST_SOCKET_PATH="/tmp/blast_{}.sock"

# Make sure to unalias deactivate if it exists
if [ "$(type -t deactivate)" = "alias" ] ; then
    unalias deactivate
fi

if [ -n "$BASH" -o -n "$ZSH_VERSION" ] ; then
    hash -r 2>/dev/null
fi"#,
            env_path.display(),
            env_path.display(),
            env_name,
            env_name,
            env_path.display(),
            env_name
        )
    }

    fn fish(env_path: &PathBuf, env_name: &str) -> String {
        format!(
            r#"# Blast environment activation script for fish

function deactivate  -d "Exit blast virtual environment and return to normal shell environment"
    # reset old environment variables
    if test -n "$_OLD_BLAST_PATH"
        set -gx PATH $_OLD_BLAST_PATH
        set -e _OLD_BLAST_PATH
    end

    if test -n "$_OLD_BLAST_PYTHONPATH"
        set -gx PYTHONPATH $_OLD_BLAST_PYTHONPATH
        set -e _OLD_BLAST_PYTHONPATH
    end

    if test -n "$_OLD_FISH_PROMPT_OVERRIDE"
        functions -e fish_prompt
        set -e _OLD_FISH_PROMPT_OVERRIDE
        functions -c _old_fish_prompt fish_prompt
        functions -e _old_fish_prompt
    end

    set -e BLAST_ENV_NAME
    set -e BLAST_ENV_PATH
    set -e BLAST_SOCKET_PATH

    if test "$argv[1]" != "nondestructive"
        functions -e deactivate
    end
end

# Save the old path
set -gx _OLD_BLAST_PATH $PATH
set -gx PATH "{}/bin" $PATH

# Save the old PYTHONPATH
set -gx _OLD_BLAST_PYTHONPATH $PYTHONPATH
set -gx PYTHONPATH "{}/lib/python/site-packages" $PYTHONPATH

# Save the old prompt
functions -c fish_prompt _old_fish_prompt
set -gx _OLD_FISH_PROMPT_OVERRIDE "$BLAST_ENV_PATH"

function fish_prompt
    echo -n "(blast:{}) "
    _old_fish_prompt
end

# Set environment variables
set -gx BLAST_ENV_NAME "{}"
set -gx BLAST_ENV_PATH "{}"
set -gx BLAST_SOCKET_PATH "/tmp/blast_{}.sock""#,
            env_path.display(),
            env_path.display(),
            env_name,
            env_name,
            env_path.display(),
            env_name
        )
    }

    fn powershell(env_path: &PathBuf, env_name: &str) -> String {
        format!(
            r#"# Blast environment activation script for PowerShell

function global:deactivate ([switch]$NonDestructive) {{
    if (Test-Path variable:_OLD_BLAST_PATH) {{
        $env:PATH = $variable:_OLD_BLAST_PATH
        Remove-Variable "_OLD_BLAST_PATH" -Scope global
    }}

    if (Test-Path variable:_OLD_BLAST_PYTHONPATH) {{
        $env:PYTHONPATH = $variable:_OLD_BLAST_PYTHONPATH
        Remove-Variable "_OLD_BLAST_PYTHONPATH" -Scope global
    }}

    if (Test-Path variable:_OLD_BLAST_PROMPT) {{
        $function:prompt = $variable:_OLD_BLAST_PROMPT
        Remove-Variable "_OLD_BLAST_PROMPT" -Scope global
    }}

    if (Test-Path env:BLAST_ENV_NAME) {{
        Remove-Item env:BLAST_ENV_NAME
    }}
    if (Test-Path env:BLAST_ENV_PATH) {{
        Remove-Item env:BLAST_ENV_PATH
    }}
    if (Test-Path env:BLAST_SOCKET_PATH) {{
        Remove-Item env:BLAST_SOCKET_PATH
    }}

    if (!$NonDestructive) {{
        # Self destruct!
        Remove-Item function:deactivate
    }}
}}

# Save the old path
$global:_OLD_BLAST_PATH = $env:PATH
$env:PATH = "{}\bin;" + $env:PATH

# Save the old PYTHONPATH
$global:_OLD_BLAST_PYTHONPATH = $env:PYTHONPATH
$env:PYTHONPATH = "{}\lib\python\site-packages;" + $env:PYTHONPATH

# Save the old prompt
$global:_OLD_BLAST_PROMPT = $function:prompt
$function:prompt = {{
    Write-Host "(blast:{}) " -NoNewline
    & $global:_OLD_BLAST_PROMPT
}}

# Set environment variables
$env:BLAST_ENV_NAME = "{}"
$env:BLAST_ENV_PATH = "{}"
$env:BLAST_SOCKET_PATH = "/tmp/blast_{}.sock""#,
            env_path.display(),
            env_path.display(),
            env_name,
            env_name,
            env_path.display(),
            env_name
        )
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-core/src/debug.rs

```rs
use std::collections::HashMap;
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};
use petgraph::graph::{DiGraph, NodeIndex};
use petgraph::dot::{Dot, Config};

/// Debug information collector
#[derive(Debug)]
pub struct DebugCollector {
    /// System information
    system_info: SystemInfo,
    /// Operation history
    history: Vec<OperationRecord>,
    /// Environment state
    environment_state: Option<EnvironmentState>,
    /// Dependency graph
    dependency_graph: Option<DependencyGraph>,
}

/// System information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SystemInfo {
    /// Operating system
    pub os: String,
    /// CPU architecture
    pub arch: String,
    /// Python version
    pub python_version: String,
    /// Available memory
    pub memory: u64,
    /// Environment variables
    pub env_vars: HashMap<String, String>,
    /// Blast version
    pub blast_version: String,
}

/// Operation record
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OperationRecord {
    /// Operation ID
    pub id: uuid::Uuid,
    /// Operation type
    pub operation_type: String,
    /// Timestamp
    pub timestamp: DateTime<Utc>,
    /// Duration
    pub duration: std::time::Duration,
    /// Status
    pub status: OperationStatus,
    /// Error if any
    pub error: Option<String>,
    /// Stack trace if error occurred
    pub stack_trace: Option<String>,
}

/// Operation status
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OperationStatus {
    /// Operation succeeded
    Success,
    /// Operation failed
    Failed,
    /// Operation was cancelled
    Cancelled,
    /// Operation is in progress
    InProgress,
}

/// Environment state
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EnvironmentState {
    /// Installed packages
    pub packages: Vec<PackageInfo>,
    /// Python version
    pub python_version: String,
    /// Environment variables
    pub env_vars: HashMap<String, String>,
    /// Virtual environment path
    pub venv_path: std::path::PathBuf,
    /// Last modified
    pub last_modified: DateTime<Utc>,
}

/// Package information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PackageInfo {
    /// Package name
    pub name: String,
    /// Package version
    pub version: String,
    /// Installation time
    pub installed_at: DateTime<Utc>,
    /// Dependencies
    pub dependencies: Vec<String>,
    /// Whether it's a direct dependency
    pub is_direct: bool,
}

/// Dependency graph representation
#[derive(Debug, Clone)]
pub struct DependencyGraph {
    /// Graph structure
    graph: DiGraph<String, ()>,
    /// Node mapping
    node_map: HashMap<String, NodeIndex>,
}

impl DebugCollector {
    /// Create a new debug collector
    pub fn new() -> Self {
        Self {
            system_info: SystemInfo::collect(),
            history: Vec::new(),
            environment_state: None,
            dependency_graph: None,
        }
    }

    /// Record an operation
    pub fn record_operation(&mut self, operation: OperationRecord) {
        self.history.push(operation);
    }

    /// Capture current environment state
    pub fn capture_environment(&mut self, state: EnvironmentState) {
        self.environment_state = Some(state);
        self.update_dependency_graph();
    }

    /// Get stack trace for current thread
    pub fn get_stack_trace() -> String {
        // Simple location tracking
        let location = std::panic::Location::caller();
        format!("Error occurred at {}:{}", location.file(), location.line())
    }

    /// Generate debug report
    pub fn generate_report(&self) -> DebugReport {
        DebugReport {
            timestamp: Utc::now(),
            system_info: self.system_info.clone(),
            operation_history: self.history.clone(),
            environment_state: self.environment_state.clone(),
            dependency_graph: self.dependency_graph.as_ref().map(|g| g.to_dot()),
        }
    }

    /// Update dependency graph from environment state
    fn update_dependency_graph(&mut self) {
        if let Some(state) = &self.environment_state {
            let mut graph = DependencyGraph::new();
            
            // Add all packages as nodes
            for package in &state.packages {
                graph.add_node(&package.name);
                
                // Add dependencies as edges
                for dep in &package.dependencies {
                    graph.add_dependency(&package.name, dep);
                }
            }

            self.dependency_graph = Some(graph);
        }
    }
}

impl SystemInfo {
    /// Collect system information
    fn collect() -> Self {
        Self {
            os: std::env::consts::OS.to_string(),
            arch: std::env::consts::ARCH.to_string(),
            python_version: String::new(), // TODO: Implement Python version detection
            memory: 0, // TODO: Implement memory detection
            env_vars: std::env::vars().collect(),
            blast_version: env!("CARGO_PKG_VERSION").to_string(),
        }
    }
}

impl DependencyGraph {
    /// Create a new dependency graph
    fn new() -> Self {
        Self {
            graph: DiGraph::new(),
            node_map: HashMap::new(),
        }
    }

    /// Add a node to the graph
    fn add_node(&mut self, package: &str) -> NodeIndex {
        if let Some(&node) = self.node_map.get(package) {
            node
        } else {
            let node = self.graph.add_node(package.to_string());
            self.node_map.insert(package.to_string(), node);
            node
        }
    }

    /// Add a dependency edge
    fn add_dependency(&mut self, from: &str, to: &str) {
        let from_node = self.add_node(from);
        let to_node = self.add_node(to);
        self.graph.add_edge(from_node, to_node, ());
    }

    /// Convert graph to DOT format
    fn to_dot(&self) -> String {
        format!("{:?}", Dot::with_config(&self.graph, &[Config::EdgeNoLabel]))
    }
}

/// Debug report containing all collected information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DebugReport {
    /// Timestamp of the report
    pub timestamp: DateTime<Utc>,
    /// System information
    pub system_info: SystemInfo,
    /// Operation history
    pub operation_history: Vec<OperationRecord>,
    /// Environment state
    pub environment_state: Option<EnvironmentState>,
    /// Dependency graph in DOT format
    pub dependency_graph: Option<String>,
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-core/src/sync/types.rs

```rs
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use crate::package::Package;
use crate::python::PythonVersion;
use crate::version::Version;

/// Change to be applied during sync
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SyncChange {
    /// Install a new package
    InstallPackage(Package),
    /// Remove a package
    RemovePackage(Package),
    /// Update package version
    UpdatePackage {
        package: Package,
        from_version: Version,
        to_version: Version,
    },
    /// Update environment variables
    UpdateEnvVars(HashMap<String, String>),
    /// Update Python version
    UpdatePythonVersion {
        from_version: PythonVersion,
        to_version: PythonVersion,
    },
}

/// Strategy for merging environment changes
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MergeStrategy {
    /// Keep all changes from source
    KeepSource,
    /// Keep all changes from target
    KeepTarget,
    /// Prefer source changes but allow manual resolution
    PreferSource,
    /// Interactive merge with manual conflict resolution
    Interactive,
}

/// Cache size limits for sync operations
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CacheSizeLimits {
    /// Maximum number of packages to cache
    pub max_packages: usize,
    /// Maximum size of package cache in bytes
    pub max_size: u64,
    /// Maximum age of cached items in seconds
    pub max_age: u64,
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-core/src/sync/manager.rs

```rs
use std::collections::HashMap;
use chrono::Utc;
use uuid::Uuid;

use crate::error::{BlastError, BlastResult};
use crate::python::PythonEnvironment;
use crate::package::Package;
use crate::version::Version;

use super::operations::{SyncOperation, SyncStatus};
use super::types::SyncChange;
use super::conflicts::{SyncConflict, ConflictType, ConflictResolution};
use super::validation::{SyncValidation, ValidationIssue, IssueSeverity, PerformanceImpact};

/// Manager for synchronization between environments
pub struct SyncManager {
    /// Active sync operations
    operations: HashMap<String, SyncOperation>,
    /// Version stability scores
    stability_scores: HashMap<String, StabilityScore>,
}

#[derive(Debug, Clone)]
struct StabilityScore {
    /// Version scores (higher is more stable)
    version_scores: HashMap<Version, f64>,
}

impl SyncManager {
    /// Create new sync manager
    pub fn new() -> Self {
        Self {
            operations: HashMap::new(),
            stability_scores: HashMap::new(),
        }
    }

    /// Plan sync operation between environments
    pub async fn plan_sync(
        &mut self,
        source: &PythonEnvironment,
        target: &PythonEnvironment,
    ) -> BlastResult<SyncOperation> {
        // Analyze differences and conflicts
        let (changes, conflicts) = self.analyze_diff(source, target).await?;

        // Validate changes and calculate performance impact
        let validation = self.validate_changes(&changes, source, target).await?;
        
        // Create sync operation
        let operation = SyncOperation {
            id: Uuid::new_v4().to_string(),
            source: source.name().unwrap_or("source").to_string(),
            target: target.name().unwrap_or("target").to_string(),
            started_at: Utc::now(),
            completed_at: None,
            status: SyncStatus::Planning,
            changes,
            conflicts,
            validation,
        };

        // Store operation
        self.operations.insert(operation.id.clone(), operation.clone());

        Ok(operation)
    }

    /// Apply sync operation
    pub async fn apply_sync(
        &mut self,
        operation_id: &str,
        target: &mut PythonEnvironment,
    ) -> BlastResult<()> {
        let operation = self.operations.get_mut(operation_id)
            .ok_or_else(|| BlastError::sync("Operation not found"))?;

        operation.status = SyncStatus::InProgress;

        for change in &operation.changes {
            match change {
                SyncChange::UpdatePackage { package, from_version: _, to_version } => {
                    // Create new package with updated version
                    let new_package = Package::new(
                        package.name().to_string(),
                        to_version.to_string(),
                        package.metadata().clone(),
                        package.metadata().python_version.clone(),
                    )?;
                    target.remove_package(&package);
                    target.add_package(new_package);
                },
                SyncChange::InstallPackage(package) => {
                    target.add_package(package.clone());
                }
                SyncChange::RemovePackage(package) => {
                    target.remove_package(&package);
                }
                SyncChange::UpdateEnvVars(vars) => {
                    for (key, value) in vars {
                        target.update_env_var(key, value);
                    }
                }
                SyncChange::UpdatePythonVersion { to_version, .. } => {
                    target.update_python_version(&to_version.to_string())?;
                }
            }
        }

        operation.status = SyncStatus::Completed;
        operation.completed_at = Some(Utc::now());

        Ok(())
    }

    /// Analyze differences between environments
    async fn analyze_diff(
        &self,
        source: &PythonEnvironment,
        target: &PythonEnvironment,
    ) -> BlastResult<(Vec<SyncChange>, Vec<SyncConflict>)> {
        let mut changes = Vec::new();
        let mut conflicts = Vec::new();

        // Compare Python versions
        let source_python = source.python_version();
        let target_python = target.python_version();
        if source_python != target_python {
            changes.push(SyncChange::UpdatePythonVersion {
                from_version: target_python.clone(),
                to_version: source_python.clone(),
            });
        }

        // Compare packages
        let source_packages = source.get_packages()?;
        let target_packages = target.get_packages()?;

        for source_pkg in &source_packages {
            if let Some(target_pkg) = target_packages.iter().find(|p| p.name() == source_pkg.name()) {
                if source_pkg.version() != target_pkg.version() {
                    // Version mismatch - check compatibility
                    if !self.is_compatible(source_pkg, target_pkg) {
                        conflicts.push(SyncConflict {
                            conflict_type: ConflictType::PackageVersionConflict,
                            description: format!(
                                "Package {} version conflict: {} vs {}",
                                source_pkg.name(),
                                source_pkg.version(),
                                target_pkg.version()
                            ),
                            resolutions: vec![
                                ConflictResolution::UseSource,
                                ConflictResolution::UseTarget,
                                ConflictResolution::Skip,
                            ],
                            selected_resolution: None,
                        });
                    } else {
                        changes.push(SyncChange::UpdatePackage {
                            package: (*source_pkg).clone(),
                            from_version: target_pkg.version().clone(),
                            to_version: source_pkg.version().clone(),
                        });
                    }
                }
            } else {
                // Package not in target - add it
                changes.push(SyncChange::InstallPackage((*source_pkg).clone()));
            }
        }

        // Check for packages to remove
        for target_pkg in &target_packages {
            if !source_packages.iter().any(|p| p.name() == target_pkg.name()) {
                changes.push(SyncChange::RemovePackage((*target_pkg).clone()));
            }
        }

        Ok((changes, conflicts))
    }

    /// Check if packages are compatible
    fn is_compatible(&self, pkg1: &Package, pkg2: &Package) -> bool {
        // Check version constraints
        if !pkg1.metadata().python_version.matches(&pkg2.version()) {
            return false;
        }

        // Check dependencies
        let deps1 = pkg1.all_dependencies(&[]);
        let deps2 = pkg2.all_dependencies(&[]);

        for (name, constraint) in &deps1 {
            if let Some(other_constraint) = deps2.get(name) {
                if let Ok(version) = Version::parse(&other_constraint.to_string()) {
                    if !constraint.matches(&version) {
                        return false;
                    }
                } else {
                    // If we can't parse the version, consider it incompatible
                    return false;
                }
            }
        }

        true
    }

    /// Validate changes
    async fn validate_changes(
        &self,
        changes: &[SyncChange],
        _source: &PythonEnvironment,
        target: &PythonEnvironment,
    ) -> BlastResult<SyncValidation> {
        let mut issues = Vec::new();
        let mut is_valid = true;

        // Validate each change
        for change in changes {
            match change {
                SyncChange::InstallPackage(package) => {
                    // Check Python compatibility
                    if !package.is_python_compatible(&target.python_version().to_string())? {
                        is_valid = false;
                        issues.push(ValidationIssue {
                            severity: IssueSeverity::Critical,
                            description: format!(
                                "Package {} is not compatible with Python {}",
                                package.name(),
                                target.python_version()
                            ),
                            recommendation: "Choose a different package version or update Python".to_string(),
                        });
                    }
                }
                SyncChange::UpdatePackage { package, from_version, to_version } => {
                    // Check version stability
                    let stability_score = self.get_version_stability(package.name(), to_version);
                    if stability_score < 0.3 {
                        issues.push(ValidationIssue {
                            severity: IssueSeverity::Warning,
                            description: format!(
                                "Package {} version {} has low stability score ({})",
                                package.name(),
                                to_version,
                                stability_score
                            ),
                            recommendation: "Consider using a more stable version".to_string(),
                        });
                    }

                    // Check for major version changes
                    if from_version.as_semver().major != to_version.as_semver().major {
                        issues.push(ValidationIssue {
                            severity: IssueSeverity::Warning,
                            description: format!(
                                "Major version change for package {} ({} -> {})",
                                package.name(),
                                from_version,
                                to_version
                            ),
                            recommendation: "Review breaking changes in changelog".to_string(),
                        });
                    }
                }
                _ => {}
            }
        }

        // Estimate performance impact
        let performance_impact = self.estimate_performance_impact(changes);

        Ok(SyncValidation {
            is_valid,
            issues,
            performance_impact,
        })
    }

    fn get_version_stability(&self, package: &str, version: &Version) -> f64 {
        self.stability_scores
            .get(package)
            .and_then(|score| score.version_scores.get(version))
            .copied()
            .unwrap_or(0.5)
    }

    fn estimate_performance_impact(&self, changes: &[SyncChange]) -> PerformanceImpact {
        let num_changes = changes.len();
        
        PerformanceImpact {
            estimated_duration: std::time::Duration::from_secs((num_changes * 10) as u64),
            required_space: (num_changes * 1024 * 1024) as u64,
            network_bandwidth: (num_changes * 512 * 1024) as u64,
            cpu_usage: 0.1 * num_changes as f32,
            memory_usage: (num_changes * 256 * 1024 * 1024) as u64,
        }
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-core/src/sync/mod.rs

```rs
pub mod manager;
pub mod operations;
pub mod validation;
pub mod conflicts;
pub mod types;

// Re-export main types
pub use manager::SyncManager;
pub use operations::{SyncOperation, SyncStatus, OperationStatus, UpgradeOperation};
pub use validation::{ValidationIssue, IssueSeverity, PerformanceImpact, SyncValidation};
pub use conflicts::{SyncConflict, ConflictType, ConflictResolution};
pub use types::{SyncChange, CacheSizeLimits, MergeStrategy}; 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-core/src/sync/validation.rs

```rs
use std::time::Duration;
use serde::{Deserialize, Serialize};

/// Validation of sync operation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SyncValidation {
    /// Whether the sync is valid
    pub is_valid: bool,
    /// List of validation issues
    pub issues: Vec<ValidationIssue>,
    /// Performance impact assessment
    pub performance_impact: PerformanceImpact,
}

/// Issue found during validation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValidationIssue {
    /// Severity of the issue
    pub severity: IssueSeverity,
    /// Description of the issue
    pub description: String,
    /// Recommended action
    pub recommendation: String,
}

/// Severity of validation issue
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum IssueSeverity {
    /// Critical issue that must be resolved
    Critical,
    /// Warning that should be reviewed
    Warning,
    /// Informational message
    Info,
}

/// Performance impact of sync operation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PerformanceImpact {
    /// Estimated time to complete sync
    #[serde(with = "duration_serde")]
    pub estimated_duration: Duration,
    /// Required disk space
    pub required_space: u64,
    /// Network bandwidth required
    pub network_bandwidth: u64,
    /// CPU usage estimate
    pub cpu_usage: f32,
    /// Memory usage estimate
    pub memory_usage: u64,
}

mod duration_serde {
    use serde::{Deserialize, Deserializer, Serializer};
    use std::time::Duration;

    pub fn serialize<S>(duration: &Duration, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_u64(duration.as_secs())
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Duration, D::Error>
    where
        D: Deserializer<'de>,
    {
        let secs = u64::deserialize(deserializer)?;
        Ok(Duration::from_secs(secs))
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-core/src/sync/original.rs

```rs
use std::collections::HashMap;
use chrono::{DateTime, Utc};

use serde::{Deserialize, Serialize};
use uuid::Uuid;
use std::time::{SystemTime, UNIX_EPOCH};

use crate::error::{BlastError, BlastResult};
use crate::package::Package;
use crate::python::{PythonEnvironment, PythonVersion};
use crate::state::{EnvironmentState, StateDiff};
use crate::metadata::PackageMetadata;
use crate::version::{Version, VersionConstraint};

/// Sync operation between environments
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SyncOperation {
    /// Operation ID
    pub id: String,
    /// Source environment
    pub source: String,
    /// Target environment
    pub target: String,
    /// Start timestamp
    pub started_at: DateTime<Utc>,
    /// Completion timestamp
    pub completed_at: Option<DateTime<Utc>>,
    /// Operation status
    pub status: SyncStatus,
    /// Package changes
    pub changes: Vec<SyncChange>,
    /// Conflicts that need resolution
    pub conflicts: Vec<SyncConflict>,
    /// Validation results
    pub validation: SyncValidation,
}

/// Status of sync operation
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum SyncStatus {
    /// Sync is being planned
    Planning,
    /// Sync is in progress
    InProgress,
    /// Sync completed successfully
    Completed,
    /// Sync failed
    Failed(String),
    /// Sync was cancelled
    Cancelled,
}

/// Change to be applied during sync
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SyncChange {
    /// Install a new package
    InstallPackage(Package),
    /// Remove a package
    RemovePackage(Package),
    /// Update package version
    UpdatePackage {
        package: Package,
        from_version: Version,
        to_version: Version,
    },
    /// Update environment variables
    UpdateEnvVars(HashMap<String, String>),
    /// Update Python version
    UpdatePythonVersion {
        from_version: PythonVersion,
        to_version: PythonVersion,
    },
}

/// Conflict during sync
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SyncConflict {
    /// Type of conflict
    pub conflict_type: ConflictType,
    /// Description of the conflict
    pub description: String,
    /// Possible resolutions
    pub resolutions: Vec<ConflictResolution>,
    /// Selected resolution
    pub selected_resolution: Option<ConflictResolution>,
}

/// Type of sync conflict
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum ConflictType {
    /// Version mismatch between environments
    VersionMismatch,
    /// Package exists in both environments with different versions
    PackageVersionConflict,
    /// Package dependencies are incompatible
    DependencyConflict,
    /// Environment variables conflict
    EnvVarConflict,
    /// Python version incompatibility
    PythonVersionConflict,
}

/// Resolution for a conflict
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ConflictResolution {
    /// Use source version
    UseSource,
    /// Use target version
    UseTarget,
    /// Use specific version
    UseVersion(Version),
    /// Skip this change
    Skip,
    /// Merge changes
    Merge,
}

/// Validation of sync operation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SyncValidation {
    /// Whether the sync is valid
    pub is_valid: bool,
    /// List of validation issues
    pub issues: Vec<ValidationIssue>,
    /// Performance impact assessment
    pub performance_impact: PerformanceImpact,
}

/// Issue found during validation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValidationIssue {
    /// Severity of the issue
    pub severity: IssueSeverity,
    /// Description of the issue
    pub description: String,
    /// Recommended action
    pub recommendation: String,
}

/// Severity of validation issue
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum IssueSeverity {
    /// Critical issue that must be resolved
    Critical,
    /// Warning that should be reviewed
    Warning,
    /// Informational message
    Info,
}

/// Performance impact of sync operation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PerformanceImpact {
    /// Estimated time to complete sync
    pub estimated_duration: std::time::Duration,
    /// Required disk space
    pub required_space: u64,
    /// Network bandwidth required
    pub network_bandwidth: u64,
    /// CPU usage estimate
    pub cpu_usage: f32,
    /// Memory usage estimate
    pub memory_usage: u64,
}

/// Manager for synchronization between environments
pub struct SyncManager {
    /// Active sync operations
    operations: HashMap<String, SyncOperation>,
    /// Version stability scores
    stability_scores: HashMap<String, StabilityScore>,
    /// Environment dependencies
    dependencies: HashMap<String, EnvironmentDeps>,
}

#[allow(dead_code)]  // Used for future stability tracking
struct StabilityScore {
    /// Package name
    package: String,
    /// Version scores (higher is more stable)
    version_scores: HashMap<Version, f64>,
    /// Usage count
    usage_count: u64,
    /// Last updated
    last_updated: DateTime<Utc>,
}

/// Environment dependencies
#[derive(Debug, Clone)]
#[allow(dead_code)]  // Fields are used in derived traits and future implementations
struct EnvironmentDeps {
    /// Environment name
    environment: String,
    /// Direct dependencies
    direct_deps: HashMap<String, String>, // Store versions as strings
    /// Transitive dependencies
    transitive_deps: HashMap<String, String>,
    /// Last sync timestamp
    last_sync: Option<DateTime<Utc>>,
}

impl EnvironmentDeps {
    fn new(environment: String) -> Self {
        Self {
            environment,
            direct_deps: HashMap::new(),
            transitive_deps: HashMap::new(),
            last_sync: None,
        }
    }

    fn get_state(&self) -> EnvironmentState {
        let mut packages = HashMap::new();
        let env_vars = HashMap::new();
        
        // Convert direct dependencies to package versions
        for (name, version_str) in &self.direct_deps {
            if let Ok(version) = Version::parse(version_str) {
                packages.insert(name.clone(), version);
            }
        }
        
        // Include transitive dependencies
        for (name, version_str) in &self.transitive_deps {
            if !packages.contains_key(name) {
                if let Ok(version) = Version::parse(version_str) {
                    packages.insert(name.clone(), version);
                }
            }
        }
        
        // Create a default Python version if none exists
        let python_version = PythonVersion::parse("3.8").unwrap_or_else(|_| {
            PythonVersion::new(3, 8, None)
        });

        EnvironmentState::new(
            self.environment.clone(),
            python_version,
            packages,
            env_vars,
        )
    }

    fn apply_diff(&mut self, diff: &StateDiff) {
        // Handle direct dependency changes
        for (name, version) in &diff.added_packages {
            self.direct_deps.insert(name.clone(), version.to_string());
        }
        for (name, _) in &diff.removed_packages {
            self.direct_deps.remove(name);
        }
        for (name, (_, new_version)) in &diff.updated_packages {
            self.direct_deps.insert(name.clone(), new_version.to_string());
        }

        // Update transitive dependencies based on resolution
        self.update_transitive_deps();
        
        // Update last sync timestamp
        self.last_sync = Some(chrono::Utc::now());
    }

    fn update_transitive_deps(&mut self) {
        // This is a placeholder - actual implementation would need to resolve dependencies
    }
}

/// Package upgrade operation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpgradeOperation {
    /// Package being upgraded
    pub package: String,
    /// Current version
    pub from_version: Version,
    /// Target version
    pub to_version: Version,
    /// Operation ID
    pub id: Uuid,
    /// Operation status
    pub status: OperationStatus,
    /// Start timestamp
    pub started_at: u64,
    /// Completion timestamp
    pub completed_at: Option<u64>,
}

impl UpgradeOperation {
    pub fn new(package: String, from_version: Version, to_version: Version) -> Self {
        Self {
            package,
            from_version,
            to_version,
            id: Uuid::new_v4(),
            status: OperationStatus::Pending,
            started_at: SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap_or_default()
                .as_secs(),
            completed_at: None,
        }
    }

    pub fn complete(&mut self, status: OperationStatus) {
        self.status = status;
        self.completed_at = Some(
            SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap_or_default()
                .as_secs(),
        );
    }

    pub fn validate_versions(&self, package: &Package) -> bool {
        let current_constraint = VersionConstraint::parse(&format!("={}", self.from_version))
            .unwrap_or_else(|_| VersionConstraint::any());
        let target_constraint = VersionConstraint::parse(&format!("={}", self.to_version))
            .unwrap_or_else(|_| VersionConstraint::any());
        
        current_constraint.matches(package.version()) || target_constraint.matches(package.version())
    }
}

/// Status of an operation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OperationStatus {
    /// Operation is pending
    Pending,
    /// Operation is in progress
    InProgress,
    /// Operation completed successfully
    Completed,
    /// Operation failed
    Failed(String),
}

/// Validate package changes
pub fn validate_changes(source: &Package, target: &Package) -> BlastResult<ValidationResult> {
    let mut issues = Vec::new();
    let mut is_valid = true;

    // Check version compatibility
    if source.version() != target.version() {
        // Check if source version is newer
        if source.version() > target.version() {
            issues.push(ValidationIssue {
                severity: IssueSeverity::Warning,
                description: format!(
                    "Package {} will be upgraded from {} to {}",
                    source.name(),
                    target.version(),
                    source.version()
                ),
                recommendation: "Review changelog for breaking changes".to_string(),
            });
        } else {
            issues.push(ValidationIssue {
                severity: IssueSeverity::Warning,
                description: format!(
                    "Package {} will be downgraded from {} to {}",
                    source.name(),
                    target.version(),
                    source.version()
                ),
                recommendation: "Consider keeping newer version".to_string(),
            });
        }
    }

    // Check Python version compatibility
    let source_python = source.metadata().python_version();
    let target_python = target.metadata().python_version();
    if !source_python.matches(&target_python) {
        is_valid = false;
        issues.push(ValidationIssue {
            severity: IssueSeverity::Critical,
            description: format!(
                "Package {} requires Python {} but target environment has {}",
                source.name(),
                source_python,
                target_python
            ),
            recommendation: "Update Python version or choose compatible package version".to_string(),
        });
    }

    // Check dependencies
    let source_deps = source.all_dependencies(&[]);
    let target_deps = target.all_dependencies(&[]);

    for (dep_name, constraint) in source_deps {
        if let Some(target_constraint) = target_deps.get(&dep_name) {
            if !constraint.is_compatible_with(target_constraint) {
                is_valid = false;
                issues.push(ValidationIssue {
                    severity: IssueSeverity::Critical,
                    description: format!(
                        "Dependency conflict: {} requires {} but target requires {}",
                        source.name(),
                        constraint,
                        target_constraint
                    ),
                    recommendation: "Resolve dependency conflict manually".to_string(),
                });
            }
        }
    }

    Ok(ValidationResult { is_valid, issues })
}

#[derive(Debug)]
pub struct ValidationResult {
    pub is_valid: bool,
    pub issues: Vec<ValidationIssue>,
}

impl SyncManager {
    /// Create new sync manager
    pub fn new() -> Self {
        Self {
            operations: HashMap::new(),
            stability_scores: HashMap::new(),
            dependencies: HashMap::new(),
        }
    }

    /// Plan sync operation between environments
    pub async fn plan_sync(
        &mut self,
        source: &PythonEnvironment,
        target: &PythonEnvironment,
    ) -> BlastResult<SyncOperation> {
        // Get environment dependencies
        let source_deps = self.get_environment_deps(source).await?;
        let target_deps = self.get_environment_deps(target).await?;

        // Analyze differences and conflicts
        let (changes, conflicts) = self.analyze_diff(&source_deps, &target_deps)?;

        // Validate changes and calculate performance impact
        let validation = self.validate_changes(&changes, source, target).await?;
        let performance_impact = self.estimate_performance_impact(&changes);

        // Create validation result
        let validation = SyncValidation {
            is_valid: validation.is_valid,
            issues: validation.issues,
            performance_impact,
        };

        // Create sync operation
        let operation = SyncOperation {
            id: Uuid::new_v4().to_string(),
            source: source.name().unwrap_or("source").to_string(),
            target: target.name().unwrap_or("target").to_string(),
            started_at: chrono::Utc::now(),
            completed_at: None,
            status: SyncStatus::Planning,
            changes: changes.clone(), // Clone here to avoid the move issue
            conflicts,
            validation,
        };

        // Store operation
        self.operations.insert(operation.id.clone(), operation.clone());

        Ok(operation)
    }

    /// Apply sync operation
    pub async fn apply_sync(
        &mut self,
        operation_id: &str,
        target: &mut PythonEnvironment,
    ) -> BlastResult<()> {
        let operation = self.operations.get_mut(operation_id)
            .ok_or_else(|| BlastError::sync("Operation not found"))?;

        operation.status = SyncStatus::InProgress;

        for change in &operation.changes {
            match change {
                SyncChange::UpdatePackage { package, from_version: _, to_version } => {
                    // Create new package with updated version
                    let metadata = PackageMetadata::new(
                        package.name().to_string(),
                        to_version.to_string(),
                        HashMap::new(),
                        VersionConstraint::any(),
                    );
                    let new_package = Package::new(
                        package.name().to_string(),
                        to_version.to_string(),
                        metadata,
                        VersionConstraint::any(),
                    )?;
                    target.remove_package(&package);
                    target.add_package(new_package);
                },
                SyncChange::InstallPackage(package) => {
                    target.add_package(package.clone());
                }
                SyncChange::RemovePackage(package) => {
                    target.remove_package(&package);
                }
                SyncChange::UpdateEnvVars(vars) => {
                    for (key, value) in vars {
                        target.update_env_var(&key, &value);
                    }
                }
                SyncChange::UpdatePythonVersion { to_version, .. } => {
                    target.update_python_version(&to_version.to_string())?;
                }
            }
        }

        // Update environment deps
        if let Some(deps) = self.dependencies.get_mut(&target.name().unwrap_or("unnamed").to_string()) {
            deps.last_sync = Some(Utc::now());
        }

        operation.status = SyncStatus::Completed;
        operation.completed_at = Some(Utc::now());

        Ok(())
    }

    /// Get environment dependencies
    async fn get_environment_deps(&mut self, env: &PythonEnvironment) -> BlastResult<EnvironmentDeps> {
        let packages = env.get_packages()?;
        let mut deps = EnvironmentDeps::new(env.name().unwrap_or("unnamed").to_string());

        // Add direct dependencies
        for package in packages {
            deps.direct_deps.insert(
                package.name().to_string(),
                package.version().to_string(),
            );
        }

        deps.last_sync = Some(Utc::now());
        Ok(deps)
    }

    fn get_version_stability(&self, package: &str, version: &Version) -> f64 {
        if let Some(score) = self.stability_scores.get(package) {
            if let Some(version_score) = score.version_scores.get(version) {
                return *version_score;
            }
        }
        0.5 // Default score for unknown versions
    }

    fn update_stability_score(&mut self, package: &str, version: &Version, factor: f64) {
        let score = self.stability_scores
            .entry(package.to_string())
            .or_insert_with(|| StabilityScore {
                package: package.to_string(),
                version_scores: HashMap::new(),
                usage_count: 0,
                last_updated: Utc::now(),
            });

        let version_score = score.version_scores
            .entry(version.clone())
            .or_insert(0.5);
        *version_score = (*version_score * score.usage_count as f64 + factor) / (score.usage_count + 1) as f64;
        score.usage_count += 1;
        score.last_updated = Utc::now();
    }

    /// Analyze differences between environments
    fn analyze_diff(
        &self,
        source_deps: &EnvironmentDeps,
        target_deps: &EnvironmentDeps,
    ) -> BlastResult<(Vec<SyncChange>, Vec<SyncConflict>)> {
        let mut changes = Vec::new();
        let mut conflicts = Vec::new();

        // Compare direct dependencies
        for (name, version) in &source_deps.direct_deps {
            if let Some(target_version) = target_deps.direct_deps.get(name) {
                if version != target_version {
                    // Version mismatch - check compatibility
                    let metadata = PackageMetadata::new(
                        name.clone(),
                        version.clone(),
                        HashMap::new(),
                        VersionConstraint::default(),
                    );
                    
                    let package = Package::new(
                        name.clone(),
                        version.clone(),
                        metadata,
                        VersionConstraint::default(),
                    )?;
                    
                    // Get all dependencies including extras
                    let deps = package.all_dependencies(&[]);
                    
                    // Check for conflicts
                    if self.has_dependency_conflicts(&deps, target_deps) {
                        conflicts.push(SyncConflict {
                            conflict_type: ConflictType::DependencyConflict,
                            description: format!("Dependency conflict for package {}", name),
                            resolutions: vec![
                                ConflictResolution::UseSource,
                                ConflictResolution::UseTarget,
                                ConflictResolution::Skip,
                            ],
                            selected_resolution: None,
                        });
                    } else {
                        // Create source version
                        let source_version = Version::parse(version)?;
                        let target_version = Version::parse(target_version)?;
                        
                        changes.push(SyncChange::UpdatePackage {
                            package,
                            from_version: target_version,
                            to_version: source_version,
                        });
                    }
                }
            } else {
                // Package not in target - add it
                let metadata = PackageMetadata::new(
                    name.clone(),
                    version.clone(),
                    HashMap::new(),
                    VersionConstraint::default(),
                );
                
                let package = Package::new(
                    name.clone(),
                    version.clone(),
                    metadata,
                    VersionConstraint::default(),
                )?;
                changes.push(SyncChange::InstallPackage(package));
            }
        }

        // Check for packages to remove
        for name in target_deps.direct_deps.keys() {
            if !source_deps.direct_deps.contains_key(name) {
                if let Some(version) = target_deps.direct_deps.get(name) {
                    let metadata = PackageMetadata::new(
                        name.clone(),
                        version.clone(),
                        HashMap::new(),
                        VersionConstraint::default(),
                    );
                    
                    let package = Package::new(
                        name.clone(),
                        version.clone(),
                        metadata,
                        VersionConstraint::default(),
                    )?;
                    changes.push(SyncChange::RemovePackage(package));
                }
            }
        }

        Ok((changes, conflicts))
    }
    
    pub async fn validate_changes(
        &self,
        changes: &[SyncChange],
        source: &PythonEnvironment,
        target: &PythonEnvironment,
    ) -> BlastResult<SyncValidation> {
        let mut issues = Vec::new();
        let mut is_valid = true;

        // Get target Python version
        let target_version = target.python_version().to_string();

        // Validate each change
        for change in changes {
            match change {
                SyncChange::InstallPackage(package) => {
                    // Validate package compatibility with target Python version
                    if !package.is_python_compatible(&target_version)? {
                        is_valid = false;
                        issues.push(ValidationIssue {
                            severity: IssueSeverity::Critical,
                            description: format!(
                                "Package {} is not compatible with Python {}",
                                package.name(),
                                target_version
                            ),
                            recommendation: "Choose a different package version or update Python".to_string(),
                        });
                    }

                    // Check for conflicts with existing packages
                    if let Some(existing) = target.get_package(package.name()) {
                        let validation = validate_changes(package, existing)?;
                        is_valid &= validation.is_valid;
                        issues.extend(validation.issues);
                    }
                }
                SyncChange::UpdatePackage { package, from_version, to_version } => {
                    // Validate package compatibility with target Python version
                    if !package.is_python_compatible(&target_version)? {
                        is_valid = false;
                        issues.push(ValidationIssue {
                            severity: IssueSeverity::Critical,
                            description: format!(
                                "Package {} is not compatible with Python {}",
                                package.name(),
                                target_version
                            ),
                            recommendation: "Choose a different package version or update Python".to_string(),
                        });
                    }

                    // Check version stability
                    let stability_score = self.get_version_stability(package.name(), to_version);
                    if stability_score < 0.3 {
                        issues.push(ValidationIssue {
                            severity: IssueSeverity::Warning,
                            description: format!(
                                "Package {} version {} has low stability score ({})",
                                package.name(),
                                to_version,
                                stability_score
                            ),
                            recommendation: "Consider using a more stable version".to_string(),
                        });
                    }

                    // Check for major version changes
                    if from_version.as_semver().major != to_version.as_semver().major {
                        issues.push(ValidationIssue {
                            severity: IssueSeverity::Warning,
                            description: format!(
                                "Major version change for package {} ({} -> {})",
                                package.name(),
                                from_version,
                                to_version
                            ),
                            recommendation: "Review breaking changes in changelog".to_string(),
                        });
                    }
                }
                SyncChange::RemovePackage(package) => {
                    // Check if other packages depend on this one
                    let packages = target.get_packages()?;
                    for dep in packages {
                        let deps = dep.all_dependencies(&[]);
                        if deps.contains_key(package.name()) {
                            is_valid = false;
                            issues.push(ValidationIssue {
                                severity: IssueSeverity::Critical,
                                description: format!(
                                    "Cannot remove package {} as it is required by {}",
                                    package.name(),
                                    dep.name()
                                ),
                                recommendation: "Remove dependent packages first".to_string(),
                            });
                        }
                    }
                }
                SyncChange::UpdatePythonVersion { from_version, to_version } => {
                    // Check if version change is backward compatible
                    if from_version.major() != to_version.major() || from_version.minor() > to_version.minor() {
                        issues.push(ValidationIssue {
                            severity: IssueSeverity::Warning,
                            description: format!(
                                "Python version change from {} to {} may break compatibility",
                                from_version,
                                to_version
                            ),
                            recommendation: "Test all packages with new Python version".to_string(),
                        });
                    }

                    // Validate all packages against new Python version
                    let packages = target.get_packages()?;
                    for package in packages {
                        if !package.is_python_compatible(&to_version.to_string())? {
                            is_valid = false;
                            issues.push(ValidationIssue {
                                severity: IssueSeverity::Critical,
                                description: format!(
                                    "Package {} is not compatible with Python {}",
                                    package.name(),
                                    to_version
                                ),
                                recommendation: "Update package or choose different Python version".to_string(),
                            });
                        }
                    }
                }
                SyncChange::UpdateEnvVars(vars) => {
                    // Check for sensitive environment variables
                    for (key, _) in vars {
                        if key.contains("SECRET") || key.contains("PASSWORD") || key.contains("TOKEN") {
                            issues.push(ValidationIssue {
                                severity: IssueSeverity::Warning,
                                description: format!("Environment variable {} may contain sensitive data", key),
                                recommendation: "Consider using a secrets manager".to_string(),
                            });
                        }
                    }
                }
            }
        }

        // Estimate performance impact
        let performance_impact = self.estimate_performance_impact(changes);

        Ok(SyncValidation {
            is_valid,
            issues,
            performance_impact,
        })
    }

    /// Merge environments
    pub async fn merge_environments(&mut self, source: &PythonEnvironment, target: &mut PythonEnvironment) -> BlastResult<()> {
        let source_deps = self.get_environment_deps(source).await?;
        let target_deps = self.get_environment_deps(target).await?;

        // Analyze differences
        let (changes, conflicts) = self.analyze_diff(&source_deps, &target_deps)?;

        // Create sync operation
        let operation = SyncOperation {
            id: Uuid::new_v4().to_string(),
            source: source.name().unwrap_or("unnamed").to_string(),
            target: target.name().unwrap_or("unnamed").to_string(),
            started_at: Utc::now(),
            completed_at: None,
            status: SyncStatus::Planning,
            changes,
            conflicts,
            validation: SyncValidation {
                is_valid: true,
                issues: Vec::new(),
                performance_impact: self.estimate_performance_impact(&changes),
            },
        };

        // Store operation
        self.operations.insert(operation.id.clone(), operation.clone());

        // Apply changes
        self.apply_sync(&operation.id, target).await?;

        Ok(())
    }

    /// Resolve conflict between packages
    pub fn resolve_conflict(&self, package: &Package, conflict: &Package) -> BlastResult<Package> {
        // Choose the package with the higher version
        if package.version().to_string() >= conflict.version().to_string() {
            Ok(package.clone())
        } else {
            Ok(conflict.clone())
        }
    }

    fn has_dependency_conflicts(&self, deps: &HashMap<String, VersionConstraint>, target_deps: &EnvironmentDeps) -> bool {
        for (name, constraint) in deps {
            if let Some(version_str) = target_deps.direct_deps.get(name) {
                // Parse version string
                if let Ok(version) = Version::parse(version_str) {
                    if !constraint.matches(&version) {
                        return true;
                    }
                }
            }
        }
        false
    }

    fn estimate_performance_impact(&self, changes: &[SyncChange]) -> PerformanceImpact {
        // Estimate based on number and type of changes
        let num_changes = changes.len();
        
        PerformanceImpact {
            estimated_duration: std::time::Duration::from_secs((num_changes * 10) as u64), // 10 seconds per change
            required_space: (num_changes * 1024 * 1024) as u64, // 1MB per change
            network_bandwidth: (num_changes * 512 * 1024) as u64, // 512KB per change
            cpu_usage: 0.1 * num_changes as f32, // 10% CPU per change
            memory_usage: (num_changes * 256 * 1024 * 1024) as u64, // 256MB per change
        }
    }
}

/// Strategy for merging environment changes
pub enum MergeStrategy {
    /// Keep all changes from source
    KeepSource,
    /// Keep all changes from target
    KeepTarget,
    /// Prefer source changes but allow manual resolution
    PreferSource,
    /// Interactive merge with manual conflict resolution
    Interactive,
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-core/src/sync/conflicts.rs

```rs
use serde::{Deserialize, Serialize};
use crate::version::Version;

/// Conflict during sync
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SyncConflict {
    /// Type of conflict
    pub conflict_type: ConflictType,
    /// Description of the conflict
    pub description: String,
    /// Possible resolutions
    pub resolutions: Vec<ConflictResolution>,
    /// Selected resolution
    pub selected_resolution: Option<ConflictResolution>,
}

/// Type of sync conflict
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum ConflictType {
    /// Version mismatch between environments
    VersionMismatch,
    /// Package exists in both environments with different versions
    PackageVersionConflict,
    /// Package dependencies are incompatible
    DependencyConflict,
    /// Environment variables conflict
    EnvVarConflict,
    /// Python version incompatibility
    PythonVersionConflict,
}

/// Resolution for a conflict
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ConflictResolution {
    /// Use source version
    UseSource,
    /// Use target version
    UseTarget,
    /// Use specific version
    UseVersion(Version),
    /// Skip this change
    Skip,
    /// Merge changes
    Merge,
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-core/src/sync/operations.rs

```rs
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;
use std::time::{SystemTime, UNIX_EPOCH};

use crate::python::PythonVersion;
use super::types::SyncChange;
use super::conflicts::SyncConflict;
use super::validation::SyncValidation;

/// Sync operation between environments
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SyncOperation {
    /// Operation ID
    pub id: String,
    /// Source environment
    pub source: String,
    /// Target environment
    pub target: String,
    /// Start timestamp
    pub started_at: DateTime<Utc>,
    /// Completion timestamp
    pub completed_at: Option<DateTime<Utc>>,
    /// Operation status
    pub status: SyncStatus,
    /// Package changes
    pub changes: Vec<SyncChange>,
    /// Conflicts that need resolution
    pub conflicts: Vec<SyncConflict>,
    /// Validation results
    pub validation: SyncValidation,
}

/// Status of sync operation
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum SyncStatus {
    /// Sync is being planned
    Planning,
    /// Sync is in progress
    InProgress,
    /// Sync completed successfully
    Completed,
    /// Sync failed
    Failed(String),
    /// Sync was cancelled
    Cancelled,
}

/// Package upgrade operation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpgradeOperation {
    /// Package being upgraded
    pub package: String,
    /// Current version
    pub from_version: PythonVersion,
    /// Target version
    pub to_version: PythonVersion,
    /// Operation ID
    pub id: Uuid,
    /// Operation status
    pub status: OperationStatus,
    /// Start timestamp
    pub started_at: u64,
    /// Completion timestamp
    pub completed_at: Option<u64>,
}

/// Status of an operation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OperationStatus {
    /// Operation is pending
    Pending,
    /// Operation is in progress
    InProgress,
    /// Operation completed successfully
    Completed,
    /// Operation failed
    Failed(String),
}

impl UpgradeOperation {
    pub fn new(package: String, from_version: PythonVersion, to_version: PythonVersion) -> Self {
        Self {
            package,
            from_version,
            to_version,
            id: Uuid::new_v4(),
            status: OperationStatus::Pending,
            started_at: SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap_or_default()
                .as_secs(),
            completed_at: None,
        }
    }

    pub fn complete(&mut self, status: OperationStatus) {
        self.status = status;
        self.completed_at = Some(
            SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap_or_default()
                .as_secs(),
        );
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-core/src/layer.rs

```rs
use async_trait::async_trait;
use crate::error::BlastResult;

/// Layer trait for caching operations
#[async_trait]
pub trait Layer: Send + Sync {
    /// Get layer data by hash
    async fn get_layer(&self, hash: &str) -> BlastResult<Option<Vec<u8>>>;

    /// Store layer data with hash
    async fn put_layer(&self, hash: &str, data: Vec<u8>) -> BlastResult<()>;

    /// Remove layer by hash
    async fn remove_layer(&self, hash: &str) -> BlastResult<()>;

    /// Clean up expired or invalid layers
    async fn cleanup(&self) -> BlastResult<()>;
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-core/src/environment.rs

```rs
use std::path::PathBuf;
use std::process::Command;
use std::collections::HashMap;
use async_trait::async_trait;
use crate::error::{BlastError, BlastResult};
use crate::package::Package;
use crate::version::VersionConstraint;
use crate::python::PythonVersion;
use crate::metadata::PackageMetadata;

// Helper function to create package metadata from dependencies
fn create_package_metadata(
    name: String,
    version: String,
    dependencies: HashMap<String, VersionConstraint>,
    python_version: VersionConstraint,
) -> PackageMetadata {
    PackageMetadata::new(
        name,
        version,
        dependencies,
        python_version,
    )
}

/// Core trait for environment management
#[async_trait]
pub trait Environment: Send + Sync + 'static {
    /// Create a new environment
    async fn create(&self) -> BlastResult<()>;

    /// Activate the environment
    async fn activate(&self) -> BlastResult<()>;

    /// Deactivate the environment
    async fn deactivate(&self) -> BlastResult<()>;

    /// Install a package
    async fn install_package(&self, package: &Package) -> BlastResult<()>;

    /// Uninstall a package
    async fn uninstall_package(&self, package: &Package) -> BlastResult<()>;

    /// Get installed packages
    async fn get_packages(&self) -> BlastResult<Vec<Package>>;

    /// Get environment path
    fn path(&self) -> &PathBuf;

    /// Get Python version
    fn python_version(&self) -> &PythonVersion;

    /// Set environment name
    fn set_name(&mut self, name: String);

    /// Get environment name
    fn name(&self) -> Option<&str>;
}

/// Python environment implementation
#[derive(Debug, Clone)]
pub struct PythonEnvironment {
    path: PathBuf,
    python_version: PythonVersion,
    name: Option<String>,
}

impl PythonEnvironment {
    /// Create a new Python environment
    pub fn new(path: PathBuf, python_version: PythonVersion) -> Self {
        Self {
            path,
            python_version,
            name: None,
        }
    }

    /// Get the pip executable path for this environment
    fn pip_executable(&self) -> PathBuf {
        #[cfg(unix)]
        {
            self.path.join("bin").join("pip")
        }
        #[cfg(windows)]
        {
            self.path.join("Scripts").join("pip.exe")
        }
    }
}

#[async_trait]
impl Environment for PythonEnvironment {
    async fn create(&self) -> BlastResult<()> {
        // Create virtual environment using the system Python
        let output = Command::new("python3")
            .arg("-m")
            .arg("venv")
            .arg(&self.path)
            .output()
            .map_err(|e| BlastError::environment(format!(
                "Failed to create virtual environment: {}", e
            )))?;

        if !output.status.success() {
            return Err(BlastError::environment(format!(
                "Failed to create virtual environment: {}",
                String::from_utf8_lossy(&output.stderr)
            )));
        }

        Ok(())
    }

    async fn activate(&self) -> BlastResult<()> {
        // No need to actually activate - we'll use full paths to executables
        Ok(())
    }

    async fn deactivate(&self) -> BlastResult<()> {
        // No need to actually deactivate - we'll use full paths to executables
        Ok(())
    }

    async fn install_package(&self, package: &Package) -> BlastResult<()> {
        let pip = self.pip_executable();
        let package_spec = format!("{}=={}", package.name(), package.version());
        
        let output = Command::new(pip)
            .arg("install")
            .arg(&package_spec)
            .output()
            .map_err(|e| BlastError::environment(format!(
                "Failed to execute pip install: {}", e
            )))?;

        if !output.status.success() {
            return Err(BlastError::environment(format!(
                "Failed to install package {}: {}",
                package_spec,
                String::from_utf8_lossy(&output.stderr)
            )));
        }

        Ok(())
    }

    async fn uninstall_package(&self, package: &Package) -> BlastResult<()> {
        let pip = self.pip_executable();
        
        let output = Command::new(pip)
            .arg("uninstall")
            .arg("--yes")
            .arg(package.name())
            .output()
            .map_err(|e| BlastError::environment(format!(
                "Failed to execute pip uninstall: {}", e
            )))?;

        if !output.status.success() {
            return Err(BlastError::environment(format!(
                "Failed to uninstall package {}: {}",
                package.name(),
                String::from_utf8_lossy(&output.stderr)
            )));
        }

        Ok(())
    }

    async fn get_packages(&self) -> BlastResult<Vec<Package>> {
        // Execute pip freeze to get installed packages
        let output = Command::new(self.pip_executable())
            .arg("freeze")
            .output()
            .map_err(|e| BlastError::environment(format!(
                "Failed to execute pip freeze: {}", e
            )))?;

        if !output.status.success() {
            return Err(BlastError::environment(format!(
                "Failed to get installed packages: {}",
                String::from_utf8_lossy(&output.stderr)
            )));
        }

        // Parse pip freeze output
        let packages = String::from_utf8_lossy(&output.stdout)
            .lines()
            .filter_map(|line| {
                let parts: Vec<&str> = line.split('=').collect();
                if parts.len() >= 2 {
                    let name = parts[0].trim().to_string();
                    let version = parts[1].trim().replace('=', "");
                    
                    // Create empty dependencies map and any version constraint
                    let dependencies = HashMap::new();
                    let python_version = VersionConstraint::any();
                    
                    Package::new(
                        name.clone(),
                        version.clone(),
                        create_package_metadata(
                            name,
                            version,
                            dependencies,
                            python_version.clone(),
                        ),
                        python_version
                    ).ok()
                } else {
                    None
                }
            })
            .collect::<Vec<_>>();

        Ok(packages)
    }

    fn path(&self) -> &PathBuf {
        &self.path
    }

    fn python_version(&self) -> &PythonVersion {
        &self.python_version
    }

    fn set_name(&mut self, name: String) {
        self.name = Some(name);
    }

    fn name(&self) -> Option<&str> {
        self.name.as_deref()
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-core/src/bindings.rs

```rs
use std::collections::HashMap;

use crate::environment::Environment;
use crate::python::{PythonEnvironment, PythonVersion};
use crate::package::Package;
use crate::version::VersionConstraint;
use crate::manifest::Manifest;
use crate::error::{BlastError, BlastResult};
use crate::metadata::PackageMetadata;

/// Native Python environment wrapper
#[derive(Clone)]
pub struct NativeEnvironment {
    inner: PythonEnvironment,
}

impl NativeEnvironment {
    /// Create a new Python environment
    pub fn new(path: String, python_version: String) -> BlastResult<Self> {
        let version = PythonVersion::parse(&python_version)?;
        Ok(Self {
            inner: PythonEnvironment::new(path.into(), version),
        })
    }

    /// Get the environment path
    pub fn path(&self) -> String {
        self.inner.path().display().to_string()
    }

    /// Get the Python version
    pub fn python_version(&self) -> String {
        self.inner.python_version().to_string()
    }

    /// Install a package in the environment
    pub async fn install_package(&self, package: &NativePackage) -> BlastResult<()> {
        self.inner.install_package(&package.inner).await
    }

    /// Uninstall a package from the environment
    pub async fn uninstall_package(&self, package: &NativePackage) -> BlastResult<()> {
        self.inner.uninstall_package(&package.inner).await
    }

    /// Get installed packages
    pub async fn get_packages(&self) -> BlastResult<Vec<NativePackage>> {
        let packages = self.inner.get_packages()?;
        Ok(packages.into_iter().map(|p| NativePackage { inner: p }).collect())
    }

    /// Execute Python code in the environment
    pub async fn execute_python(&self, code: &str) -> BlastResult<String> {
        let output = tokio::process::Command::new(&self.inner.interpreter_path())
            .arg("-c")
            .arg(code)
            .output()
            .await?;

        if output.status.success() {
            Ok(String::from_utf8_lossy(&output.stdout).to_string())
        } else {
            Err(BlastError::python(format!(
                "Python execution failed: {}",
                String::from_utf8_lossy(&output.stderr)
            )))
        }
    }

    /// Run a Python script file
    pub async fn run_script(&self, script_path: &str) -> BlastResult<String> {
        let python_path = self.inner.interpreter_path();
        let output = tokio::process::Command::new(python_path)
            .arg(script_path)
            .output()
            .await
            .map_err(|e| BlastError::python(format!("Failed to run script: {}", e)))?;

        if !output.status.success() {
            return Err(BlastError::python(format!(
                "Script execution failed: {}",
                String::from_utf8_lossy(&output.stderr)
            )));
        }

        Ok(String::from_utf8_lossy(&output.stdout).to_string())
    }

    /// Install dependencies from requirements.txt
    pub async fn install_requirements(&self, requirements_path: &str) -> BlastResult<()> {
        let pip = self.inner.pip_executable();
        let output = tokio::process::Command::new(pip)
            .arg("install")
            .arg("-r")
            .arg(requirements_path)
            .output()
            .await
            .map_err(|e| BlastError::python(format!("Failed to install requirements: {}", e)))?;

        if !output.status.success() {
            return Err(BlastError::python(format!(
                "Failed to install requirements: {}",
                String::from_utf8_lossy(&output.stderr)
            )));
        }

        Ok(())
    }
}

/// Native package wrapper
#[derive(Clone)]
pub struct NativePackage {
    inner: Package,
}

impl NativePackage {
    /// Create a new package
    pub fn new(name: String, version: String, dependencies: Option<HashMap<String, String>>) -> BlastResult<Self> {
        let deps = dependencies.unwrap_or_default()
            .into_iter()
            .map(|(name, ver)| {
                VersionConstraint::parse(&ver)
                    .map(|constraint| (name, constraint))
            })
            .collect::<Result<HashMap<_, _>, _>>()?;

        let python_version = VersionConstraint::any();
        
        Ok(Self {
            inner: Package::new(
                name.clone(),
                version.clone(),
                PackageMetadata::new(
                    name,
                    version,
                    deps,
                    python_version.clone(),
                ),
                python_version,
            )?
        })
    }

    /// Get package name
    pub fn name(&self) -> String {
        self.inner.name().to_string()
    }

    /// Get package version
    pub fn version(&self) -> String {
        self.inner.version().to_string()
    }

    /// Get package dependencies
    pub fn dependencies(&self) -> HashMap<String, String> {
        self.inner.all_dependencies(&[])
            .into_iter()
            .map(|(k, v)| (k, v.to_string()))
            .collect()
    }
}

/// Native manifest wrapper
pub struct NativeManifest {
    inner: Manifest,
}

impl NativeManifest {
    /// Create manifest from environment
    pub async fn from_environment(env: &NativeEnvironment) -> BlastResult<Self> {
        Ok(Self {
            inner: Manifest::from_environment(&env.inner).await?
        })
    }

    /// Save manifest to file
    pub async fn save(&self, path: String) -> BlastResult<()> {
        self.inner.save(path.into()).await
    }

    /// Load manifest from file
    pub async fn load(path: String) -> BlastResult<Self> {
        Ok(Self {
            inner: Manifest::load(path.into()).await?
        })
    }

    /// Get packages in manifest
    pub fn packages(&self) -> Vec<NativePackage> {
        self.inner.packages()
            .iter()
            .map(|p| NativePackage { inner: p.clone() })
            .collect()
    }

    /// Add package to manifest
    pub fn add_package(&mut self, package: &NativePackage) {
        self.inner.add_package(package.inner.clone());
    }

    /// Remove package from manifest
    pub fn remove_package(&mut self, name: String) {
        self.inner.remove_package(&name);
    }
}

/// Create a new Python environment
pub async fn create_environment(path: String, python_version: Option<String>) -> BlastResult<NativeEnvironment> {
    let version = python_version.unwrap_or_else(|| "3.8".to_string());
    let env = NativeEnvironment::new(path, version)?;
    env.inner.create().await?;
    Ok(env)
}

/// Get the active Python environment
pub fn get_active_environment() -> BlastResult<Option<NativeEnvironment>> {
    match PythonEnvironment::get_active()? {
        Some(env) => Ok(Some(NativeEnvironment { inner: env })),
        None => Ok(None),
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-core/src/python.rs

```rs
use std::path::{Path, PathBuf};
use std::process::Command;
use std::collections::HashMap;
use async_trait::async_trait;
use std::str::FromStr;
use serde::{Deserialize, Serialize};
use std::cmp::Ordering;

use crate::error::{BlastError, BlastResult};
use crate::package::Package;
use crate::version::VersionConstraint;
use crate::environment::Environment;
use crate::metadata::PackageMetadata;

// Helper function to create package metadata from dependencies
fn create_package_metadata(
    name: String,
    version: String,
    dependencies: HashMap<String, VersionConstraint>,
    python_version: VersionConstraint,
) -> PackageMetadata {
    PackageMetadata::new(
        name,
        version,
        dependencies,
        python_version,
    )
}

/// Python version specification
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct PythonVersion {
    major: u32,
    minor: u32,
    patch: Option<u32>,
}

impl Default for PythonVersion {
    fn default() -> Self {
        Self {
            major: 3,
            minor: 7,
            patch: None,
        }
    }
}

impl PythonVersion {
    /// Create a new Python version
    pub fn new(major: u32, minor: u32, patch: Option<u32>) -> Self {
        Self {
            major,
            minor,
            patch,
        }
    }

    /// Get the major version
    pub fn major(&self) -> u32 {
        self.major
    }

    /// Get the minor version
    pub fn minor(&self) -> u32 {
        self.minor
    }

    /// Get the patch version
    pub fn patch(&self) -> Option<u32> {
        self.patch
    }

    /// Convert to string representation
    pub fn to_string(&self) -> String {
        match self.patch {
            Some(patch) => format!("{}.{}.{}", self.major, self.minor, patch),
            None => format!("{}.{}", self.major, self.minor),
        }
    }

    /// Check if this version is compatible with another version
    pub fn is_compatible_with(&self, other: &PythonVersion) -> bool {
        self.major == other.major && self.minor <= other.minor
    }

    pub fn parse(version: &str) -> BlastResult<Self> {
        let parts: Vec<&str> = version.split('.').collect();
        if parts.len() < 2 {
            return Err(BlastError::Python(format!(
                "Invalid Python version format: {}",
                version
            )));
        }

        let major = parts[0]
            .parse()
            .map_err(|_| BlastError::Python(format!("Invalid major version: {}", parts[0])))?;
        let minor = parts[1]
            .parse()
            .map_err(|_| BlastError::Python(format!("Invalid minor version: {}", parts[1])))?;
        let patch = if parts.len() > 2 {
            Some(
                parts[2]
                    .parse()
                    .map_err(|_| BlastError::Python(format!("Invalid patch version: {}", parts[2])))?,
            )
        } else {
            None
        };

        Ok(Self {
            major,
            minor,
            patch,
        })
    }
}

impl std::fmt::Display for PythonVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self.patch {
            Some(patch) => write!(f, "{}.{}.{}", self.major, self.minor, patch),
            None => write!(f, "{}.{}", self.major, self.minor),
        }
    }
}

impl PartialOrd for PythonVersion {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for PythonVersion {
    fn cmp(&self, other: &Self) -> Ordering {
        match self.major.cmp(&other.major) {
            Ordering::Equal => match self.minor.cmp(&other.minor) {
                Ordering::Equal => match (self.patch, other.patch) {
                    (None, None) => Ordering::Equal,
                    (None, Some(_)) => Ordering::Less,
                    (Some(_), None) => Ordering::Greater,
                    (Some(a), Some(b)) => a.cmp(&b),
                },
                ord => ord,
            },
            ord => ord,
        }
    }
}

impl FromStr for PythonVersion {
    type Err = BlastError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::parse(s)
    }
}

/// Python environment state
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PythonEnvironment {
    /// Path to the environment
    pub path: PathBuf,
    /// Python version
    pub python_version: PythonVersion,
    /// Installed packages
    pub packages: Vec<Package>,
    /// Environment creation time
    pub created_at: chrono::DateTime<chrono::Utc>,
    
    /// Last update time
    pub updated_at: chrono::DateTime<chrono::Utc>,
    /// Environment metadata
    pub metadata: EnvironmentMetadata,
    /// Environment name
    pub name: Option<String>,
    /// Environment version
    pub version: Option<String>,
}

impl PythonEnvironment {
    /// Create a new Python environment
    pub fn new(path: PathBuf, python_version: PythonVersion) -> Self {
        let now = chrono::Utc::now();
        Self {
            path,
            python_version,
            packages: Vec::new(),
            created_at: now,
            updated_at: now,
            metadata: EnvironmentMetadata::default(),
            name: None,
            version: None,
        }
    }

    /// Get the environment path
    pub fn path(&self) -> &Path {
        &self.path
    }

    /// Get the Python version
    pub fn python_version(&self) -> &PythonVersion {
        &self.python_version
    }

    /// Get the environment name
    pub fn name(&self) -> Option<&str> {
        self.name.as_deref()
    }

    /// Get the environment version
    pub fn version(&self) -> Option<&str> {
        self.version.as_deref()
    }

    /// Set the environment name
    pub fn set_name(&mut self, name: String) {
        self.name = Some(name);
    }

    /// Set the environment version
    pub fn set_version(&mut self, version: String) {
        self.version = Some(version);
    }

    /// Get the Python interpreter path
    pub fn interpreter_path(&self) -> PathBuf {
        #[cfg(windows)]
        let python_exe = "python.exe";
        #[cfg(not(windows))]
        let python_exe = "python";

        self.path.join("bin").join(python_exe)
    }

    /// Check if the environment exists
    pub fn exists(&self) -> bool {
        self.interpreter_path().exists()
    }

    /// Get the packages in the environment
    pub fn get_packages(&self) -> BlastResult<Vec<Package>> {
        Ok(self.packages.clone())
    }

    /// Add a package to the environment
    pub fn add_package(&mut self, package: Package) {
        self.packages.push(package);
        self.updated_at = chrono::Utc::now();
    }

    /// Remove a package from the environment
    pub fn remove_package(&mut self, package: &Package) {
        self.packages.retain(|p| p.name() != package.name());
        self.updated_at = chrono::Utc::now();
    }

    /// Get a package by name
    pub fn get_package(&self, name: &str) -> Option<&Package> {
        self.packages.iter().find(|p| p.name() == name)
    }

    /// Update the Python version
    pub fn update_python_version(&mut self, version: &str) -> BlastResult<()> {
        let new_version = PythonVersion::parse(version)?;
        self.python_version = new_version;
        self.updated_at = chrono::Utc::now();
        Ok(())
    }

    /// Update an environment variable
    pub fn update_env_var(&mut self, key: &str, value: &str) {
        let env_vars = match self.metadata.extra.as_object_mut() {
            Some(obj) => {
                if !obj.contains_key("env_vars") {
                    obj.insert("env_vars".to_string(), serde_json::Value::Object(serde_json::Map::new()));
                }
                obj.get_mut("env_vars").unwrap().as_object_mut().unwrap()
            }
            None => {
                let mut map = serde_json::Map::new();
                map.insert("env_vars".to_string(), serde_json::Value::Object(serde_json::Map::new()));
                self.metadata.extra = serde_json::Value::Object(map);
                self.metadata.extra.as_object_mut().unwrap().get_mut("env_vars").unwrap().as_object_mut().unwrap()
            }
        };

        env_vars.insert(key.to_string(), serde_json::Value::String(value.to_string()));
        self.updated_at = chrono::Utc::now();
    }

    /// Get an environment variable
    pub fn get_env_var(&self, key: &str) -> Option<String> {
        self.metadata.extra
            .as_object()
            .and_then(|obj| obj.get("env_vars"))
            .and_then(|env_vars| env_vars.as_object())
            .and_then(|env_vars| env_vars.get(key))
            .and_then(|value| value.as_str())
            .map(|s| s.to_string())
    }

    /// Get all environment variables
    pub fn get_env_vars(&self) -> HashMap<String, String> {
        let mut vars = HashMap::new();
        if let Some(obj) = self.metadata.extra.as_object() {
            if let Some(env_vars) = obj.get("env_vars").and_then(|v| v.as_object()) {
                for (key, value) in env_vars {
                    if let Some(value_str) = value.as_str() {
                        vars.insert(key.clone(), value_str.to_string());
                    }
                }
            }
        }
        vars
    }

    /// Get the pip executable
    pub fn pip_executable(&self) -> PathBuf {
        self.interpreter_path().join("pip")
    }

    pub fn get_active() -> BlastResult<Option<Self>> {
        if let Ok(path) = std::env::var("BLAST_ENV_PATH") {
            let python_version = if let Ok(version) = std::env::var("BLAST_PYTHON_VERSION") {
                PythonVersion::parse(&version)?
            } else {
                PythonVersion::default()
            };

            Ok(Some(Self::new(PathBuf::from(path), python_version)))
        } else {
            Ok(None)
        }
    }

    /// Check if a package is installed
    pub async fn has_package(&self, package: &Package) -> BlastResult<bool> {
        let packages = self.get_packages()?;
        Ok(packages.iter().any(|p| p.name() == package.name() && p.version() == package.version()))
    }
}

/// Metadata for Python environments
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct EnvironmentMetadata {
    /// Environment name
    pub name: Option<String>,
    /// Environment description
    pub description: Option<String>,
    /// Custom tags
    pub tags: Vec<String>,
    /// Additional metadata
    pub extra: serde_json::Value,
}

#[async_trait]
impl Environment for PythonEnvironment {
    async fn create(&self) -> BlastResult<()> {
        // Create virtual environment using the system Python
        let output = Command::new("python3")
            .arg("-m")
            .arg("venv")
            .arg(&self.path)
            .output()
            .map_err(|e| BlastError::environment(format!(
                "Failed to create virtual environment: {}", e
            )))?;

        if !output.status.success() {
            return Err(BlastError::environment(format!(
                "Failed to create virtual environment: {}",
                String::from_utf8_lossy(&output.stderr)
            )));
        }

        Ok(())
    }

    async fn activate(&self) -> BlastResult<()> {
        // No need to actually activate - we'll use full paths to executables
        Ok(())
    }

    async fn deactivate(&self) -> BlastResult<()> {
        // No need to actually deactivate - we'll use full paths to executables
        Ok(())
    }

    async fn install_package(&self, package: &Package) -> BlastResult<()> {
        let pip = self.pip_executable();
        let package_spec = format!("{}=={}", package.name(), package.version());
        
        let output = Command::new(pip)
            .arg("install")
            .arg(&package_spec)
            .output()
            .map_err(|e| BlastError::environment(format!(
                "Failed to execute pip install: {}", e
            )))?;

        if !output.status.success() {
            return Err(BlastError::environment(format!(
                "Failed to install package {}: {}",
                package_spec,
                String::from_utf8_lossy(&output.stderr)
            )));
        }

        Ok(())
    }

    async fn uninstall_package(&self, package: &Package) -> BlastResult<()> {
        let pip = self.pip_executable();
        
        let output = Command::new(pip)
            .arg("uninstall")
            .arg("--yes")
            .arg(package.name())
            .output()
            .map_err(|e| BlastError::environment(format!(
                "Failed to execute pip uninstall: {}", e
            )))?;

        if !output.status.success() {
            return Err(BlastError::environment(format!(
                "Failed to uninstall package {}: {}",
                package.name(),
                String::from_utf8_lossy(&output.stderr)
            )));
        }

        Ok(())
    }

    async fn get_packages(&self) -> BlastResult<Vec<Package>> {
        let output = Command::new(&self.pip_executable())
            .args(&["list", "--format=json"])
            .output()?;

        if !output.status.success() {
            return Err(BlastError::CommandFailed(
                "Failed to list packages".to_string(),
                String::from_utf8_lossy(&output.stderr).to_string(),
            ));
        }

        let packages: Vec<serde_json::Value> = serde_json::from_slice(&output.stdout)?;
        
        let result = packages.into_iter()
            .map(|pkg| {
                let name = pkg["name"].as_str().ok_or_else(|| 
                    BlastError::ParseError("Missing package name".to_string())
                )?.to_string();
                
                let version = pkg["version"].as_str().ok_or_else(|| 
                    BlastError::ParseError("Missing package version".to_string())
                )?.to_string();

                Package::new(
                    name.clone(),
                    version.clone(),
                    create_package_metadata(
                        name,
                        version,
                        HashMap::new(),
                        VersionConstraint::any(),
                    ),
                    VersionConstraint::any(),
                )
            })
            .collect::<Result<Vec<_>, _>>()?;

        Ok(result)
    }

    fn path(&self) -> &PathBuf {
        &self.path
    }

    fn python_version(&self) -> &PythonVersion {
        &self.python_version
    }

    fn set_name(&mut self, name: String) {
        self.name = Some(name);
    }

    fn name(&self) -> Option<&str> {
        self.name.as_deref()
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-core/src/utils.rs

```rs
use std::path::PathBuf;
use std::fs;

use crate::error::{BlastError, BlastResult};

/// Create a directory and all its parent directories
pub fn create_dir_all(path: impl AsRef<std::path::Path>) -> BlastResult<()> {
    fs::create_dir_all(path).map_err(BlastError::from)
}

/// Remove a directory and all its contents
pub fn remove_dir_all(path: impl AsRef<std::path::Path>) -> BlastResult<()> {
    fs::remove_dir_all(path).map_err(BlastError::from)
}

/// Copy a directory recursively
pub fn copy_dir_all(src: impl AsRef<std::path::Path>, dst: impl AsRef<std::path::Path>) -> BlastResult<()> {
    let src = src.as_ref();
    let dst = dst.as_ref();

    if !src.is_dir() {
        return Err(BlastError::InvalidPath(src.to_path_buf()));
    }

    if !dst.exists() {
        create_dir_all(dst)?;
    }

    for entry in fs::read_dir(src)? {
        let entry = entry?;
        let ty = entry.file_type()?;
        let src_path = entry.path();
        let dst_path = dst.join(entry.file_name());

        if ty.is_dir() {
            copy_dir_all(src_path, dst_path)?;
        } else {
            fs::copy(src_path, dst_path)?;
        }
    }

    Ok(())
}

/// Create a hardlink if possible, otherwise copy
pub fn hardlink_or_copy(src: impl AsRef<std::path::Path>, dst: impl AsRef<std::path::Path>) -> BlastResult<()> {
    match fs::hard_link(src.as_ref(), dst.as_ref()) {
        Ok(()) => Ok(()),
        Err(_) => fs::copy(src.as_ref(), dst.as_ref()).map(|_| ()).map_err(BlastError::from),
    }
}

/// Get the size of a directory recursively
pub fn dir_size(path: impl AsRef<std::path::Path>) -> BlastResult<u64> {
    let mut total_size = 0;
    let path = path.as_ref();

    if !path.is_dir() {
        return Err(BlastError::InvalidPath(path.to_path_buf()));
    }

    for entry in fs::read_dir(path)? {
        let entry = entry?;
        let ty = entry.file_type()?;
        if ty.is_file() {
            total_size += entry.metadata()?.len();
        } else if ty.is_dir() {
            total_size += dir_size(entry.path())?;
        }
    }

    Ok(total_size)
}

/// Find Python interpreters in the system
pub fn find_python_interpreters() -> BlastResult<Vec<(PathBuf, String)>> {
    let mut interpreters = Vec::new();

    // Common paths to look for Python
    let paths = if cfg!(windows) {
        vec![
            r"C:\Python*",
            r"C:\Program Files\Python*",
            r"C:\Program Files (x86)\Python*",
        ]
    } else {
        vec![
            "/usr/bin/python*",
            "/usr/local/bin/python*",
            "/opt/python*/bin/python*",
        ]
    };

    for glob_pattern in paths {
        for entry in glob::glob(glob_pattern)? {
            if let Ok(path) = entry {
                if let Ok(version) = get_python_version(&path) {
                    interpreters.push((path, version));
                }
            }
        }
    }

    Ok(interpreters)
}

/// Get Python version from interpreter path
fn get_python_version(path: impl AsRef<std::path::Path>) -> BlastResult<String> {
    use std::process::Command;

    let output = Command::new(path.as_ref())
        .arg("--version")
        .output()
        .map_err(|e| BlastError::python(format!("Failed to execute Python: {}", e)))?;

    if !output.status.success() {
        return Err(BlastError::python("Failed to get Python version"));
    }

    let version = String::from_utf8_lossy(&output.stdout);
    Ok(version.trim().to_string())
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-core/src/version_control.rs

```rs
use std::collections::{HashMap, HashSet};
use chrono::Utc;
use serde::{Deserialize, Serialize};
use tracing::{info, warn};

use crate::error::BlastResult;
use crate::package::Package;
use crate::version::{Version, VersionConstraint};
use crate::python::PythonVersion;
use crate::version_history::{VersionEvent, VersionHistory, VersionImpact, VersionChangeAnalysis};
use crate::metadata::PackageMetadata;

/// Version policy for package upgrades
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VersionPolicy {
    /// Whether to allow major version upgrades
    pub allow_major: bool,
    /// Whether to allow minor version upgrades
    pub allow_minor: bool,
    /// Whether to allow patch version upgrades
    pub allow_patch: bool,
    /// Whether to allow pre-releases
    pub allow_prereleases: bool,
    /// Package-specific version constraints
    pub package_constraints: HashMap<String, VersionConstraint>,
    /// Python version constraints
    pub package_python_constraints: HashMap<String, VersionConstraint>,
}

impl Default for VersionPolicy {
    fn default() -> Self {
        Self {
            allow_major: false,
            allow_minor: true,
            allow_patch: true,
            allow_prereleases: false,
            package_constraints: HashMap::new(),
            package_python_constraints: HashMap::new(),
        }
    }
}

/// Version upgrade strategy
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum UpgradeStrategy {
    /// Never upgrade
    Never,
    /// Only security updates
    SecurityOnly,
    /// Patch versions only
    PatchOnly,
    /// Minor versions and patches
    MinorAndPatch,
    /// All versions including major
    All,
    /// Custom policy
    Custom(VersionPolicy),
}

impl Default for UpgradeStrategy {
    fn default() -> Self {
        Self::MinorAndPatch
    }
}

/// Version manager for tracking and enforcing version policies
#[derive(Debug)]
pub struct VersionManager {
    /// Version histories by package
    histories: HashMap<String, VersionHistory>,
    /// Global version policy
    policy: VersionPolicy,
    /// Package-specific upgrade strategies
    upgrade_strategies: HashMap<String, UpgradeStrategy>,
}

impl VersionManager {
    /// Create new version manager
    pub fn new(policy: VersionPolicy) -> Self {
        Self {
            histories: HashMap::new(),
            policy,
            upgrade_strategies: HashMap::new(),
        }
    }

    /// Get the current version policy
    pub fn policy(&self) -> &VersionPolicy {
        &self.policy
    }

    /// Update the version policy
    pub fn set_policy(&mut self, policy: VersionPolicy) {
        self.policy = policy;
    }

    /// Add package installation
    pub fn add_installation(
        &mut self,
        package: &Package,
        is_direct: bool,
        python_version: &PythonVersion,
        reason: String,
    ) {
        let event = VersionEvent {
            timestamp: Utc::now(),
            from_version: None,
            to_version: package.version().clone(),
            impact: VersionImpact::None,
            reason,
            python_version: python_version.clone(),
            is_direct,
            affected_dependencies: HashMap::new(),
            approved: true,
            approved_by: None,
            policy_snapshot: None,
        };

        self.histories
            .entry(package.name().to_string())
            .or_insert_with(|| VersionHistory::new(package.name().to_string()))
            .add_event(event);
    }

    /// Add package installation with audit
    pub fn add_installation_with_audit(
        &mut self,
        package: &Package,
        is_direct: bool,
        python_version: &PythonVersion,
        reason: String,
        approved_by: Option<String>,
    ) {
        info!(
            "Installing package {} v{} (Python {})",
            package.name(),
            package.version(),
            python_version
        );

        let event = VersionEvent {
            timestamp: Utc::now(),
            from_version: None,
            to_version: package.version().clone(),
            impact: VersionImpact::None,
            reason,
            python_version: python_version.clone(),
            is_direct,
            affected_dependencies: HashMap::new(),
            approved: true,
            approved_by,
            policy_snapshot: Some(format!("{:?}", self.policy)),
        };

        self.histories
            .entry(package.name().to_string())
            .or_insert_with(|| VersionHistory::new(package.name().to_string()))
            .add_event(event);
    }

    /// Check if upgrade is allowed
    pub fn check_upgrade_allowed(
        &self,
        package: &Package,
        target_version: &Version,
    ) -> BlastResult<bool> {
        let strategy = self.upgrade_strategies
            .get(package.name())
            .cloned()
            .unwrap_or_else(|| UpgradeStrategy::Custom(self.policy.clone()));

        match strategy {
            UpgradeStrategy::Never => Ok(false),
            UpgradeStrategy::SecurityOnly => {
                // TODO: Implement security vulnerability checking
                Ok(false)
            }
            UpgradeStrategy::PatchOnly => {
                let impact = VersionImpact::from_version_change(package.version(), target_version);
                Ok(impact == VersionImpact::None)
            }
            UpgradeStrategy::MinorAndPatch => {
                let impact = VersionImpact::from_version_change(package.version(), target_version);
                Ok(impact != VersionImpact::Major)
            }
            UpgradeStrategy::All => Ok(true),
            UpgradeStrategy::Custom(policy) => {
                self.check_policy_allows_upgrade(&policy, package, target_version)
            }
        }
    }

    /// Set upgrade strategy for a package
    pub fn set_upgrade_strategy(&mut self, package_name: String, strategy: UpgradeStrategy) {
        self.upgrade_strategies.insert(package_name, strategy);
    }

    /// Get version history for a package
    pub fn get_history(&self, package_name: &str) -> Option<&VersionHistory> {
        self.histories.get(package_name)
    }

    /// Analyze version change impact
    pub fn analyze_change_impact(
        &self,
        package: &Package,
        target_version: &Version,
    ) -> BlastResult<VersionChangeAnalysis> {
        if let Some(history) = self.histories.get(package.name()) {
            Ok(history.analyze_change_impact(package.version(), target_version))
        } else {
            Ok(VersionChangeAnalysis {
                impact: VersionImpact::from_version_change(package.version(), target_version),
                affected_dependents: HashSet::new(),
                breaking_changes: Vec::new(),
                compatibility_issues: Vec::new(),
            })
        }
    }

    /// Export version history report
    pub fn export_history_report(&self, package_name: &str) -> BlastResult<Option<String>> {
        Ok(self.histories.get(package_name).map(|h| h.generate_report()))
    }

    /// Validate all package versions against current policy
    pub fn validate_all_versions(&self) -> BlastResult<Vec<(String, String)>> {
        let mut violations = Vec::new();

        for (package_name, history) in &self.histories {
            if let Some(current_version) = &history.current_version {
                let version_str = current_version.to_string();
                let package = Package::new(
                    package_name.clone(),
                    version_str.clone(),
                    create_package_metadata(
                        package_name.clone(),
                        version_str,
                        HashMap::new(),
                        VersionConstraint::any(),
                    ),
                    VersionConstraint::any(),
                ).unwrap();

                if let Ok(allowed) = self.check_upgrade_allowed(&package, current_version) {
                    if !allowed {
                        warn!("Package {} version {} violates current policy", package_name, current_version);
                        violations.push((
                            package_name.clone(),
                            format!("Version {} violates current policy", current_version)
                        ));
                    }
                }
            }
        }

        Ok(violations)
    }

    // Helper methods
    fn check_policy_allows_upgrade(
        &self,
        policy: &VersionPolicy,
        package: &Package,
        target_version: &Version,
    ) -> BlastResult<bool> {
        // Check package-specific constraints
        if let Some(constraint) = policy.package_constraints.get(package.name()) {
            if !constraint.matches(target_version) {
                return Ok(false);
            }
        }

        // Check version increment rules
        let impact = VersionImpact::from_version_change(package.version(), target_version);
        match impact {
            VersionImpact::Major if !policy.allow_major => return Ok(false),
            VersionImpact::Minor if !policy.allow_minor => return Ok(false),
            VersionImpact::None if !policy.allow_patch => return Ok(false),
            _ => {}
        }

        // Check pre-release
        if !policy.allow_prereleases && target_version.as_semver().pre.len() > 0 {
            return Ok(false);
        }

        Ok(true)
    }

    pub fn analyze_version_change(&self, from: &Version, to: &Version) -> VersionChangeAnalysis {
        let mut analysis = VersionChangeAnalysis {
            impact: VersionImpact::from_version_change(from, to),
            affected_dependents: HashSet::new(),
            breaking_changes: Vec::new(),
            compatibility_issues: Vec::new(),
        };

        // Check for breaking changes
        if analysis.impact.is_breaking() {
            analysis.breaking_changes.push(format!(
                "Breaking version change from {} to {} may introduce breaking changes",
                from, to
            ));
        }

        // Get version history for the package
        if let Some(history) = self.histories.values().next() {
            // Check dependent packages
            for dependent in history.get_dependents() {
                if let Some(req) = history.get_requirements().get(dependent) {
                    if !VersionConstraint::parse(req).unwrap().matches(to) {
                        analysis.affected_dependents.insert(dependent.clone());
                        analysis.compatibility_issues.push(format!(
                            "Package {} requires version {}, which is incompatible with {}",
                            dependent, req, to
                        ));
                    }
                }
            }
        }

        analysis
    }
}

// Helper function to create package metadata from dependencies
fn create_package_metadata(
    name: String,
    version: String,
    dependencies: HashMap<String, VersionConstraint>,
    python_version: VersionConstraint,
) -> PackageMetadata {
    PackageMetadata::new(
        name,
        version,
        dependencies,
        python_version,
    )
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-image/Cargo.toml

```toml
[package]
name = "blast-image"
version = "0.1.0"
edition = "2021"
authors = ["Blast Contributors"]
description = "Image management for the Blast Python environment manager"
license = "MIT"

[dependencies]
# Internal dependencies
blast-core = { path = "../blast-core", features = ["serde-support"] }
blast-cache = { path = "../blast-cache" }

# Version handling
semver = { workspace = true }

# Async runtime
tokio = { version = "1.0", features = ["fs"] }
async-trait = { workspace = true }

# Error handling
thiserror = "1.0"
anyhow = "1.0"

# Serialization
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# Logging
tracing = "0.1"
tracing-subscriber = { workspace = true }

# Compression
zstd = "0.13"
flate2 = "1.0"
tar = "0.4"

# Hashing
blake3 = "1.5"
sha2 = "0.10"

# Filesystem
walkdir = "2.4"
tempfile = "3.8"

# Time
chrono = { version = "0.4", features = ["serde"] }

# TOML
toml = "0.8"

# URL
url = { version = "2.5", features = ["serde"] }

[dev-dependencies]
proptest = { workspace = true }
tempfile = "3.8"
tokio-test = "0.4"
assert_fs = "1.0"

[features]
default = []
gpu = [] 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-image/src/packages.rs

```rs
//! Package management and dependencies
//! 
//! This module provides functionality for managing Python packages,
//! dependencies, and package indexes.

use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};
use url::Url;

/// Package dependency information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PackageDependency {
    /// Package name
    pub name: String,
    /// Version specification
    pub version_spec: String,
    /// Optional extras
    pub extras: HashSet<String>,
    /// Whether this is a direct dependency
    pub is_direct: bool,
    /// Package hash (if available)
    pub hash: Option<String>,
    /// Package URL
    pub url: Option<String>,
    /// Build tags
    pub build_tags: Vec<String>,
    /// Platform tags
    pub platform_tags: Vec<String>,
}

/// Package index configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PackageIndex {
    /// Index URL
    pub url: Url,
    /// Index name
    pub name: String,
    /// Whether this is a trusted index
    pub trusted: bool,
    /// Authentication credentials (if required)
    pub credentials: Option<IndexCredentials>,
    /// Index priority (lower is higher priority)
    pub priority: i32,
}

/// Package index credentials
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IndexCredentials {
    /// Username
    pub username: Option<String>,
    /// Password
    pub password: Option<String>,
    /// API token
    pub token: Option<String>,
}

/// Package manager configuration
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct PackageConfig {
    /// Package indexes
    pub indexes: Vec<PackageIndex>,
    /// Direct dependencies
    pub direct_dependencies: HashMap<String, PackageDependency>,
    /// Transitive dependencies
    pub transitive_dependencies: HashMap<String, PackageDependency>,
    /// Build isolation
    pub build_isolation: bool,
    /// Use user site packages
    pub use_user_site: bool,
    /// Cache directory
    pub cache_dir: Option<String>,
    /// Build directory
    pub build_dir: Option<String>,
}

impl PackageConfig {
    /// Create new package configuration
    pub fn new() -> Self {
        Self::default()
    }

    /// Add a package index
    pub fn add_index(&mut self, index: PackageIndex) {
        // Sort indexes by priority after adding
        self.indexes.push(index);
        self.indexes.sort_by_key(|idx| idx.priority);
    }

    /// Add a direct dependency
    pub fn add_direct_dependency(&mut self, dependency: PackageDependency) {
        self.direct_dependencies.insert(dependency.name.clone(), dependency);
    }

    /// Add a transitive dependency
    pub fn add_transitive_dependency(&mut self, dependency: PackageDependency) {
        self.transitive_dependencies.insert(dependency.name.clone(), dependency);
    }

    /// Get all dependencies (direct and transitive)
    pub fn all_dependencies(&self) -> HashMap<String, &PackageDependency> {
        let mut all = HashMap::new();
        
        // Add direct dependencies
        for (name, dep) in &self.direct_dependencies {
            all.insert(name.clone(), dep);
        }
        
        // Add transitive dependencies
        for (name, dep) in &self.transitive_dependencies {
            if !all.contains_key(name) {
                all.insert(name.clone(), dep);
            }
        }
        
        all
    }

    /// Get dependency tree
    pub fn dependency_tree(&self) -> DependencyTree {
        let mut tree = DependencyTree::new();
        
        // Add direct dependencies as roots
        for dep in self.direct_dependencies.values() {
            tree.add_dependency(dep.clone(), None);
        }
        
        // Add transitive dependencies
        for dep in self.transitive_dependencies.values() {
            // Find parent dependency
            if let Some(parent) = self.find_parent_dependency(dep) {
                tree.add_dependency(dep.clone(), Some(parent.clone()));
            }
        }
        
        tree
    }

    /// Find parent dependency for a transitive dependency
    fn find_parent_dependency(&self, dep: &PackageDependency) -> Option<PackageDependency> {
        // This is a simplified implementation
        // In reality, we would need to parse requirements and build a proper dependency graph
        self.direct_dependencies.values()
            .find(|d| d.name < dep.name)
            .cloned()
    }
}

/// Dependency tree node
#[derive(Debug, Clone)]
struct DependencyNode {
    dependency: PackageDependency,
    children: Vec<DependencyNode>,
}

/// Dependency tree
#[derive(Debug, Clone)]
pub struct DependencyTree {
    roots: Vec<DependencyNode>,
}

impl DependencyTree {
    /// Create new dependency tree
    fn new() -> Self {
        Self {
            roots: Vec::new(),
        }
    }

    /// Add a dependency to the tree
    fn add_dependency(&mut self, dependency: PackageDependency, parent: Option<PackageDependency>) {
        let node = DependencyNode {
            dependency,
            children: Vec::new(),
        };

        if let Some(parent) = parent {
            // Find parent node and add as child
            self.add_to_parent(&parent, node);
        } else {
            // Add as root
            self.roots.push(node);
        }
    }

    /// Add node to parent
    fn add_to_parent(&mut self, parent: &PackageDependency, node: DependencyNode) {
        // Recursive helper
        fn add_to_node(current: &mut DependencyNode, parent: &PackageDependency, node: DependencyNode) {
            if current.dependency.name == parent.name {
                current.children.push(node);
            } else {
                for child in &mut current.children {
                    add_to_node(child, parent, node.clone());
                }
            }
        }

        // Try to add to each root
        for root in &mut self.roots {
            add_to_node(root, parent, node.clone());
        }
    }

    /// Print tree
    pub fn print(&self) -> String {
        let mut output = String::new();
        
        for root in &self.roots {
            self.print_node(root, 0, &mut output);
        }
        
        output
    }

    /// Print node
    fn print_node(&self, node: &DependencyNode, depth: usize, output: &mut String) {
        let indent = "  ".repeat(depth);
        output.push_str(&format!("{}{} {}\n", 
            indent,
            node.dependency.name,
            node.dependency.version_spec
        ));
        
        for child in &node.children {
            self.print_node(child, depth + 1, output);
        }
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-image/src/compression.rs

```rs
use std::io::{self, Write};
use serde::{Deserialize, Serialize};
use zstd::stream::{Encoder, Decoder};
use flate2::write::GzEncoder;
use flate2::read::GzDecoder;
use flate2::Compression;

use crate::error::{Error, Result};

/// Compression types supported by Blast
#[derive(Debug, Clone, Eq, PartialEq, Serialize, Deserialize)]
pub enum CompressionType {
    /// No compression
    None,
    /// Zstandard compression
    Zstd,
    /// GZIP compression
    Gzip,
}

/// Compression level for layer storage
#[derive(Debug, Clone, Copy, Eq, PartialEq, Serialize, Deserialize)]
pub enum CompressionLevel {
    /// No compression
    None,
    /// Fast compression
    Fast,
    /// Default compression
    Default,
    /// Maximum compression
    Best,
}

impl CompressionLevel {
    /// Convert to zstd compression level
    pub fn to_zstd_level(&self) -> i32 {
        match self {
            Self::None => 0,
            Self::Fast => 1,
            Self::Default => 3,
            Self::Best => 19,
        }
    }

    /// Convert to gzip compression level
    pub fn to_gzip_level(&self) -> u32 {
        match self {
            Self::None => 0,
            Self::Fast => 1,
            Self::Default => 6,
            Self::Best => 9,
        }
    }
}

/// Compression strategy trait
pub trait CompressionStrategy: Send + Sync {
    /// Compress data
    fn compress(&self, data: &[u8]) -> Result<Vec<u8>>;
    
    /// Decompress data
    fn decompress(&self, data: &[u8]) -> Result<Vec<u8>>;
    
    /// Get compression type
    fn compression_type(&self) -> CompressionType;
    
    /// Get compression level
    fn compression_level(&self) -> CompressionLevel;
}

/// Zstandard compression strategy
pub struct ZstdStrategy {
    level: CompressionLevel,
}

impl ZstdStrategy {
    /// Create a new Zstd strategy with the given compression level
    pub fn new(level: CompressionLevel) -> Self {
        Self { level }
    }
}

impl CompressionStrategy for ZstdStrategy {
    fn compress(&self, data: &[u8]) -> Result<Vec<u8>> {
        let mut encoder = Encoder::new(Vec::new(), self.level.to_zstd_level())
            .map_err(|e| Error::Io { source: e, path: None })?;
        encoder.write_all(data)
            .map_err(|e| Error::Io { source: e, path: None })?;
        Ok(encoder.finish()
            .map_err(|e| Error::Io { source: e, path: None })?)
    }

    fn decompress(&self, data: &[u8]) -> Result<Vec<u8>> {
        let mut decoder = Decoder::new(data)
            .map_err(|e| Error::Io { source: e, path: None })?;
        let mut decompressed = Vec::new();
        io::copy(&mut decoder, &mut decompressed)
            .map_err(|e| Error::Io { source: e, path: None })?;
        Ok(decompressed)
    }

    fn compression_type(&self) -> CompressionType {
        CompressionType::Zstd
    }

    fn compression_level(&self) -> CompressionLevel {
        self.level
    }
}

/// GZIP compression strategy
pub struct GzipStrategy {
    level: CompressionLevel,
}

impl GzipStrategy {
    /// Create a new GZIP strategy with the given compression level
    pub fn new(level: CompressionLevel) -> Self {
        Self { level }
    }
}

impl CompressionStrategy for GzipStrategy {
    fn compress(&self, data: &[u8]) -> Result<Vec<u8>> {
        let mut encoder = GzEncoder::new(Vec::new(), Compression::new(self.level.to_gzip_level()));
        encoder.write_all(data)?;
        Ok(encoder.finish()?)
    }

    fn decompress(&self, data: &[u8]) -> Result<Vec<u8>> {
        let mut decoder = GzDecoder::new(data);
        let mut decompressed = Vec::new();
        io::copy(&mut decoder, &mut decompressed)?;
        Ok(decompressed)
    }

    fn compression_type(&self) -> CompressionType {
        CompressionType::Gzip
    }

    fn compression_level(&self) -> CompressionLevel {
        self.level
    }
}

/// Create a compression strategy for the given type and level
pub fn create_strategy(
    compression_type: CompressionType,
    level: CompressionLevel,
) -> Box<dyn CompressionStrategy> {
    match compression_type {
        CompressionType::None => Box::new(NoopStrategy),
        CompressionType::Zstd => Box::new(ZstdStrategy::new(level)),
        CompressionType::Gzip => Box::new(GzipStrategy::new(level)),
    }
}

/// No-op compression strategy
#[derive(Default)]
pub struct NoopStrategy;

impl CompressionStrategy for NoopStrategy {
    fn compress(&self, data: &[u8]) -> Result<Vec<u8>> {
        Ok(data.to_vec())
    }

    fn decompress(&self, data: &[u8]) -> Result<Vec<u8>> {
        Ok(data.to_vec())
    }

    fn compression_type(&self) -> CompressionType {
        CompressionType::None
    }

    fn compression_level(&self) -> CompressionLevel {
        CompressionLevel::None
    }
}

/// Calculate compression ratio
pub fn compression_ratio(original_size: u64, compressed_size: u64) -> f64 {
    if original_size == 0 {
        return 1.0;
    }
    compressed_size as f64 / original_size as f64
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-image/src/error.rs

```rs
use std::io;
use std::path::PathBuf;
use thiserror::Error;

/// Error type for blast-image operations
#[derive(Debug, Error)]
pub enum Error {
    #[error("IO error: {source}")]
    Io {
        source: io::Error,
        path: Option<PathBuf>,
    },

    #[error("Serialization error: {message}")]
    Serialization {
        message: String,
        #[source]
        source: Option<Box<dyn std::error::Error + Send + Sync>>,
    },

    #[error("Validation error: {message}")]
    Validation {
        message: String,
        code: Option<String>,
    },

    #[error("Platform error: {message}")]
    Platform {
        message: String,
        platform: Option<String>,
    },

    #[error("Layer error: {message}")]
    Layer {
        message: String,
        layer: Option<String>,
    },

    #[error("Package error: {message}")]
    Package {
        message: String,
        package: Option<String>,
    },

    #[error("Compression error: {message}")]
    Compression {
        message: String,
        #[source]
        source: Option<Box<dyn std::error::Error + Send + Sync>>,
    },

    #[error("Configuration error: {message}")]
    Config {
        message: String,
        key: Option<String>,
    },

    #[error(transparent)]
    Other(#[from] Box<dyn std::error::Error + Send + Sync>),
}

impl From<io::Error> for Error {
    fn from(error: io::Error) -> Self {
        Self::Io {
            source: error,
            path: None,
        }
    }
}

impl Error {
    /// Create a new IO error with path
    pub fn io(source: io::Error, path: impl Into<PathBuf>) -> Self {
        Self::Io {
            source,
            path: Some(path.into()),
        }
    }

    /// Create a new serialization error
    pub fn serialization(message: impl Into<String>) -> Self {
        Self::Serialization {
            message: message.into(),
            source: None,
        }
    }

    /// Create a new serialization error with source
    pub fn serialization_with_source(
        message: impl Into<String>,
        source: impl Into<Box<dyn std::error::Error + Send + Sync>>,
    ) -> Self {
        Self::Serialization {
            message: message.into(),
            source: Some(source.into()),
        }
    }

    /// Create a new validation error
    pub fn validation(message: impl Into<String>) -> Self {
        Self::Validation {
            message: message.into(),
            code: None,
        }
    }

    /// Create a new validation error with code
    pub fn validation_with_code(message: impl Into<String>, code: impl Into<String>) -> Self {
        Self::Validation {
            message: message.into(),
            code: Some(code.into()),
        }
    }

    /// Create a new platform error
    pub fn platform(message: impl Into<String>) -> Self {
        Self::Platform {
            message: message.into(),
            platform: None,
        }
    }

    /// Create a new platform error with platform info
    pub fn platform_with_info(message: impl Into<String>, platform: impl Into<String>) -> Self {
        Self::Platform {
            message: message.into(),
            platform: Some(platform.into()),
        }
    }

    /// Create a new layer error
    pub fn layer(message: impl Into<String>) -> Self {
        Self::Layer {
            message: message.into(),
            layer: None,
        }
    }

    /// Create a new layer error with layer name
    pub fn layer_with_name(message: impl Into<String>, layer: impl Into<String>) -> Self {
        Self::Layer {
            message: message.into(),
            layer: Some(layer.into()),
        }
    }

    /// Create a new package error
    pub fn package(message: impl Into<String>) -> Self {
        Self::Package {
            message: message.into(),
            package: None,
        }
    }

    /// Create a new package error with package name
    pub fn package_with_name(message: impl Into<String>, package: impl Into<String>) -> Self {
        Self::Package {
            message: message.into(),
            package: Some(package.into()),
        }
    }

    /// Create a new compression error
    pub fn compression(message: impl Into<String>) -> Self {
        Self::Compression {
            message: message.into(),
            source: None,
        }
    }

    /// Create a new compression error with source
    pub fn compression_with_source(
        message: impl Into<String>,
        source: impl Into<Box<dyn std::error::Error + Send + Sync>>,
    ) -> Self {
        Self::Compression {
            message: message.into(),
            source: Some(source.into()),
        }
    }

    /// Create a new configuration error
    pub fn config(message: impl Into<String>) -> Self {
        Self::Config {
            message: message.into(),
            key: None,
        }
    }

    /// Create a new configuration error with key
    pub fn config_with_key(message: impl Into<String>, key: impl Into<String>) -> Self {
        Self::Config {
            message: message.into(),
            key: Some(key.into()),
        }
    }
}

/// Result type for blast-image operations
pub type Result<T> = std::result::Result<T, Error>; 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-image/src/metadata.rs

```rs
 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-image/src/lib.rs

```rs
//! Blast Image Management Library
//! 
//! This library provides functionality for managing Python environment images,
//! including creation, validation, and metadata management.

pub mod platform;
pub mod hooks;
pub mod validation;
pub mod packages;
pub mod layer;
pub mod compression;
pub mod error;

pub use platform::{PlatformInfo, PlatformRequirements, GpuRequirements};
pub use hooks::{EnvironmentHooks, PathModifications};
pub use validation::{
    ImageValidator, ValidationResult, ValidationError, ValidationWarning,
    ValidationOptions, ValidationErrorCode, ValidationWarningCode,
};
pub use packages::{
    PackageConfig, PackageDependency, PackageIndex, IndexCredentials,
    DependencyTree,
};
pub use layer::{Layer, LayerType, LayerMetadata};
pub use compression::{
    CompressionType, CompressionLevel, CompressionStrategy,
    compression_ratio, create_strategy,
};
pub use error::{Error, Result};

// Re-export manifest types from blast-core
pub use blast_core::manifest::{
    Manifest, BlastMetadata, SystemDependency, ResourceRequirements,
    VenvConfig, LayerInfo,
};

// Re-export commonly used types
pub use chrono;
pub use blake3;
pub use serde;
pub use url;

// Version information
pub const VERSION: &str = env!("CARGO_PKG_VERSION");
pub const MIN_COMPATIBLE_VERSION: &str = "0.1.0";

use blast_core::Version;

/// Check if two versions are compatible
pub fn is_compatible_version(version: &str) -> bool {
    if let Ok(version) = Version::parse(version) {
        let version_str = version.to_string();
        let parts: Vec<&str> = version_str.split('.').collect();
        parts.get(0).map_or(false, |major| *major == "0") &&
        parts.get(1).map_or(false, |minor| *minor == "1")
    } else {
        false
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-image/src/manifest.rs

```rs
//! Image manifest handling
//! 
//! This module provides functionality for managing image manifests,
//! including metadata, layer information, and environment configuration.

use std::path::{Path, PathBuf};
use std::collections::HashMap;
use std::fs;

use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};

use blast_core::error::{BlastError, BlastResult};
use blast_core::python::{PythonEnvironment, PythonVersion};
use blast_core::security::SecurityPolicy;

use crate::layer::{Layer, LayerType, CompressionType};
use crate::platform::PlatformRequirements;
use crate::hooks::EnvironmentHooks;
use crate::packages::PackageIndex;

/// Comprehensive metadata for Blast environments
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BlastMetadata {
    /// Image name
    pub name: String,
    /// Image version
    pub version: String,
    /// Creation timestamp
    pub created_at: DateTime<Utc>,
    /// Last modified timestamp
    pub modified_at: DateTime<Utc>,
    /// Python version with exact patch level
    pub python_version: PythonVersion,
    /// Author information
    pub author: Option<String>,
    /// Description
    pub description: Option<String>,
    /// License
    pub license: Option<String>,
    /// Environment variables required
    pub env_vars: HashMap<String, String>,
    /// Tags for categorization
    pub tags: Vec<String>,
    /// Direct dependencies with exact versions
    pub dependencies: HashMap<String, String>,
    /// All transitive dependencies with versions
    pub transitive_deps: HashMap<String, String>,
    /// System packages required (apt, brew, etc)
    pub system_deps: Vec<SystemDependency>,
    /// Platform requirements
    pub platform: PlatformRequirements,
    /// Security policy
    #[serde(skip)]
    pub security_policy: SecurityPolicy,
    /// Resource requirements
    pub resources: ResourceRequirements,
    /// Python package index URLs
    pub package_indexes: Vec<PackageIndex>,
    /// Environment hooks (pre/post activation)
    pub hooks: EnvironmentHooks,
    /// Virtual environment configuration
    pub venv_config: VenvConfig,
    /// Content hash for integrity verification
    pub content_hash: String,
    /// Custom metadata
    pub custom: HashMap<String, String>,
    /// Image layers information
    pub layers: Vec<LayerInfo>,
}

/// System dependency information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SystemDependency {
    /// Package name
    pub name: String,
    /// Version constraint
    pub version: String,
    /// Package manager (apt, brew, etc)
    pub package_manager: String,
    /// Installation commands if custom
    pub install_commands: Option<Vec<String>>,
}

/// Resource requirements for the environment
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceRequirements {
    /// Maximum memory usage
    pub max_memory: u64,
    /// Maximum disk usage
    pub max_disk: u64,
    /// CPU usage limits
    pub cpu_limit: Option<f64>,
    /// Network bandwidth limits
    pub network_limit: Option<u64>,
    /// Maximum number of processes
    pub max_processes: u32,
    /// Temporary storage requirements
    pub temp_storage: u64,
}

/// Virtual environment configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VenvConfig {
    /// Python executable path
    pub python_path: PathBuf,
    /// Site-packages directory
    pub site_packages: PathBuf,
    /// Include system site-packages
    pub system_site_packages: bool,
    /// Prompt prefix
    pub prompt: String,
    /// Additional paths to add to PYTHONPATH
    pub python_path_additions: Vec<PathBuf>,
    /// Symlinks to create
    pub symlinks: HashMap<PathBuf, PathBuf>,
}

/// Layer information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LayerInfo {
    /// Layer ID
    pub id: String,
    /// Layer type (base, packages, etc.)
    pub layer_type: LayerType,
    /// Layer size in bytes
    pub size: u64,
    /// Layer compression type
    pub compression: CompressionType,
    /// Layer hash for integrity verification
    pub hash: String,
    /// Layer creation timestamp
    pub created_at: DateTime<Utc>,
}

/// Image manifest
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Manifest {
    /// Manifest metadata
    pub metadata: BlastMetadata,
    /// Installed packages with versions
    pub packages: Vec<String>,
    /// Manifest format version
    pub format_version: String,
}

impl Manifest {
    /// Create a new manifest from a Python environment
    pub fn from_environment(env: &PythonEnvironment) -> BlastResult<Self> {
        let metadata = BlastMetadata::new(
            env.name().unwrap_or("unnamed").to_string(),
            env.python_version().clone(),
            SecurityPolicy::default(),
        );

        Ok(Self {
            metadata,
            packages: Vec::new(),
            format_version: env!("CARGO_PKG_VERSION").to_string(),
        })
    }

    /// Save manifest to a file
    pub fn save<P: AsRef<Path>>(&self, path: P) -> BlastResult<()> {
        let content = toml::to_string_pretty(self)
            .map_err(|e| BlastError::serialization(e.to_string()))?;
        fs::write(path, content)?;
        Ok(())
    }

    /// Load manifest from a file
    pub fn load<P: AsRef<Path>>(path: P) -> BlastResult<Self> {
        let content = fs::read_to_string(path)?;
        toml::from_str(&content)
            .map_err(|e| BlastError::serialization(e.to_string()))
    }

    /// Convert manifest to a Python environment
    pub fn to_environment(&self, target_path: &PathBuf) -> BlastResult<PythonEnvironment> {
        let env = PythonEnvironment::new(
            target_path.clone(),
            self.metadata.python_version.clone(),
        );

        // TODO: Apply environment configuration from manifest
        Ok(env)
    }

    /// Add a layer to the manifest
    pub fn add_layer(&mut self, layer: &Layer) {
        self.metadata.layers.push(LayerInfo {
            id: layer.name.clone(),
            layer_type: LayerType::Base, // TODO: Determine layer type
            size: layer.metadata.original_size,
            compression: CompressionType::Zstd,
            hash: layer.metadata.hash.clone(),
            created_at: layer.metadata.created_at,
        });
    }

    /// Add environment variables
    pub fn add_env_vars(&mut self, vars: HashMap<String, String>) {
        self.metadata.env_vars.extend(vars);
    }

    /// Add tags
    pub fn add_tags(&mut self, tags: Vec<String>) {
        self.metadata.tags.extend(tags);
    }

    /// Add custom metadata
    pub fn add_custom_metadata(&mut self, metadata: HashMap<String, String>) {
        self.metadata.custom.extend(metadata);
    }

    /// Get total size of all layers
    pub fn total_size(&self) -> u64 {
        self.metadata.layers.iter().map(|l| l.size).sum()
    }

    /// Record a package installation
    pub fn record_package_install(&mut self, package_name: String, version: String) {
        self.packages.push(format!("{}=={}", package_name, version));
        self.metadata.dependencies.insert(package_name, version);
        self.metadata.modified_at = Utc::now();
        self.metadata.update_hash();
    }

    /// Record package removal
    pub fn record_package_removal(&mut self, package_name: &str) {
        self.packages.retain(|p| !p.starts_with(&format!("{}==", package_name)));
        self.metadata.dependencies.remove(package_name);
        self.metadata.modified_at = Utc::now();
        self.metadata.update_hash();
    }

    /// Record environment variable change
    pub fn record_env_var_change(&mut self, key: String, value: String) {
        self.metadata.env_vars.insert(key, value);
        self.metadata.modified_at = Utc::now();
        self.metadata.update_hash();
    }

    /// Record system dependency
    pub fn record_system_dependency(&mut self, dependency: SystemDependency) {
        self.metadata.system_deps.push(dependency);
        self.metadata.modified_at = Utc::now();
        self.metadata.update_hash();
    }

    /// Update platform requirements
    pub fn update_platform_requirements(&mut self, requirements: PlatformRequirements) {
        self.metadata.platform = requirements;
        self.metadata.modified_at = Utc::now();
        self.metadata.update_hash();
    }

    /// Record hook addition
    pub fn record_hook_addition(&mut self, hook_type: &str, command: String) {
        match hook_type {
            "pre-activate" => self.metadata.hooks.add_pre_activate(command),
            "post-activate" => self.metadata.hooks.add_post_activate(command),
            "pre-deactivate" => self.metadata.hooks.add_pre_deactivate(command),
            "post-deactivate" => self.metadata.hooks.add_post_deactivate(command),
            _ => return,
        }
        self.metadata.modified_at = Utc::now();
        self.metadata.update_hash();
    }

    /// Get package version
    pub fn get_package_version(&self, package_name: &str) -> Option<&String> {
        self.metadata.dependencies.get(package_name)
    }

    /// Check if package is installed
    pub fn has_package(&self, package_name: &str) -> bool {
        self.metadata.dependencies.contains_key(package_name)
    }

    /// Get all installed packages with versions
    pub fn get_installed_packages(&self) -> &Vec<String> {
        &self.packages
    }

    /// Get direct dependencies only
    pub fn get_direct_dependencies(&self) -> HashMap<String, String> {
        self.metadata.dependencies.clone()
    }

    /// Get transitive dependencies
    pub fn get_transitive_dependencies(&self) -> HashMap<String, String> {
        self.metadata.transitive_deps.clone()
    }

    /// Record transitive dependency
    pub fn record_transitive_dependency(&mut self, package_name: String, version: String) {
        self.metadata.transitive_deps.insert(package_name, version);
        self.metadata.modified_at = Utc::now();
        self.metadata.update_hash();
    }
}

impl BlastMetadata {
    /// Create new metadata
    pub fn new(name: String, python_version: PythonVersion, security_policy: SecurityPolicy) -> Self {
        Self {
            name,
            version: "0.1.0".to_string(),
            created_at: Utc::now(),
            modified_at: Utc::now(),
            python_version,
            author: None,
            description: None,
            license: None,
            env_vars: HashMap::new(),
            tags: Vec::new(),
            dependencies: HashMap::new(),
            transitive_deps: HashMap::new(),
            system_deps: Vec::new(),
            platform: PlatformRequirements::default(),
            security_policy,
            resources: ResourceRequirements::default(),
            package_indexes: Vec::new(),
            hooks: EnvironmentHooks::default(),
            venv_config: VenvConfig::default(),
            content_hash: String::new(),
            custom: HashMap::new(),
            layers: Vec::new(),
        }
    }

    /// Save metadata to a file
    pub fn save<P: AsRef<Path>>(&self, path: P) -> BlastResult<()> {
        let content = toml::to_string_pretty(self)
            .map_err(|e| BlastError::serialization(e.to_string()))?;
        fs::write(path.as_ref().join("blast.toml"), content)?;
        Ok(())
    }

    /// Load metadata from a file
    pub fn load<P: AsRef<Path>>(path: P) -> BlastResult<Self> {
        let content = fs::read_to_string(path.as_ref().join("blast.toml"))?;
        toml::from_str(&content)
            .map_err(|e| BlastError::serialization(e.to_string()))
    }

    /// Update content hash
    pub fn update_hash(&mut self) {
        let mut hasher = blake3::Hasher::new();
        hasher.update(self.name.as_bytes());
        hasher.update(self.version.as_bytes());
        hasher.update(self.python_version.to_string().as_bytes());
        
        for layer in &self.layers {
            hasher.update(layer.hash.as_bytes());
        }

        self.content_hash = hasher.finalize().to_hex().to_string();
    }

    /// Verify metadata integrity
    pub fn verify(&self) -> BlastResult<bool> {
        let mut temp = self.clone();
        temp.update_hash();
        Ok(temp.content_hash == self.content_hash)
    }
}

impl Default for ResourceRequirements {
    fn default() -> Self {
        Self {
            max_memory: 1024 * 1024 * 1024 * 2, // 2GB
            max_disk: 1024 * 1024 * 1024 * 10,  // 10GB
            cpu_limit: None,
            network_limit: None,
            max_processes: 32,
            temp_storage: 1024 * 1024 * 512,    // 512MB
        }
    }
}

impl Default for VenvConfig {
    fn default() -> Self {
        Self {
            python_path: PathBuf::from("bin/python"),
            site_packages: PathBuf::from("lib/python/site-packages"),
            system_site_packages: false,
            prompt: "(.venv)".to_string(),
            python_path_additions: Vec::new(),
            symlinks: HashMap::new(),
        }
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-image/src/hooks.rs

```rs
//! Environment hooks management
//! 
//! This module provides functionality for managing environment hooks that are
//! executed during environment activation and deactivation.

use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Environment hooks configuration
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct EnvironmentHooks {
    /// Commands to run before environment activation
    pub pre_activate: Vec<String>,
    /// Commands to run after environment activation
    pub post_activate: Vec<String>,
    /// Commands to run before environment deactivation
    pub pre_deactivate: Vec<String>,
    /// Commands to run after environment deactivation
    pub post_deactivate: Vec<String>,
    /// Environment variables to set during activation
    pub env_vars: HashMap<String, String>,
    /// Path modifications (prepend/append)
    pub path_modifications: PathModifications,
}

/// Path modifications for environment
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct PathModifications {
    /// Paths to prepend to PATH
    pub prepend_path: Vec<String>,
    /// Paths to append to PATH
    pub append_path: Vec<String>,
    /// Paths to prepend to PYTHONPATH
    pub prepend_python_path: Vec<String>,
    /// Paths to append to PYTHONPATH
    pub append_python_path: Vec<String>,
}

impl EnvironmentHooks {
    /// Create new environment hooks
    pub fn new() -> Self {
        Self::default()
    }

    /// Add a pre-activation hook
    pub fn add_pre_activate(&mut self, command: String) {
        self.pre_activate.push(command);
    }

    /// Add a post-activation hook
    pub fn add_post_activate(&mut self, command: String) {
        self.post_activate.push(command);
    }

    /// Add a pre-deactivation hook
    pub fn add_pre_deactivate(&mut self, command: String) {
        self.pre_deactivate.push(command);
    }

    /// Add a post-deactivation hook
    pub fn add_post_deactivate(&mut self, command: String) {
        self.post_deactivate.push(command);
    }

    /// Set an environment variable
    pub fn set_env_var(&mut self, key: String, value: String) {
        self.env_vars.insert(key, value);
    }

    /// Add a PATH prepend directory
    pub fn prepend_path(&mut self, path: String) {
        self.path_modifications.prepend_path.push(path);
    }

    /// Add a PATH append directory
    pub fn append_path(&mut self, path: String) {
        self.path_modifications.append_path.push(path);
    }

    /// Add a PYTHONPATH prepend directory
    pub fn prepend_python_path(&mut self, path: String) {
        self.path_modifications.prepend_python_path.push(path);
    }

    /// Add a PYTHONPATH append directory
    pub fn append_python_path(&mut self, path: String) {
        self.path_modifications.append_python_path.push(path);
    }

    /// Generate activation script
    pub fn generate_activation_script(&self) -> String {
        let mut script = String::new();

        // Add pre-activation hooks
        for cmd in &self.pre_activate {
            script.push_str(&format!("{}\n", cmd));
        }

        // Set environment variables
        for (key, value) in &self.env_vars {
            script.push_str(&format!("export {}={}\n", key, value));
        }

        // Modify PATH
        if !self.path_modifications.prepend_path.is_empty() {
            let paths = self.path_modifications.prepend_path.join(":");
            script.push_str(&format!("export PATH={}:$PATH\n", paths));
        }
        if !self.path_modifications.append_path.is_empty() {
            let paths = self.path_modifications.append_path.join(":");
            script.push_str(&format!("export PATH=$PATH:{}\n", paths));
        }

        // Modify PYTHONPATH
        if !self.path_modifications.prepend_python_path.is_empty() {
            let paths = self.path_modifications.prepend_python_path.join(":");
            script.push_str(&format!("export PYTHONPATH={}:$PYTHONPATH\n", paths));
        }
        if !self.path_modifications.append_python_path.is_empty() {
            let paths = self.path_modifications.append_python_path.join(":");
            script.push_str(&format!("export PYTHONPATH=$PYTHONPATH:{}\n", paths));
        }

        // Add post-activation hooks
        for cmd in &self.post_activate {
            script.push_str(&format!("{}\n", cmd));
        }

        script
    }

    /// Generate deactivation script
    pub fn generate_deactivation_script(&self) -> String {
        let mut script = String::new();

        // Add pre-deactivation hooks
        for cmd in &self.pre_deactivate {
            script.push_str(&format!("{}\n", cmd));
        }

        // Unset environment variables
        for key in self.env_vars.keys() {
            script.push_str(&format!("unset {}\n", key));
        }

        // Add post-deactivation hooks
        for cmd in &self.post_deactivate {
            script.push_str(&format!("{}\n", cmd));
        }

        script
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-image/src/validation.rs

```rs
//! Image validation and integrity checks
//! 
//! This module provides functionality for validating image contents,
//! checking integrity of layers, and verifying metadata consistency.

use blake3::Hash;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::Path;

/// Validation result containing success/failure status and details
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValidationResult {
    /// Whether validation passed
    pub is_valid: bool,
    /// List of validation errors if any
    pub errors: Vec<ValidationError>,
    /// List of validation warnings if any
    pub warnings: Vec<ValidationWarning>,
    /// Validation metadata
    pub metadata: ValidationMetadata,
}

/// Validation error details
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValidationError {
    /// Error code
    pub code: ValidationErrorCode,
    /// Error message
    pub message: String,
    /// Error context/details
    pub context: HashMap<String, String>,
}

/// Validation warning details
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValidationWarning {
    /// Warning code
    pub code: ValidationWarningCode,
    /// Warning message
    pub message: String,
    /// Warning context/details
    pub context: HashMap<String, String>,
}

/// Validation metadata
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ValidationMetadata {
    /// Timestamp of validation
    pub timestamp: chrono::DateTime<chrono::Utc>,
    /// Duration of validation
    pub duration: std::time::Duration,
    /// Number of files checked
    pub files_checked: usize,
    /// Total size of files checked
    pub total_size: u64,
}

/// Validation error codes
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ValidationErrorCode {
    /// Missing required file
    MissingFile,
    /// Invalid file hash
    InvalidHash,
    /// Invalid metadata
    InvalidMetadata,
    /// Invalid layer
    InvalidLayer,
    /// Invalid dependencies
    InvalidDependencies,
    /// Invalid platform requirements
    InvalidPlatform,
    /// Invalid hooks
    InvalidHooks,
    /// Other error
    Other,
}

/// Validation warning codes
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ValidationWarningCode {
    /// Deprecated feature
    Deprecated,
    /// Insecure configuration
    Insecure,
    /// Performance issue
    Performance,
    /// Compatibility issue
    Compatibility,
    /// Other warning
    Other,
}

/// Image validator
#[derive(Debug, Default)]
pub struct ImageValidator {
    /// Validation options
    options: ValidationOptions,
}

/// Validation options
#[derive(Debug, Clone, Default)]
pub struct ValidationOptions {
    /// Whether to check file hashes
    pub check_hashes: bool,
    /// Whether to verify dependencies
    pub verify_dependencies: bool,
    /// Whether to check platform compatibility
    pub check_platform: bool,
    /// Whether to validate hooks
    pub validate_hooks: bool,
    /// Maximum file size to check (bytes)
    pub max_file_size: Option<u64>,
    /// Files to exclude from validation
    pub exclude_patterns: Vec<String>,
}

impl ImageValidator {
    /// Create new image validator with default options
    pub fn new() -> Self {
        Self::default()
    }

    /// Create new image validator with custom options
    pub fn with_options(options: ValidationOptions) -> Self {
        Self { options }
    }

    /// Validate image at given path
    pub fn validate<P: AsRef<Path>>(&self, _path: P) -> ValidationResult {
        let start_time = chrono::Utc::now();
        let mut result = ValidationResult {
            is_valid: true,
            errors: Vec::new(),
            warnings: Vec::new(),
            metadata: ValidationMetadata {
                timestamp: start_time,
                duration: std::time::Duration::default(),
                files_checked: 0,
                total_size: 0,
            },
        };

        // TODO: Implement actual validation logic here
        // This would include:
        // - Checking file existence and permissions
        // - Verifying file hashes
        // - Validating metadata structure and contents
        // - Checking layer integrity
        // - Verifying dependencies
        // - Validating platform requirements
        // - Checking hooks

        let end_time = chrono::Utc::now();
        result.metadata.duration = end_time
            .signed_duration_since(start_time)
            .to_std()
            .unwrap_or_default();

        result
    }

    /// Verify file hash
    pub fn verify_hash<P: AsRef<Path>>(&self, _path: P, _expected_hash: &Hash) -> bool {
        if !self.options.check_hashes {
            return true;
        }

        // TODO: Implement actual hash verification
        // This would include:
        // - Reading file contents
        // - Computing hash
        // - Comparing with expected hash
        true
    }

    /// Add a validation error to the result
    pub fn add_error(result: &mut ValidationResult, code: ValidationErrorCode, message: String) {
        result.is_valid = false;
        result.errors.push(ValidationError {
            code,
            message,
            context: HashMap::new(),
        });
    }

    /// Add a validation warning to the result
    pub fn add_warning(result: &mut ValidationResult, code: ValidationWarningCode, message: String) {
        result.warnings.push(ValidationWarning {
            code,
            message,
            context: HashMap::new(),
        });
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-image/src/layer.rs

```rs
//! Image layer handling

use std::path::{Path, PathBuf};
use std::io::{self, Write, Read};
use std::fs;
use std::fmt;
use walkdir::WalkDir;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use blake3::Hasher;

use blast_core::python::PythonEnvironment;

use crate::compression::{CompressionLevel, CompressionType, CompressionStrategy, create_strategy};
use crate::error::{Error, Result};

/// Layer types
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum LayerType {
    /// Base Python installation
    Base,
    /// Package installations
    Packages,
    /// Custom files
    Custom,
    /// Configuration
    Config,
}

/// Layer metadata
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LayerMetadata {
    /// Layer creation time
    pub created_at: DateTime<Utc>,
    /// Layer type
    pub layer_type: LayerType,
    /// Layer compression type
    pub compression_type: CompressionType,
    /// Layer compression level
    pub compression_level: CompressionLevel,
    /// Layer size before compression
    pub original_size: u64,
    /// Layer size after compression
    pub compressed_size: u64,
    /// Layer hash (blake3)
    pub hash: String,
    /// Layer dependencies
    pub dependencies: Vec<String>,
}

impl LayerMetadata {
    /// Create new layer metadata
    pub fn new(
        layer_type: LayerType,
        compression_type: CompressionType,
        compression_level: CompressionLevel,
    ) -> Self {
        Self {
            created_at: Utc::now(),
            layer_type,
            compression_type,
            compression_level,
            original_size: 0,
            compressed_size: 0,
            hash: String::new(),
            dependencies: Vec::new(),
        }
    }

    /// Get compression ratio
    pub fn compression_ratio(&self) -> f64 {
        crate::compression::compression_ratio(self.original_size, self.compressed_size)
    }
}

/// Layer in a Blast image
pub struct Layer {
    /// Layer name
    pub name: String,
    /// Layer path
    pub path: PathBuf,
    /// Layer metadata
    pub metadata: LayerMetadata,
    /// Compression strategy
    compression_strategy: Box<dyn CompressionStrategy>,
}

impl fmt::Debug for Layer {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Layer")
            .field("name", &self.name)
            .field("path", &self.path)
            .field("metadata", &self.metadata)
            .field("compression_strategy", &"<dyn CompressionStrategy>")
            .finish()
    }
}

impl Layer {
    /// Create a new layer
    pub fn new(
        name: String,
        path: PathBuf,
        layer_type: LayerType,
        compression_type: CompressionType,
        compression_level: CompressionLevel,
    ) -> Self {
        let strategy = create_strategy(compression_type.clone(), compression_level);
        Self {
            name,
            path,
            metadata: LayerMetadata::new(layer_type, compression_type, compression_level),
            compression_strategy: strategy,
        }
    }

    /// Create a new layer from an environment
    pub fn from_environment(env: &PythonEnvironment) -> Result<Self> {
        Self::from_environment_with_options(
            env,
            LayerType::Base,
            CompressionType::Zstd,
            CompressionLevel::default(),
        )
    }

    /// Create a new layer from an environment with options
    pub fn from_environment_with_options(
        env: &PythonEnvironment,
        layer_type: LayerType,
        compression_type: CompressionType,
        compression_level: CompressionLevel,
    ) -> Result<Self> {
        let name = format!("{}_{}", 
            env.name().unwrap_or("unknown"), 
            env.python_version().to_string()
        );
        let path = env.path().to_path_buf();
        Ok(Self::new(name, path, layer_type, compression_type, compression_level))
    }

    /// Save layer to a file
    pub fn save<P: AsRef<Path>>(&mut self, target: P) -> Result<()> {
        let target_path = target.as_ref().to_path_buf();
        
        // Calculate original size and hash
        self.metadata.original_size = calculate_size(&self.path)?;
        self.metadata.hash = calculate_hash(&self.path)?;

        // Create tar archive
        let mut tar = tar::Builder::new(Vec::new());
        for entry in WalkDir::new(&self.path) {
            let entry = entry.map_err(|e| Error::layer_with_name(e.to_string(), self.name.clone()))?;
            let path = entry.path();
            if path.is_file() {
                let name = path.strip_prefix(&self.path)
                    .map_err(|e| Error::layer_with_name(format!("Failed to strip prefix: {}", e), self.name.clone()))?;
                tar.append_path_with_name(path, name)
                    .map_err(|e| Error::io(e, path.to_path_buf()))?;
            }
        }
        let tar_data = tar.into_inner()
            .map_err(|e| Error::io(e, target_path.clone()))?;

        // Compress data
        let compressed_data = self.compression_strategy.compress(&tar_data)
            .map_err(|e| Error::compression_with_source(format!("Failed to compress layer {}", self.name), e))?;
        self.metadata.compressed_size = compressed_data.len() as u64;

        // Write compressed data and metadata
        let mut file = fs::File::create(&target_path)
            .map_err(|e| Error::io(e, target_path.clone()))?;
        serde_json::to_writer(&mut file, &self.metadata)
            .map_err(|e| Error::serialization_with_source(format!("Failed to write metadata for layer {}", self.name), e))?;
        file.write_all(&compressed_data)
            .map_err(|e| Error::io(e, target_path.clone()))?;

        Ok(())
    }

    /// Load layer from a file
    pub fn load<P1: AsRef<Path>, P2: AsRef<Path>>(source: P1, target: P2) -> Result<Self> {
        let source_path = source.as_ref().to_path_buf();
        let target_path = target.as_ref().to_path_buf();
        
        let mut file = fs::File::open(&source_path)
            .map_err(|e| Error::io(e, source_path.clone()))?;
        let metadata: LayerMetadata = serde_json::from_reader(&file)
            .map_err(|e| Error::serialization_with_source(format!("Failed to read metadata from {}", source_path.display()), e))?;

        let strategy = create_strategy(metadata.compression_type.clone(), metadata.compression_level);
        let layer = Self {
            name: source.as_ref().file_stem()
                .and_then(|s| s.to_str())
                .unwrap_or("unknown")
                .to_string(),
            path: target_path.clone(),
            metadata,
            compression_strategy: strategy,
        };

        // Read and decompress data
        let mut compressed_data = Vec::new();
        file.read_to_end(&mut compressed_data)
            .map_err(|e| Error::io(e, source_path.clone()))?;
        let tar_data = layer.compression_strategy.decompress(&compressed_data)
            .map_err(|e| Error::compression_with_source(format!("Failed to decompress layer {}", layer.name), e))?;

        // Extract tar archive
        let mut archive = tar::Archive::new(&tar_data[..]);
        archive.unpack(&target_path)
            .map_err(|e| Error::io(e, target_path.clone()))?;

        Ok(layer)
    }

    /// Verify layer integrity
    pub fn verify(&self) -> Result<bool> {
        let current_size = calculate_size(&self.path)?;
        if current_size != self.metadata.original_size {
            return Ok(false);
        }

        let current_hash = calculate_hash(&self.path)?;
        Ok(current_hash == self.metadata.hash)
    }

    /// Get layer size
    pub fn size(&self) -> u64 {
        self.metadata.original_size
    }

    /// Get compressed size
    pub fn compressed_size(&self) -> u64 {
        self.metadata.compressed_size
    }

    /// Get compression ratio
    pub fn compression_ratio(&self) -> f64 {
        self.metadata.compression_ratio()
    }
}

fn calculate_size(path: &Path) -> Result<u64> {
    let mut size = 0;
    for entry in WalkDir::new(path) {
        let entry = entry.map_err(|e| Error::io(io::Error::new(io::ErrorKind::Other, e), path.to_path_buf()))?;
        if entry.path().is_file() {
            size += entry.metadata()
                .map_err(|e| Error::io(io::Error::new(io::ErrorKind::Other, e.to_string()), entry.path().to_path_buf()))?.len();
        }
    }
    Ok(size)
}

fn calculate_hash(path: &Path) -> Result<String> {
    let mut hasher = Hasher::new();
    for entry in WalkDir::new(path) {
        let entry = entry.map_err(|e| Error::io(io::Error::new(io::ErrorKind::Other, e), path.to_path_buf()))?;
        if entry.path().is_file() {
            let file_path = entry.path().to_path_buf();
            let mut file = fs::File::open(&file_path)
                .map_err(|e| Error::io(e, file_path.clone()))?;
            io::copy(&mut file, &mut hasher)
                .map_err(|e| Error::io(e, file_path))?;
        }
    }
    Ok(hasher.finalize().to_hex().to_string())
}

impl Default for CompressionLevel {
    fn default() -> Self {
        Self::Default
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-image/src/platform.rs

```rs
//! Platform-specific requirements and information
//! 
//! This module provides types and functionality for managing platform-specific
//! requirements and capabilities for Python environments.

use serde::{Deserialize, Serialize};

/// Platform-specific requirements
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlatformRequirements {
    /// Operating system requirements
    pub os: Vec<String>,
    /// CPU architecture
    pub arch: Vec<String>,
    /// Minimum CPU cores
    pub min_cores: u32,
    /// Minimum memory in bytes
    pub min_memory: u64,
    /// Minimum disk space in bytes
    pub min_disk_space: u64,
    /// Required system features
    pub required_features: Vec<String>,
    /// GPU requirements
    pub gpu_requirements: Option<GpuRequirements>,
}

/// GPU requirements
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GpuRequirements {
    /// Required GPU memory
    pub min_memory: u64,
    /// Required CUDA version
    pub cuda_version: Option<String>,
    /// Required ROCm version
    pub rocm_version: Option<String>,
    /// Required features
    pub required_features: Vec<String>,
}

/// Platform-specific information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlatformInfo {
    /// Operating system
    pub os: String,
    /// Architecture
    pub arch: String,
    /// Required system dependencies
    pub system_deps: Vec<String>,
    /// Minimum required disk space in bytes
    pub min_disk_space: u64,
    /// Minimum required memory in bytes
    pub min_memory: u64,
}

impl Default for PlatformRequirements {
    fn default() -> Self {
        Self {
            os: vec!["linux".to_string(), "darwin".to_string()],
            arch: vec!["x86_64".to_string(), "aarch64".to_string()],
            min_cores: 1,
            min_memory: 1024 * 1024 * 1024, // 1GB
            min_disk_space: 5 * 1024 * 1024 * 1024, // 5GB
            required_features: Vec::new(),
            gpu_requirements: None,
        }
    }
}

impl PlatformInfo {
    /// Get current platform information
    pub fn current() -> Self {
        Self {
            os: std::env::consts::OS.to_string(),
            arch: std::env::consts::ARCH.to_string(),
            system_deps: Vec::new(),
            min_disk_space: 1024 * 1024 * 1024, // 1GB
            min_memory: 512 * 1024 * 1024,      // 512MB
        }
    }

    /// Check if current platform meets requirements
    pub fn meets_requirements(&self, requirements: &PlatformRequirements) -> bool {
        // Check OS compatibility
        if !requirements.os.iter().any(|os| os == &self.os) {
            return false;
        }

        // Check architecture compatibility
        if !requirements.arch.iter().any(|arch| arch == &self.arch) {
            return false;
        }

        // Check memory requirements
        if self.min_memory < requirements.min_memory {
            return false;
        }

        // Check disk space requirements
        if self.min_disk_space < requirements.min_disk_space {
            return false;
        }

        true
    }

    /// Get available GPU devices
    #[cfg(feature = "gpu")]
    pub fn get_gpu_devices() -> Vec<GpuDevice> {
        // Implementation depends on GPU detection libraries
        vec![]
    }
}

#[cfg(feature = "gpu")]
#[derive(Debug, Clone)]
pub struct GpuDevice {
    /// Device name
    pub name: String,
    /// Available memory
    pub memory: u64,
    /// CUDA compute capability
    pub cuda_capability: Option<String>,
    /// ROCm version
    pub rocm_version: Option<String>,
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-resolver/Cargo.toml

```toml
[package]
name = "blast-resolver"
version = "0.1.0"
edition = "2021"
authors = ["Blast Contributors"]
description = "Dependency resolver for the Blast Python environment manager"
license = "MIT"

[dependencies]
# Internal dependencies
blast-core = { path = "../blast-core" }
blast-cache = { path = "../blast-cache" }
blast-image = { path = "../blast-image" }

# Async runtime
tokio = { version = "1.0", features = ["full"] }
async-trait = "0.1"

# Error handling
thiserror = { workspace = true }
anyhow = "1.0"

# Serialization
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# Logging
tracing = "0.1"

# Dependency resolution
pubgrub = "0.2"
semver = { workspace = true }
rustc-hash = "1.1"

# HTTP client for PyPI
reqwest = { version = "0.11", features = ["json"] }
url = "2.4"

# Concurrency
futures = "0.3"
async-recursion = "1.0"
futures-util = "0.3"

# Additional dependencies
dirs = "5.0"

[dev-dependencies]
tokio = { workspace = true, features = ["macros", "rt-multi-thread"] }
mockall = { workspace = true }
wiremock = "0.5"
tempfile = "3.8"
tokio-test = "0.4"
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-resolver/src/cache.rs

```rs
use std::collections::HashMap;
use std::path::PathBuf;
use std::time::{Duration, SystemTime};

use serde::{Deserialize, Serialize};
use tokio::fs;

use blast_core::error::{BlastError, BlastResult};
use blast_core::package::{Package, PackageId};

const CACHE_DIR_NAME: &str = "blast-resolver";
const CACHE_FILE_NAME: &str = "package-cache.json";
const CACHE_TTL: Duration = Duration::from_secs(24 * 60 * 60); // 24 hours

#[derive(Debug, Serialize, Deserialize)]
struct CacheEntry {
    package: Package,
    last_used: SystemTime,
}

/// Cache for resolved dependencies
#[derive(Debug)]
pub struct Cache {
    cache_dir: PathBuf,
    packages: HashMap<PackageId, CacheEntry>,
    last_cleanup: SystemTime,
}

impl Cache {
    /// Create a new cache
    pub fn new(cache_dir: PathBuf) -> Self {
        let cache_dir = cache_dir.join(CACHE_DIR_NAME);
        Self {
            cache_dir,
            packages: HashMap::new(),
            last_cleanup: SystemTime::now(),
        }
    }

    /// Store a package in the cache
    pub async fn store_package(&mut self, package: Package) -> BlastResult<()> {
        let id = package.id().clone();
        let entry = CacheEntry {
            package,
            last_used: SystemTime::now(),
        };

        self.packages.insert(id, entry);
        self.save().await
    }

    /// Get a package from the cache
    pub fn get_package(&mut self, id: &PackageId) -> Option<&Package> {
        if let Some(entry) = self.packages.get_mut(id) {
            entry.last_used = SystemTime::now();
            Some(&entry.package)
        } else {
            None
        }
    }

    /// Save the cache to disk
    async fn save(&self) -> BlastResult<()> {
        let cache_file = self.cache_dir.join(CACHE_FILE_NAME);
        let json = serde_json::to_string(&self.packages)
            .map_err(|e| BlastError::cache(format!("Failed to serialize cache: {}", e)))?;
        fs::write(cache_file, json).await
            .map_err(|e| BlastError::cache(format!("Failed to write cache file: {}", e)))
    }

    /// Load the cache from disk
    pub async fn load(&mut self) -> BlastResult<()> {
        let cache_file = self.cache_dir.join(CACHE_FILE_NAME);
        if !cache_file.exists() {
            return Ok(());
        }

        let json = fs::read_to_string(cache_file).await
            .map_err(|e| BlastError::cache(format!("Failed to read cache file: {}", e)))?;
        self.packages = serde_json::from_str(&json)
            .map_err(|e| BlastError::cache(format!("Failed to deserialize cache: {}", e)))?;
        Ok(())
    }

    /// Clean up old entries
    pub async fn cleanup(&mut self) -> BlastResult<()> {
        let now = SystemTime::now();
        if now
            .duration_since(self.last_cleanup)
            .unwrap()
            .as_secs()
            < 3600
        {
            return Ok(());
        }

        self.packages.retain(|_, entry| {
            entry
                .last_used
                .elapsed()
                .map(|d| d < CACHE_TTL)
                .unwrap_or(false)
        });

        self.last_cleanup = now;
        self.save().await
    }

    pub async fn add_package(&mut self, package: Package) -> BlastResult<()> {
        self.packages.insert(package.id().clone(), CacheEntry {
            package,
            last_used: SystemTime::now(),
        });
        Ok(())
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-resolver/src/lib.rs

```rs
//! Dependency resolver for the Blast Python environment manager.
//!
//! This crate provides the dependency resolution functionality for Blast,
//! implementing the PubGrub algorithm for Python packages.

use std::sync::Arc;
use blast_core::error::BlastResult;
use blast_core::package::Package;

mod cache;
mod pypi;
mod pubgrub;
mod resolution;
pub mod resolver;

pub use cache::Cache;
pub use pypi::PyPIClient;
pub use resolver::DependencyResolver;
pub use resolution::{ResolutionStrategy, ResolutionResult, ResolutionGraph};

/// Configuration for the resolver
#[derive(Debug, Clone)]
pub struct Config {
    /// Maximum number of concurrent requests
    pub max_concurrent_requests: u64,
    /// Request timeout in seconds
    pub request_timeout: u64,
    /// Whether to verify SSL certificates
    pub verify_ssl: bool,
    /// Whether to allow pre-releases
    pub allow_prereleases: bool,
    /// Additional package sources
    pub additional_sources: Vec<String>,
}

impl Default for Config {
    fn default() -> Self {
        Self {
            max_concurrent_requests: 10,
            request_timeout: 30,
            verify_ssl: true,
            allow_prereleases: false,
            additional_sources: Vec::new(),
        }
    }
}

/// Create a new resolver with default configuration
pub async fn create_resolver() -> BlastResult<Arc<DependencyResolver>> {
    create_resolver_with_config(Config::default()).await
}

/// Create a new resolver with the given configuration
pub async fn create_resolver_with_config(config: Config) -> BlastResult<Arc<DependencyResolver>> {
    let cache_dir = dirs::cache_dir()
        .ok_or_else(|| blast_core::error::BlastError::cache("Failed to get cache directory".to_string()))?
        .join("blast");

    let pypi_client = PyPIClient::new(
        config.max_concurrent_requests,
        config.request_timeout,
        config.verify_ssl,
    )?;

    let cache = Cache::new(cache_dir);
    Ok(Arc::new(DependencyResolver::new(pypi_client, cache)))
}

/// Resolve dependencies for a package
pub async fn resolve(package: Package) -> BlastResult<Vec<Package>> {
    let resolver = create_resolver().await?;
    resolver.resolve(&package).await
}
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-resolver/src/source.rs

```rs
use async_trait::async_trait;

use blast_core::error::BlastResult;
use blast_core::package::{Package, PackageId, Version};

/// Interface for package sources (e.g., PyPI, local directory, custom index)
#[async_trait]
pub trait PackageSource: Send + Sync + 'static {
    /// Get package metadata
    async fn get_package(&self, id: &PackageId) -> BlastResult<Package>;

    /// Get available versions for a package
    async fn get_versions(&self, package_name: &str) -> BlastResult<Vec<Version>>;

    /// Download package
    async fn download_package(&self, id: &PackageId) -> BlastResult<Vec<u8>>;

    /// Check if a package exists
    async fn package_exists(&self, id: &PackageId) -> BlastResult<bool>;

    /// Get source name
    fn name(&self) -> &str;

    /// Get source priority (lower is higher priority)
    fn priority(&self) -> u32;
}

/// A chain of package sources that are tried in order of priority
pub struct PackageSourceChain {
    sources: Vec<Box<dyn PackageSource>>,
}

impl PackageSourceChain {
    /// Create a new package source chain
    pub fn new() -> Self {
        Self {
            sources: Vec::new(),
        }
    }

    /// Add a package source to the chain
    pub fn add_source(&mut self, source: Box<dyn PackageSource>) {
        // Insert source in order of priority
        let pos = self.sources
            .binary_search_by_key(&source.priority(), |s| s.priority())
            .unwrap_or_else(|e| e);
        self.sources.insert(pos, source);
    }

    /// Get all sources in the chain
    pub fn sources(&self) -> &[Box<dyn PackageSource>] {
        &self.sources
    }
}

#[async_trait]
impl PackageSource for PackageSourceChain {
    async fn get_package(&self, id: &PackageId) -> BlastResult<Package> {
        let mut last_error = None;

        for source in &self.sources {
            match source.get_package(id).await {
                Ok(package) => return Ok(package),
                Err(e) => last_error = Some(e),
            }
        }

        Err(last_error.unwrap_or_else(|| {
            blast_core::error::BlastError::package(format!(
                "No package sources available for {}",
                id
            ))
        }))
    }

    async fn get_versions(&self, package_name: &str) -> BlastResult<Vec<Version>> {
        let mut versions = Vec::new();
        let mut seen = std::collections::HashSet::new();

        for source in &self.sources {
            if let Ok(mut source_versions) = source.get_versions(package_name).await {
                // Only add versions we haven't seen before
                source_versions.retain(|v| seen.insert(v.clone()));
                versions.extend(source_versions);
            }
        }

        if versions.is_empty() {
            return Err(blast_core::error::BlastError::package(format!(
                "No versions found for package {}",
                package_name
            )));
        }

        // Sort versions in descending order
        versions.sort();
        versions.reverse();
        Ok(versions)
    }

    async fn download_package(&self, id: &PackageId) -> BlastResult<Vec<u8>> {
        let mut last_error = None;

        for source in &self.sources {
            match source.download_package(id).await {
                Ok(data) => return Ok(data),
                Err(e) => last_error = Some(e),
            }
        }

        Err(last_error.unwrap_or_else(|| {
            blast_core::error::BlastError::package(format!(
                "No package sources available for {}",
                id
            ))
        }))
    }

    async fn package_exists(&self, id: &PackageId) -> BlastResult<bool> {
        for source in &self.sources {
            if source.package_exists(id).await? {
                return Ok(true);
            }
        }
        Ok(false)
    }

    fn name(&self) -> &str {
        "package-source-chain"
    }

    fn priority(&self) -> u32 {
        0
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-resolver/src/pubgrub.rs

```rs
use std::cmp::Ordering;
use std::fmt;

use blast_core::version::Version;
use pubgrub::version::Version as PubgrubVersionTrait;

/// Version wrapper for PubGrub compatibility
#[derive(Debug, Clone, Eq, PartialEq)]
pub(crate) struct PubgrubVersion(pub(crate) Version);

impl From<Version> for PubgrubVersion {
    fn from(v: Version) -> Self {
        Self(v)
    }
}

impl fmt::Display for PubgrubVersion {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl PartialOrd for PubgrubVersion {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for PubgrubVersion {
    fn cmp(&self, other: &Self) -> Ordering {
        self.0.cmp(&other.0)
    }
}

impl PubgrubVersionTrait for PubgrubVersion {
    fn lowest() -> Self {
        Self(Version::parse("0.0.0").unwrap())
    }

    fn bump(&self) -> Self {
        // Simple increment of patch version
        // In practice, we should use proper version bumping logic
        let version_str = format!("{}.0", self.0);
        Self(Version::parse(&version_str).unwrap())
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-resolver/src/pypi.rs

```rs
use std::collections::HashMap;
use std::time::Duration;

use reqwest::Client;
use rustc_hash::FxHashMap;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use tracing::debug;

use blast_core::error::{BlastError, BlastResult};
use blast_core::package::{Package, PackageId};
use blast_core::metadata::PackageMetadata;
use blast_core::{Version, VersionConstraint};
use blast_image::compression::{
    CompressionType, CompressionLevel, CompressionStrategy,
    NoopStrategy, ZstdStrategy, GzipStrategy,
};
use pubgrub::range::Range;
use pubgrub::solver::Dependencies;

const PYPI_BASE_URL: &str = "https://pypi.org/pypi";

/// PyPI API client
#[derive(Clone)]
pub struct PyPIClient {
    client: Client,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct PyPIResponse {
    info: PackageInfo,
    releases: HashMap<String, Vec<ReleaseInfo>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct PackageInfo {
    name: String,
    version: String,
    requires_python: Option<String>,
    summary: Option<String>,
    description: Option<String>,
    author: Option<String>,
    author_email: Option<String>,
    home_page: Option<String>,
    license: Option<String>,
    requires_dist: Option<Vec<String>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct ReleaseInfo {
    yanked: Option<bool>,
    requires_dist: Option<Vec<String>>,
    requires_python: Option<String>,
    filename: String,
    python_version: String,
    url: String,
}

// Helper function to convert reqwest errors to BlastError
fn handle_reqwest_error(err: reqwest::Error) -> BlastError {
    BlastError::network(err.to_string())
}

impl PyPIClient {
    /// Create a new PyPI client
    pub fn new(connect_timeout: u64, request_timeout: u64, verify_ssl: bool) -> BlastResult<Self> {
        let client = Client::builder()
            .connect_timeout(Duration::from_secs(connect_timeout))
            .timeout(Duration::from_secs(request_timeout))
            .danger_accept_invalid_certs(!verify_ssl)
            .build()
            .map_err(handle_reqwest_error)?;

        Ok(Self { client })
    }

    /// Get package metadata from PyPI
    pub async fn get_package_metadata(&self, package: &str) -> BlastResult<Package> {
        let url = format!("{}/{}/json", PYPI_BASE_URL, package);
        debug!("Fetching package metadata from {}", url);

        let response = self.client
            .get(&url)
            .send()
            .await
            .map_err(handle_reqwest_error)?;

        if !response.status().is_success() {
            return Err(BlastError::package(format!(
                "Package not found: {} (status: {})",
                package,
                response.status()
            )));
        }

        let data: PyPIResponse = response
            .json()
            .await
            .map_err(|e| BlastError::package(format!("Invalid package metadata: {}", e)))?;

        let python_constraint = data.info.requires_python.as_deref()
            .map(|v| VersionConstraint::parse(v))
            .transpose()?
            .unwrap_or_else(VersionConstraint::any);

        // Track dependencies by extras
        let mut base_dependencies = HashMap::new();
        let mut extra_dependencies = HashMap::new();

        if let Some(release) = data.releases.get(&data.info.version) {
            if let Some(first_release) = release.first() {
                if let Some(requires_dist) = &first_release.requires_dist {
                    for req in requires_dist {
                        if let Ok(dep) = Dependency::parse(req) {
                            // Only add dependency if Python version constraint is met
                            if dep.python_constraint.as_ref().map_or(true, |pc| pc.matches(&Version::parse("3.7.0").unwrap())) {
                                if dep.extras.is_empty() {
                                    // Base dependency
                                    base_dependencies.insert(dep.package, dep.version_constraint);
                                } else {
                                    // Extra dependency
                                    for extra in &dep.extras {
                                        extra_dependencies
                                            .entry(extra.clone())
                                            .or_insert_with(HashMap::new)
                                            .insert(dep.package.clone(), dep.version_constraint.clone());
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        let mut metadata = PackageMetadata::new(
            data.info.name.clone(),
            data.info.version.clone(),
            base_dependencies.clone(),
            python_constraint.clone(),
        );

        // Add additional metadata
        metadata.description = data.info.description;
        metadata.author = data.info.author;
        metadata.homepage = data.info.home_page;
        metadata.license = data.info.license;

        let mut pkg = Package::new(
            data.info.name.clone(),
            data.info.version.clone(),
            metadata,
            python_constraint,
        )?;

        // Add extras dependencies
        for (extra_name, deps) in extra_dependencies {
            pkg.metadata_mut().extras.insert(extra_name, deps);
        }

        Ok(pkg)
    }

    /// Get available versions for a package
    pub async fn get_package_versions(&self, package: &str) -> BlastResult<Vec<Version>> {
        let url = format!("{}/{}/json", PYPI_BASE_URL, package);
        debug!("Fetching package versions from {}", url);

        let response = self.client
            .get(&url)
            .send()
            .await
            .map_err(handle_reqwest_error)?;

        if !response.status().is_success() {
            return Err(BlastError::package(format!(
                "Package not found: {} (status: {})",
                package,
                response.status()
            )));
        }

        let data: PyPIResponse = response
            .json()
            .await
            .map_err(|e| BlastError::package(format!("Invalid package metadata: {}", e)))?;

        let mut versions = Vec::new();
        for (version_str, releases) in data.releases {
            // Skip yanked releases
            if releases.iter().any(|r| r.yanked.unwrap_or(false)) {
                continue;
            }

            if let Ok(version) = Version::parse(&version_str) {
                versions.push(version);
            }
        }

        versions.sort();
        Ok(versions)
    }

    /// Get package dependencies
    pub async fn get_package_dependencies(&self, package: &str, version: &Version) -> BlastResult<HashMap<String, VersionConstraint>> {
        let url = format!("{}/{}/{}/json", PYPI_BASE_URL, package, version);
        debug!("Fetching package dependencies from {}", url);

        let response = self.client
            .get(&url)
            .send()
            .await
            .map_err(handle_reqwest_error)?;

        if !response.status().is_success() {
            return Err(BlastError::package(format!(
                "Package not found: {}=={} (status: {})",
                package,
                version,
                response.status()
            )));
        }

        let data: PyPIResponse = response
            .json()
            .await
            .map_err(|e| BlastError::package(format!("Invalid package metadata: {}", e)))?;

        let mut dependencies = HashMap::new();
        if let Some(release) = data.releases.get(&version.to_string()) {
            if let Some(first_release) = release.first() {
                if let Some(requires_dist) = &first_release.requires_dist {
                    for req in requires_dist {
                        if let Some((name, constraint)) = parse_requirement(req) {
                            dependencies.insert(name, constraint);
                        }
                    }
                }
            }
        }

        Ok(dependencies)
    }

    pub async fn get_dependencies(
        &self,
        package: &str,
        version: &str,
    ) -> BlastResult<Dependencies<String, PyPIVersion>> {
        let url = format!("{}/{}/{}/json", PYPI_BASE_URL, package, version);
        debug!("Fetching package dependencies from {}", url);

        let response = self.client
            .get(&url)
            .send()
            .await
            .map_err(handle_reqwest_error)?;

        if !response.status().is_success() {
            return Err(BlastError::package(format!(
                "Package not found: {}=={} (status: {})",
                package,
                version,
                response.status()
            )));
        }

        let data: PyPIResponse = response
            .json()
            .await
            .map_err(|e| BlastError::package(format!("Invalid package metadata: {}", e)))?;

        let mut dependencies = HashMap::new();
        if let Some(release) = data.releases.get(version) {
            if let Some(first_release) = release.first() {
                if let Some(requires_dist) = &first_release.requires_dist {
                    for req in requires_dist {
                        if let Some((name, constraint)) = parse_requirement(req) {
                            dependencies.insert(name, constraint);
                        }
                    }
                }
            }
        }

        let mut ranges = FxHashMap::default();
        for (name, constraint) in dependencies {
            let range = match constraint.to_string().as_str() {
                "*" => Range::any(),
                constraint => {
                    let version = Version::parse(constraint.trim_matches(|c| c == '*'))
                        .unwrap_or_else(|_| Version::parse("0.0.0").unwrap());
                    Range::exact(PyPIVersion(version))
                }
            };
            
            ranges.insert(name, range);
        }
        Ok(Dependencies::Known(ranges))
    }

    #[allow(dead_code)]
    async fn get_package(&self, package_id: &PackageId) -> BlastResult<Package> {
        let metadata = self.get_package_metadata(package_id.name()).await?;
        let _base_dependencies = self.get_dependencies(package_id.name(), &package_id.version().to_string()).await?;

        let pkg = Package::new(
            package_id.name().to_string(),
            package_id.version().to_string(),
            metadata.metadata().clone(),
            metadata.metadata().python_version.clone(),
        )?;

        Ok(pkg)
    }

    pub async fn resolve_import(&self, import_name: &str) -> BlastResult<Option<Package>> {
        let package_name = match self.get_package_metadata(import_name).await {
            Ok(metadata) => metadata.name().to_string(),
            Err(_) => return Ok(None),
        };

        let client = PyPIClient::new(10, 30, false)?;
        let metadata = client.get_package_metadata(&package_name).await?;
        let _base_dependencies = client.get_dependencies(&package_name, metadata.version().to_string().as_str()).await?;

        Package::new(
            metadata.name().to_string(),
            metadata.version().to_string(),
            metadata.metadata().clone(),
            metadata.metadata().python_version.clone(),
        ).map(Some)
    }

    pub async fn is_available(&self, import_name: &str) -> bool {
        if let Some(package_name) = self.get_package_name(import_name) {
            if let Ok(client) = PyPIClient::new(10, 30, false) {
                client.get_package_metadata(package_name.as_str()).await.is_ok()
            } else {
                false
            }
        } else {
            false
        }
    }

    pub fn get_package_name(&self, import_name: &str) -> Option<String> {
        // Basic implementation - in real world this would need a more sophisticated mapping
        Some(import_name.to_string())
    }

    #[allow(dead_code)]
    async fn get_package_info(&self, name: &str) -> BlastResult<PackageMetadata> {
        let url = format!("{}/{}/json", PYPI_BASE_URL, name);
        let response = self.client.get(&url)
            .send()
            .await
            .map_err(handle_reqwest_error)?;

        if !response.status().is_success() {
            return Err(BlastError::package(format!(
                "Package '{}' not found on PyPI",
                name
            )));
        }

        let pypi_data: PyPIResponse = response.json()
            .await
            .map_err(handle_reqwest_error)?;

        // Parse dependencies
        let mut dependencies = HashMap::new();
        if let Some(deps) = pypi_data.info.requires_dist {
            for dep_str in deps {
                if let Some((name, constraint)) = parse_requirement(&dep_str) {
                    dependencies.insert(name, constraint);
                }
            }
        }

        let python_constraint = pypi_data.info.requires_python
            .as_deref()
            .map(|v| VersionConstraint::parse(v))
            .transpose()?
            .unwrap_or_else(VersionConstraint::any);

        let mut metadata = PackageMetadata::new(
            pypi_data.info.name.clone(),
            pypi_data.info.version.clone(),
            dependencies,
            python_constraint,
        );

        metadata.description = pypi_data.info.description;
        metadata.author = pypi_data.info.author;
        metadata.homepage = pypi_data.info.home_page;
        metadata.license = pypi_data.info.license;

        Ok(metadata)
    }

    #[allow(dead_code)]
    async fn update_package_metadata(&self, package: &mut Package, info: &Value) -> BlastResult<()> {
        let mut metadata = package.metadata().clone();

        if let Some(description) = info["description"].as_str() {
            metadata.description = Some(description.to_string());
        }

        if let Some(author) = info["author"].as_str() {
            metadata.author = Some(author.to_string());
        }

        if let Some(homepage) = info["home_page"].as_str() {
            metadata.homepage = Some(homepage.to_string());
        }

        // Parse dependencies
        let mut dependencies = HashMap::new();
        if let Some(requires_dist) = info["requires_dist"].as_array() {
            for req in requires_dist {
                if let Some(req_str) = req.as_str() {
                    if let Some((name, constraint)) = parse_requirement(req_str) {
                        dependencies.insert(name, constraint);
                    }
                }
            }
        }

        // Update package with new metadata
        *package.metadata_mut() = metadata;

        Ok(())
    }
}

fn parse_requirement(req: &str) -> Option<(String, VersionConstraint)> {
    match Dependency::parse(req) {
        Ok(dep) => Some((dep.package, dep.version_constraint)),
        Err(_) => None
    }
}

/// Package dependency
#[derive(Debug, Clone)]
pub struct Dependency {
    pub package: String,
    pub version_constraint: VersionConstraint,
    pub python_constraint: Option<VersionConstraint>,
    pub extras: Vec<String>,
}

impl Dependency {
    /// Parse a dependency string according to PEP 508
    pub fn parse(dep_str: &str) -> BlastResult<Self> {
        // Split package name from version/extras
        let parts: Vec<&str> = dep_str.split(';').collect();
        let main_req = parts[0].trim();

        // Parse extras and version constraints
        let (package_name, extras, version_req) = if main_req.contains('[') {
            // Has extras
            let bracket_idx = main_req.find('[').unwrap();
            let close_idx = main_req.find(']')
                .ok_or_else(|| BlastError::package("Invalid extras format"))?;
            
            let name = main_req[..bracket_idx].trim();
            let extras_str = main_req[bracket_idx + 1..close_idx].trim();
            let extras: Vec<String> = extras_str.split(',')
                .map(|s| s.trim().to_string())
                .collect();

            let version_part = main_req[close_idx + 1..].trim();
            let version_req = if version_part.is_empty() {
                "*"
            } else {
                version_part.trim_start_matches(|c| c == '(' || c == '=' || c == ' ')
                    .trim_end_matches(|c| c == ')' || c == ' ')
            };

            (name, extras, version_req)
        } else if main_req.contains('=') || main_req.contains('>') || main_req.contains('<') || main_req.contains('~') {
            // Has version constraint
            let mut parts = main_req.splitn(2, |c| c == '=' || c == '>' || c == '<' || c == '~');
            let name = parts.next().unwrap().trim();
            let version_req = parts.next().unwrap_or("*").trim();
            (name, Vec::new(), version_req)
        } else {
            // Just package name
            (main_req, Vec::new(), "*")
        };

        // Parse Python version constraint if present
        let python_constraint = if parts.len() > 1 {
            let python_req = parts[1].trim();
            if python_req.starts_with("python_version") {
                let version_str = python_req.split_once(|c| c == '>' || c == '<' || c == '=')
                    .map(|(_, v)| v.trim())
                    .unwrap_or("*");
                Some(VersionConstraint::parse(version_str)?)
            } else {
                None
            }
        } else {
            None
        };

        Ok(Self {
            package: package_name.to_string(),
            version_constraint: VersionConstraint::parse(version_req)?,
            python_constraint,
            extras,
        })
    }
}

/// PyPI package resolver
#[allow(dead_code)]
pub struct PyPIResolver {
    client: Client,
    package_cache: HashMap<String, PackageMetadata>,
    import_map: HashMap<String, String>,
}

impl Default for PyPIResolver {
    fn default() -> Self {
        Self::new()
    }
}

impl PyPIResolver {
    pub fn new() -> Self {
        let mut resolver = Self {
            client: Client::new(),
            package_cache: HashMap::new(),
            import_map: HashMap::new(),
        };
        
        // Add common import mappings
        resolver.add_default_mappings();
        resolver
    }

    fn add_default_mappings(&mut self) {
        let default_mappings = [
            ("numpy", "numpy"),
            ("pandas", "pandas"),
            ("requests", "requests"),
            ("tensorflow", "tensorflow"),
            ("torch", "torch"),
            ("sklearn", "scikit-learn"),
            ("matplotlib", "matplotlib"),
            ("pytest", "pytest"),
        ];

        for (import_name, package_name) in default_mappings {
            self.add_import_mapping(import_name.to_string(), package_name.to_string());
        }
    }

    pub fn add_import_mapping(&mut self, import_name: String, package_name: String) {
        debug!("Adding import mapping: {} -> {}", import_name, package_name);
        self.import_map.insert(import_name, package_name);
    }

    #[allow(dead_code)]
    pub fn get_package_name(&self, import_name: &str) -> Option<&String> {
        self.import_map.get(import_name)
    }

    #[allow(dead_code)]
    pub async fn is_available(&self, import_name: &str) -> bool {
        if let Some(package_name) = self.get_package_name(import_name) {
            if let Ok(client) = PyPIClient::new(10, 30, false) {
                client.get_package_metadata(package_name.as_str()).await.is_ok()
            } else {
                false
            }
        } else {
            false
        }
    }

    #[allow(dead_code)]
    pub async fn resolve_imports(&self, imports: &[String]) -> BlastResult<Vec<Package>> {
        let mut packages = Vec::new();
        let client = PyPIClient::new(10, 30, false)?;
        
        for import_name in imports {
            if let Some(package_name) = self.get_package_name(import_name) {
                match client.get_package_metadata(package_name).await {
                    Ok(package) => packages.push(package),
                    Err(_) => continue,
                }
            }
        }
        
        Ok(packages)
    }

    #[allow(dead_code)]
    fn parse_dependencies(&self, deps: &[String]) -> BlastResult<HashMap<String, VersionConstraint>> {
        let mut result = HashMap::new();
        
        for dep_str in deps {
            if let Some((name, constraint)) = parse_requirement(dep_str) {
                result.insert(name, constraint);
            }
        }
        
        Ok(result)
    }

    #[allow(dead_code)]
    fn parse_python_version(&self, version: Option<&str>) -> BlastResult<VersionConstraint> {
        match version {
            Some(v) => VersionConstraint::parse(v),
            None => Ok(VersionConstraint::any()),
        }
    }
}

#[derive(Debug, Clone, Eq, PartialEq, Hash, Ord, PartialOrd)]
pub struct PyPIVersion(pub(crate) Version);

impl std::fmt::Display for PyPIVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl From<Version> for PyPIVersion {
    fn from(v: Version) -> Self {
        PyPIVersion(v)
    }
}

impl pubgrub::version::Version for PyPIVersion {
    fn lowest() -> Self {
        PyPIVersion(Version::parse("0.0.0").unwrap())
    }

    fn bump(&self) -> Self {
        // Since we can't access Version's internals directly,
        // we'll parse the version string and increment
        let version_str = self.0.to_string();
        let parts: Vec<&str> = version_str.split('.').collect();
        if parts.len() >= 3 {
            let major: u64 = parts[0].parse().unwrap_or(0);
            let minor: u64 = parts[1].parse().unwrap_or(0);
            let patch: u64 = parts[2].parse().unwrap_or(0);
            let new_version = format!("{}.{}.{}", major, minor, patch + 1);
            PyPIVersion(Version::parse(&new_version).unwrap())
        } else {
            PyPIVersion(Version::parse("0.0.1").unwrap())
        }
    }
}

#[allow(dead_code)]
pub fn create_strategy(
    compression_type: CompressionType,
    level: CompressionLevel,
) -> Box<dyn CompressionStrategy> {
    match compression_type {
        CompressionType::None => Box::new(NoopStrategy),
        CompressionType::Zstd => Box::new(ZstdStrategy::new(level)),
        CompressionType::Gzip => Box::new(GzipStrategy::new(level)),
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-resolver/src/resolution.rs

```rs
use std::sync::Arc;
use async_trait::async_trait;
use tokio::sync::RwLock;

use blast_core::error::BlastResult;
use blast_core::package::Package;

use crate::cache::Cache;
use crate::pypi::PyPIClient;

/// Result of a dependency resolution
#[derive(Debug, Clone)]
pub struct ResolutionResult {
    /// Resolved packages
    pub packages: Vec<Package>,
    /// Resolution graph (if available)
    pub graph: Option<ResolutionGraph>,
    /// Resolution metrics
    pub metrics: ResolutionMetrics,
}

/// Dependency resolution graph
#[derive(Debug, Clone)]
pub struct ResolutionGraph {
    /// Direct dependencies
    pub direct_deps: Vec<Package>,
    /// Transitive dependencies
    pub transitive_deps: Vec<Package>,
    /// Dependency relationships
    pub relationships: Vec<DependencyRelationship>,
}

/// Relationship between packages
#[derive(Debug, Clone)]
pub struct DependencyRelationship {
    /// Source package
    pub from: Package,
    /// Target package
    pub to: Package,
    /// Type of relationship
    pub kind: DependencyKind,
}

/// Type of dependency relationship
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum DependencyKind {
    /// Direct dependency
    Direct,
    /// Transitive dependency
    Transitive,
    /// Optional dependency
    Optional,
    /// Development dependency
    Development,
}

/// Metrics from dependency resolution
#[derive(Debug, Clone, Default)]
pub struct ResolutionMetrics {
    /// Number of packages resolved
    pub package_count: usize,
    /// Time taken for resolution (ms)
    pub resolution_time_ms: u64,
    /// Number of network requests
    pub network_requests: usize,
    /// Number of cache hits
    pub cache_hits: usize,
    /// Number of version conflicts resolved
    pub conflicts_resolved: usize,
}

/// Strategy for resolving dependencies
#[async_trait]
pub trait ResolutionStrategy: Send + Sync {
    /// Resolve dependencies for a package
    async fn resolve(
        &self,
        package: &Package,
        pypi: &PyPIClient,
        cache: &Arc<RwLock<Cache>>,
    ) -> BlastResult<ResolutionResult>;

    /// Check if a version conflict exists
    fn has_conflict(&self, package: &Package, resolved: &[Package]) -> bool;

    /// Get resolution metrics
    fn get_metrics(&self) -> ResolutionMetrics;
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-resolver/src/resolver.rs

```rs
use std::collections::HashMap;
use std::sync::Arc;
use std::cmp::Ordering;
use std::borrow::Borrow;
use std::error::Error as StdError;
use rustc_hash::FxHashMap;

use pubgrub::range::Range;
use pubgrub::solver::{Dependencies, DependencyProvider};
use pubgrub::version::Version as PubgrubVersionTrait;
use tokio::sync::RwLock;
use tracing::debug;
use async_trait::async_trait;

use blast_core::error::{BlastError, BlastResult};
use blast_core::package::{Package, PackageId};
use blast_core::version::Version;
use blast_core::security::{PackageVerification, PolicyResult, SecurityPolicy, VerificationResult, Vulnerability};

use crate::cache::Cache;
use crate::pypi::PyPIClient;
use crate::resolution::{ResolutionStrategy, ResolutionResult};

/// Dependency resolver for Python packages
pub struct DependencyResolver {
    pub(crate) pypi: PyPIClient,
    cache: Arc<RwLock<Cache>>,
    resolution_cache: Arc<RwLock<HashMap<PackageId, Vec<Package>>>>,
    resolution_strategy: PubGrubProvider,
}

impl DependencyResolver {
    /// Create a new resolver
    pub fn new(pypi: PyPIClient, cache: Cache) -> Self {
        Self {
            pypi: pypi.clone(),
            cache: Arc::new(RwLock::new(cache)),
            resolution_cache: Arc::new(RwLock::new(HashMap::new())),
            resolution_strategy: PubGrubProvider::new(pypi),
        }
    }

    /// Get available versions for a package
    pub async fn get_package_versions(&self, name: &str) -> BlastResult<Vec<Version>> {
        self.pypi.get_package_versions(name).await
    }

    /// Resolve dependencies for a package
    pub async fn resolve(&self, package: &Package) -> BlastResult<Vec<Package>> {
        // Check resolution cache first
        let cache_key = package.id().clone();
        if let Some(deps) = self.resolution_cache.read().await.get(&cache_key) {
            debug!("Using cached resolution for {}", package.name());
            return Ok(deps.clone());
        }

        let ResolutionResult { packages, .. } = self.resolution_strategy
            .resolve(package, &self.pypi, &self.cache)
            .await?;

        // Cache the resolution
        self.resolution_cache.write().await.insert(cache_key, packages.clone());
        Ok(packages)
    }

    /// Clear resolution cache
    pub async fn clear_cache(&self) {
        self.resolution_cache.write().await.clear();
    }

    /// Resolve dependencies for a package with specified extras
    pub async fn resolve_with_extras(&self, package: &Package, extras: &[String]) -> BlastResult<Vec<Package>> {
        let all_deps = package.all_dependencies(extras);
        let mut resolved = Vec::new();

        for (name, constraint) in all_deps {
            let versions = self.get_package_versions(&name).await?;
            // Find highest version that satisfies the constraint
            if let Some(_version) = versions.into_iter().rev().find(|v| constraint.matches(v)) {
                let pkg = self.pypi.get_package_metadata(&name).await?;
                resolved.extend(self.resolve(&pkg).await?);
            }
        }

        Ok(resolved)
    }

    pub async fn resolve_import(&self, import_name: &str) -> BlastResult<Option<Package>> {
        self.pypi.resolve_import(import_name).await
    }

    pub async fn is_available(&self, import_name: &str) -> bool {
        self.pypi.is_available(import_name).await
    }
}

impl PackageVerification for DependencyResolver {
    fn verify_package(&self, _package: &Package) -> BlastResult<VerificationResult> {
        // TODO: Implement package verification
        Ok(VerificationResult {
            verified: true,
            details: String::new(),
            warnings: Vec::new(),
            signature: None,
        })
    }

    fn scan_vulnerabilities(&self, _package: &Package) -> BlastResult<Vec<Vulnerability>> {
        // TODO: Implement vulnerability scanning
        Ok(Vec::new())
    }

    fn verify_policy(&self, _package: &Package, _policy: &SecurityPolicy) -> BlastResult<PolicyResult> {
        // TODO: Implement policy verification
        Ok(PolicyResult {
            allowed: true,
            required_actions: Vec::new(),
            violations: Vec::new(),
        })
    }
}

/// PubGrub dependency provider
struct PubGrubProvider {
    pypi: PyPIClient,
}

/// Wrapper type for Version to implement PubgrubVersion
#[derive(Debug, Clone, Eq, PartialEq, Hash)]
pub struct PubgrubVersion(pub(crate) Version);

impl std::fmt::Display for PubgrubVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl PubgrubVersionTrait for PubgrubVersion {
    fn lowest() -> Self {
        PubgrubVersion(Version::parse("0.0.0").unwrap())
    }

    fn bump(&self) -> Self {
        // Since we can't access Version's internals directly,
        // we'll parse the version string and increment
        let version_str = self.0.to_string();
        let parts: Vec<&str> = version_str.split('.').collect();
        if parts.len() >= 3 {
            let major: u64 = parts[0].parse().unwrap_or(0);
            let minor: u64 = parts[1].parse().unwrap_or(0);
            let patch: u64 = parts[2].parse().unwrap_or(0);
            let new_version = format!("{}.{}.{}", major, minor, patch + 1);
            PubgrubVersion(Version::parse(&new_version).unwrap())
        } else {
            // Fallback to a simple increment
            PubgrubVersion(Version::parse("0.0.1").unwrap())
        }
    }
}

impl From<Version> for PubgrubVersion {
    fn from(v: Version) -> Self {
        PubgrubVersion(v)
    }
}

impl PartialOrd for PubgrubVersion {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for PubgrubVersion {
    fn cmp(&self, other: &Self) -> Ordering {
        self.0.cmp(&other.0)
    }
}

impl PubGrubProvider {
    pub fn new(pypi: PyPIClient) -> Self {
        Self { pypi }
    }
}

#[async_trait]
impl ResolutionStrategy for PubGrubProvider {
    async fn resolve(
        &self,
        package: &Package,
        pypi: &PyPIClient,
        cache: &Arc<RwLock<Cache>>,
    ) -> BlastResult<ResolutionResult> {
        let start_time = std::time::Instant::now();
        let mut metrics = crate::resolution::ResolutionMetrics::default();

        let root = package.name().to_string();
        let root_version = PubgrubVersion(package.version().clone());

        let solution = pubgrub::solver::resolve(self, root.clone(), root_version)
            .map_err(|e| BlastError::resolution(format!(
                "No solution found for package {}: {:?}",
                package.name(),
                e
            )))?;

        let mut packages = Vec::new();
        for (name, version) in solution.into_iter() {
            if name != root {
                let pkg_id = PackageId::new(name.clone(), version.0.clone());
                let pkg = if let Some(cached_pkg) = cache.write().await.get_package(&pkg_id) {
                    debug!("Using cached package {}", pkg_id);
                    metrics.cache_hits += 1;
                    cached_pkg.clone()
                } else {
                    metrics.network_requests += 1;
                    let pkg = pypi.get_package_metadata(&name).await?;
                    cache.write().await.store_package(pkg.clone()).await?;
                    pkg
                };
                packages.push(pkg);
            }
        }

        metrics.package_count = packages.len();
        metrics.resolution_time_ms = start_time.elapsed().as_millis() as u64;

        Ok(ResolutionResult {
            packages,
            graph: None,
            metrics,
        })
    }

    fn has_conflict(&self, package: &Package, resolved: &[Package]) -> bool {
        for dep in resolved {
            if dep.name() == package.name() && dep.version() != package.version() {
                return true;
            }
        }
        false
    }

    fn get_metrics(&self) -> crate::resolution::ResolutionMetrics {
        crate::resolution::ResolutionMetrics::default()
    }
}

impl DependencyProvider<String, PubgrubVersion> for PubGrubProvider {
    fn get_dependencies(
        &self,
        package: &String,
        version: &PubgrubVersion,
    ) -> Result<Dependencies<String, PubgrubVersion>, Box<dyn StdError>> {
        let rt = tokio::runtime::Runtime::new()
            .map_err(|e| Box::new(BlastError::resolution(e.to_string())) as Box<dyn StdError>)?;
        
        let deps_map = rt.block_on(self.pypi.get_package_dependencies(package, &version.0))
            .map_err(|e| Box::new(BlastError::resolution(e.to_string())) as Box<dyn StdError>)?;

        let mut ranges = FxHashMap::default();
        for (name, _constraint) in deps_map {
            let range = Range::any(); // TODO: Convert VersionConstraint to PubGrub Range
            ranges.insert(name, range);
        }
        Ok(Dependencies::Known(ranges))
    }

    fn choose_package_version<T, U>(
        &self,
        mut available_versions: impl Iterator<Item = (T, U)>,
    ) -> Result<(T, Option<PubgrubVersion>), Box<dyn StdError>>
    where
        T: Borrow<String>,
        U: Borrow<Range<PubgrubVersion>>,
    {
        let rt = tokio::runtime::Runtime::new()
            .map_err(|e| Box::new(BlastError::resolution(e.to_string())) as Box<dyn StdError>)?;

        if let Some((package, range)) = available_versions.next() {
            let versions = rt.block_on(self.pypi.get_package_versions(package.borrow()))
                .map_err(|e| Box::new(BlastError::resolution(e.to_string())) as Box<dyn StdError>)?;

            let mut best_version = None;
            for version in versions {
                let pubgrub_version = PubgrubVersion(version);
                if range.borrow().contains(&pubgrub_version) {
                    match best_version {
                        None => best_version = Some(pubgrub_version),
                        Some(ref current) if pubgrub_version > *current => {
                            best_version = Some(pubgrub_version)
                        }
                        _ => {}
                    }
                }
            }
            Ok((package, best_version))
        } else {
            Err(Box::new(BlastError::resolution("No versions available".to_string())))
        }
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-sync/src/manifest.rs

```rs
//! Sync manifest management implementation

use std::path::PathBuf;
use std::sync::Arc;
use tokio::sync::RwLock;
use async_trait::async_trait;

use blast_core::{
    BlastResult,
    ManifestManager,
    Package,
    SystemDependency,
    Manifest,
};

/// Sync manifest manager
#[derive(Clone)]
pub struct SyncManifestManager {
    manifest: Arc<RwLock<Manifest>>,
    manifest_path: PathBuf,
    daemon_client: Arc<blast_daemon::Client>,
}

impl SyncManifestManager {
    /// Create new manifest manager
    pub async fn new(manifest_path: PathBuf, daemon_client: Arc<blast_daemon::Client>) -> BlastResult<Self> {
        // Load manifest from daemon
        let manifest = daemon_client.get_manifest().await?;

        Ok(Self {
            manifest: Arc::new(RwLock::new(manifest)),
            manifest_path,
            daemon_client,
        })
    }

    /// Sync manifest with daemon
    pub async fn sync_with_daemon(&self) -> BlastResult<()> {
        let daemon_manifest = self.daemon_client.get_manifest().await?;
        *self.manifest.write().await = daemon_manifest;
        Ok(())
    }
}

#[async_trait]
impl ManifestManager for SyncManifestManager {
    async fn get_manifest(&self) -> BlastResult<Manifest> {
        Ok(self.manifest.read().await.clone())
    }

    async fn update_manifest(&self, manifest: &Manifest) -> BlastResult<()> {
        // Update local copy
        *self.manifest.write().await = manifest.clone();
        
        // Sync with daemon
        self.daemon_client.update_manifest(manifest).await
    }

    async fn record_package_install(&self, package: &Package) -> BlastResult<()> {
        // Update local copy
        let mut manifest = self.manifest.write().await;
        manifest.record_package_install(
            package.name.clone(),
            package.version.to_string(),
        );
        
        // Sync with daemon
        self.daemon_client.record_package_install(package).await
    }

    async fn record_package_removal(&self, package: &Package) -> BlastResult<()> {
        // Update local copy
        let mut manifest = self.manifest.write().await;
        manifest.record_package_removal(&package.name);
        
        // Sync with daemon
        self.daemon_client.record_package_removal(package).await
    }

    async fn record_env_var_change(&self, key: &str, value: &str) -> BlastResult<()> {
        // Update local copy
        let mut manifest = self.manifest.write().await;
        manifest.record_env_var_change(key.to_string(), value.to_string());
        
        // Sync with daemon
        self.daemon_client.record_env_var_change(key, value).await
    }

    async fn record_system_dependency(&self, dependency: &SystemDependency) -> BlastResult<()> {
        // Update local copy
        let mut manifest = self.manifest.write().await;
        manifest.record_system_dependency(dependency.clone());
        
        // Sync with daemon
        self.daemon_client.record_system_dependency(dependency).await
    }

    async fn record_hook_addition(&self, hook_type: &str, command: &str) -> BlastResult<()> {
        // Update local copy
        let mut manifest = self.manifest.write().await;
        manifest.record_hook_addition(hook_type, command.to_string());
        
        // Sync with daemon
        self.daemon_client.record_hook_addition(hook_type, command).await
    }

    async fn verify_manifest(&self) -> BlastResult<bool> {
        let manifest = self.manifest.read().await;
        let local_valid = manifest.metadata.verify()?;
        
        // Also verify against daemon
        let daemon_manifest = self.daemon_client.get_manifest().await?;
        let daemon_valid = daemon_manifest.metadata.verify()?;
        
        Ok(local_valid && daemon_valid && manifest.metadata.content_hash == daemon_manifest.metadata.content_hash)
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cli/Cargo.toml

```toml
[package]
name = "blast-cli"
version = "0.1.0"
edition = "2021"
authors = ["Blast Contributors"]
description = "Command-line interface for the Blast Python environment manager"
license = "MIT"

[dependencies]
# Internal dependencies
blast-core = { path = "../blast-core" }
blast-daemon = { path = "../blast-daemon" }
blast-image = { path = "../blast-image" }
blast-resolver = { path = "../blast-resolver" }

# CLI
clap = { version = "4.4", features = ["derive"] }
console = "0.15"
dialoguer = "0.11"
indicatif = "0.17"

# Error handling
anyhow = "1.0"
thiserror = "1.0"

# Async runtime
tokio = { version = "1.0", features = ["full"] }

# Logging
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }

# Time handling
chrono = { version = "0.4", features = ["serde"] }
humantime = "2.1"

# Utilities
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
uuid = { version = "1.0", features = ["v4", "serde"] }
dirs = "5.0"
once_cell = "1.19"

# Unix process management
nix = { version = "0.27", features = ["signal"] }

[dev-dependencies]
assert_cmd = "2.0"
predicates = "3.0"
tempfile = { workspace = true } 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cli/jockey-img/blast-cli_02-17-25.md

````md
# Jockey Image

Generated: 02-17-2025 at 19:44:24

## Repository Structure

```
blast-cli
│   ├── Cargo.toml
    └── src
    │   ├── output
    │       └── logger.rs
    │   ├── commands
    │   ├── lib.rs
    │   ├── output.rs
        └── progress.rs
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cli/Cargo.toml

```toml
[package]
name = "blast-cli"
version = "0.1.0"
edition = "2021"
authors = ["Blast Contributors"]
description = "Command-line interface for the Blast Python environment manager"
license = "MIT"

[dependencies]
# Internal dependencies
blast-core = { path = "../blast-core" }
blast-daemon = { path = "../blast-daemon" }
blast-image = { path = "../blast-image" }
blast-resolver = { path = "../blast-resolver" }

# CLI
clap = { version = "4.4", features = ["derive"] }
console = "0.15"
dialoguer = "0.11"
indicatif = "0.17"

# Error handling
anyhow = "1.0"
thiserror = "1.0"

# Async runtime
tokio = { version = "1.0", features = ["full"] }

# Logging
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }

# Time handling
chrono = { version = "0.4", features = ["serde"] }
humantime = "2.1"

# Utilities
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
uuid = { version = "1.0", features = ["v4", "serde"] }

[dev-dependencies]
assert_cmd = "2.0"
predicates = "3.0"
tempfile = { workspace = true } 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cli/src/lib.rs

```rs
//! Command-line interface for the Blast Python environment manager.

use std::path::PathBuf;
use anyhow::Result;
use clap::{Parser, Subcommand};
use tracing::error;

use blast_core::config::BlastConfig;
use blast_core::python::PythonVersion;

mod commands;
mod output;
mod progress;

pub use commands::*;
pub use output::*;
pub use progress::*;

/// CLI arguments parser
#[derive(Parser)]
#[command(author, version, about, long_about = None)]
pub struct Cli {
    /// Config file path
    #[arg(short, long, value_name = "FILE")]
    config: Option<PathBuf>,

    /// Verbose output
    #[arg(short, long)]
    verbose: bool,

    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
pub enum Commands {
    /// Start a new blast environment (stacks if one exists)
    Start {
        /// Python version to use
        #[arg(short, long)]
        python: Option<String>,

        /// Environment name
        #[arg(short, long)]
        name: Option<String>,

        /// Environment path
        #[arg(short, long)]
        path: Option<PathBuf>,

        /// Additional environment variables
        #[arg(short, long)]
        env: Vec<String>,
    },

    /// Kill the current blast environment
    Kill {
        /// Force kill without graceful shutdown
        #[arg(short, long)]
        force: bool,
    },

    /// Clean and reinstall all dependencies
    Clean,

    /// Save environment image
    Save {
        /// Image name
        #[arg(short, long)]
        name: Option<String>,
    },

    /// Load environment image
    Load {
        /// Image name
        #[arg(short, long)]
        name: Option<String>,
    },

    /// List all environments from most to least recently used
    List,

    /// Check environment status and health
    Check,
}

/// Run the CLI application
pub async fn run() -> Result<()> {
    let cli = Cli::parse();

    // Initialize logging
    if cli.verbose {
        tracing_subscriber::fmt()
            .with_max_level(tracing::Level::DEBUG)
            .init();
    } else {
        tracing_subscriber::fmt()
            .with_max_level(tracing::Level::INFO)
            .init();
    }

    // Load or create config
    let config = if let Some(path) = cli.config {
        BlastConfig::from_file(path)?
    } else {
        let current_dir = std::env::current_dir()?;
        BlastConfig::new(
            current_dir.file_name().unwrap().to_string_lossy().to_string(),
            "0.1.0",
            PythonVersion::parse("3.8")?,
            current_dir,
        )
    };

    // Execute command
    match cli.command {
        Commands::Start {
            python,
            name,
            path,
            env,
        } => {
            commands::execute_start(python, name, path, env, &config).await?;
        }
        Commands::Kill { force } => {
            commands::execute_kill(force, &config).await?;
        }
        Commands::Clean => {
            commands::execute_clean(&config).await?;
        }
        Commands::Save { name } => {
            commands::execute_save(name, &config).await?;
        }
        Commands::Load { name } => {
            commands::execute_load(name, &config).await?;
        }
        Commands::List => {
            commands::execute_list(&config).await?;
        }
        Commands::Check => {
            commands::execute_check(&config).await?;
        }
    }

    Ok(())
}

/// Main entry point for the CLI binary
pub fn main() {
    // Set up logging with better formatting
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::EnvFilter::from_default_env()
            .add_directive(tracing::Level::INFO.into()))
        .with_target(false)
        .with_thread_ids(false)
        .with_line_number(false)
        .with_file(false)
        .init();

    if let Err(e) = tokio::runtime::Runtime::new()
        .unwrap()
        .block_on(run())
    {
        error!("Error: {}", e);
        std::process::exit(1);
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cli/src/output/logger.rs

```rs
use console::{style, Term};
use std::fmt::Display;

pub struct Logger {
    term: Term,
}

#[derive(Debug, Clone, Copy)]
pub enum HealthStatus {
    Good,
    Okay,
    Bad,
}

impl HealthStatus {
    pub fn from_resource_usage(cpu_percent: f32, memory_percent: f32, disk_percent: f32) -> Self {
        if cpu_percent > 90.0 || memory_percent > 90.0 || disk_percent > 90.0 {
            HealthStatus::Bad
        } else if cpu_percent > 70.0 || memory_percent > 70.0 || disk_percent > 70.0 {
            HealthStatus::Okay
        } else {
            HealthStatus::Good
        }
    }

    pub fn color(&self) -> console::Style {
        match self {
            HealthStatus::Good => style().green(),
            HealthStatus::Okay => style().yellow(),
            HealthStatus::Bad => style().red(),
        }
    }
}

impl Display for HealthStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            HealthStatus::Good => write!(f, "good"),
            HealthStatus::Okay => write!(f, "okay"),
            HealthStatus::Bad => write!(f, "bad"),
        }
    }
}

impl Logger {
    pub fn new() -> Self {
        Self {
            term: Term::stdout(),
        }
    }

    pub fn header(&self, text: &str) {
        let width = self.term.size().1 as usize;
        let padding = "=".repeat((width - text.len() - 2) / 2);
        println!("\n{} {} {}\n", padding, style(text).bold(), padding);
    }

    pub fn section(&self, text: &str) {
        println!("\n{}", style(text).bold().underlined());
    }

    pub fn status(&self, label: &str, status: HealthStatus) {
        println!("{}: {}", 
            style(label).bold(),
            status.color().apply_to(status.to_string())
        );
    }

    pub fn info(&self, label: &str, value: impl Display) {
        println!("{}: {}", style(label).bold(), value);
    }

    pub fn resource(&self, label: &str, used: u64, total: u64) {
        let percentage = (used as f32 / total as f32) * 100.0;
        let status = if percentage > 90.0 {
            HealthStatus::Bad
        } else if percentage > 70.0 {
            HealthStatus::Okay
        } else {
            HealthStatus::Good
        };

        println!("{}: {} / {} ({:.1}%) {}",
            style(label).bold(),
            self.format_bytes(used),
            self.format_bytes(total),
            percentage,
            status.color().apply_to("●")
        );
    }

    pub fn warning(&self, text: impl Display) {
        println!("{} {}", 
            style("WARNING:").yellow().bold(),
            text
        );
    }

    pub fn error(&self, text: impl Display) {
        println!("{} {}", 
            style("ERROR:").red().bold(),
            text
        );
    }

    fn format_bytes(&self, bytes: u64) -> String {
        const KB: u64 = 1024;
        const MB: u64 = KB * 1024;
        const GB: u64 = MB * 1024;

        if bytes >= GB {
            format!("{:.1}GB", bytes as f64 / GB as f64)
        } else if bytes >= MB {
            format!("{:.1}MB", bytes as f64 / MB as f64)
        } else if bytes >= KB {
            format!("{:.1}KB", bytes as f64 / KB as f64)
        } else {
            format!("{}B", bytes)
        }
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cli/src/output.rs

```rs
//! Output formatting utilities for CLI

use console::style;
use blast_core::{
    package::Package,
    version::Version,
};

/// Format a package for display
pub fn format_package(package: &Package) -> String {
    format!(
        "{} {}",
        style(package.name()).green(),
        style(package.version()).yellow()
    )
}

/// Format a version for display
pub fn format_version(version: &Version) -> String {
    style(version.to_string()).yellow().to_string()
}

/// Format a dependency tree
pub fn format_dependency_tree(package: &Package, depth: usize) -> String {
    let mut output = String::new();
    let indent = "  ".repeat(depth);
    
    output.push_str(&format!(
        "{}{}",
        indent,
        format_package(package)
    ));

    for (name, constraint) in package.metadata().dependencies.iter() {
        output.push_str(&format!(
            "\n{}└── {} {}",
            indent,
            style(name).blue(),
            style(constraint).dim()
        ));
    }

    output
}

/// Format an error message
pub fn format_error(msg: &str) -> String {
    style(format!("Error: {}", msg)).red().to_string()
}

/// Format a success message
pub fn format_success(msg: &str) -> String {
    style(format!("Success: {}", msg)).green().to_string()
}

/// Format a warning message
pub fn format_warning(msg: &str) -> String {
    style(format!("Warning: {}", msg)).yellow().to_string()
}

/// Format an info message
pub fn format_info(msg: &str) -> String {
    style(msg).blue().to_string()
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cli/src/progress.rs

```rs
//! Progress tracking utilities for CLI operations

use std::time::Duration;
use indicatif::{ProgressBar, ProgressStyle};
use console::style;
use blast_core::package::Package;

/// Manages progress bars for concurrent operations
pub struct ProgressManager {
    resolution_spinner: Option<ProgressBar>,
    installation_progress: Option<ProgressBar>,
}

impl ProgressManager {
    /// Create a new progress manager
    pub fn new() -> Self {
        Self {
            resolution_spinner: None,
            installation_progress: None,
        }
    }

    /// Start the resolution process
    pub fn start_resolution(&mut self) {
        let spinner = ProgressBar::new_spinner();
        spinner.set_style(
            ProgressStyle::default_spinner()
                .template("{spinner} {msg}")
                .unwrap(),
        );
        spinner.set_message("Resolving dependencies...");
        spinner.enable_steady_tick(Duration::from_millis(100));
        self.resolution_spinner = Some(spinner);
    }

    /// Finish the resolution process
    pub fn finish_resolution(&mut self) {
        if let Some(spinner) = self.resolution_spinner.take() {
            spinner.finish_with_message("Dependencies resolved");
        }
    }

    /// Start the installation process
    pub fn start_installation(&mut self, total: usize) {
        let progress = ProgressBar::new(total as u64);
        progress.set_style(
            ProgressStyle::default_bar()
                .template("{spinner:.green} [{bar:40.cyan/blue}] {pos}/{len} {msg}")
                .unwrap()
                .progress_chars("#>-"),
        );
        progress.set_message("Installing packages...");
        self.installation_progress = Some(progress);
    }

    /// Set the progress for a specific package
    pub fn set_package(&mut self, package: &Package) {
        if let Some(progress) = &self.installation_progress {
            progress.set_message(format!("Installing {}", style(package.id()).cyan()));
        }
    }

    /// Increment the installation progress
    pub fn increment(&mut self) {
        if let Some(progress) = &self.installation_progress {
            progress.inc(1);
        }
    }

    /// Finish the installation process
    pub fn finish_installation(&mut self) {
        if let Some(progress) = self.installation_progress.take() {
            progress.finish_with_message("Installation complete");
        }
    }
}

impl Default for ProgressManager {
    fn default() -> Self {
        Self::new()
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cli/src/commands/deactivate.rs

```rs
use blast_core::{
    config::BlastConfig,
    error::BlastResult,
};
use blast_daemon::{Daemon, DaemonConfig};
use tracing::{debug, info};

pub async fn execute(config: &BlastConfig) -> BlastResult<()> {
    debug!("Deactivating environment");

    // Create daemon configuration
    let daemon_config = DaemonConfig {
        max_pending_updates: 100,
        max_snapshot_age_days: 7,
        env_path: config.project_root.join("environments/default"),
        cache_path: config.project_root.join("cache"),
    };

    // Connect to daemon
    let daemon = Daemon::new(daemon_config).await?;

    // Deactivate current environment
    daemon.deactivate_environment().await?;

    // Get current state to show what was deactivated
    let state_manager = daemon.state_manager();
    let current_state = state_manager.read().await.get_current_state();

    info!("Deactivated environment: {}", current_state.name());
    info!("Run 'blast list' to see available environments");

    Ok(())
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cli/src/commands/start.rs

```rs
use std::path::PathBuf;
use blast_core::{
    config::BlastConfig,
    error::BlastResult,
    python::PythonVersion,
    security::{SecurityPolicy, IsolationLevel, ResourceLimits},
    state::EnvironmentState,
};
use blast_daemon::{
    DaemonConfig,
    Daemon,
};
use tracing::{debug, info};
use uuid::Uuid;

const SHELL_ACTIVATION_SCRIPT: &str = r#"
# Store old environment state
_OLD_PATH="$PATH"
_OLD_PS1="${PS1-}"
_OLD_PYTHON_PATH="${PYTHONPATH-}"

# Set up blast environment
export BLAST_ENV="{env_path}"
export BLAST_ENV_NAME="{env_name}"
export BLAST_PYTHON_VERSION="{python_version}"
export BLAST_ENV_PATH="{env_path}"
export PATH="{env_path}/bin:$PATH"
export PYTHONPATH="{env_path}/lib/python{python_major}/site-packages:$PYTHONPATH"

# Define the blast function for environment management
blast() {
    if [ "$1" = "deactivate" ]; then
        command blast deactivate > /dev/null 2>&1
        export PATH="$_OLD_PATH"
        export PS1="$_OLD_PS1"
        export PYTHONPATH="$_OLD_PYTHON_PATH"
        unset BLAST_ENV BLAST_ENV_NAME BLAST_PYTHON_VERSION BLAST_ENV_PATH _OLD_PATH _OLD_PS1 _OLD_PYTHON_PATH
        unset -f blast
    else
        BLAST_ACTIVE_ENV="{env_name}" BLAST_ENV_PATH="{env_path}" command blast "$@"
    fi
}

# Set up shell prompt
if [ -n "$ZSH_VERSION" ]; then
    setopt PROMPT_SUBST
    _OLD_PROMPT_COMMAND=${PROMPT_COMMAND:-}
    _blast_update_prompt() { PS1="(blast) ${PS1#\(blast\) }"; }
    precmd_functions+=(_blast_update_prompt)
elif [ -n "$BASH_VERSION" ]; then
    _OLD_PROMPT_COMMAND=${PROMPT_COMMAND:-}
    _blast_update_prompt() { PS1="(blast) ${PS1#\(blast\) }"; }
    PROMPT_COMMAND="_blast_update_prompt;${_OLD_PROMPT_COMMAND}"
else
    PS1="(blast) $PS1"
fi

hash -r 2>/dev/null"#;

/// Execute the start command
pub async fn execute(
    python: Option<String>,
    name: Option<String>,
    path: Option<PathBuf>,
    _env_vars: Vec<String>,
    config: &BlastConfig,
) -> BlastResult<()> {
    debug!("Starting environment creation");
    
    // Resolve environment path
    let env_path = path.unwrap_or_else(|| config.env_path());
    if !env_path.exists() {
        debug!("Creating environment directory");
        std::fs::create_dir_all(&env_path)?;
    }

    // Resolve environment name
    let env_name = name.unwrap_or_else(|| {
        env_path
            .file_name()
            .unwrap_or_default()
            .to_string_lossy()
            .to_string()
    });

    // Parse Python version
    let python_version = python
        .map(|v| PythonVersion::parse(&v))
        .transpose()?
        .unwrap_or_else(|| config.python_version.clone());

    debug!("Creating environment with Python {}", python_version);

    // Create daemon configuration
    let daemon_config = DaemonConfig {
        max_pending_updates: 100,
        max_snapshot_age_days: 7,
        env_path: env_path.clone(),
        cache_path: config.project_root.join("cache"),
    };

    // Initialize daemon
    let daemon = Daemon::new(daemon_config).await?;
    
    // Create security policy
    let security_policy = SecurityPolicy {
        isolation_level: IsolationLevel::Process,
        python_version: python_version.clone(),
        resource_limits: ResourceLimits::default(),
    };

    // Create environment
    let env = daemon.create_environment(&security_policy).await?;
    debug!("Created Python environment at {}", env.path().display());

    // Create environment state
    let env_state = EnvironmentState::new(
        env_name.clone(),
        python_version.clone(),
        Default::default(),
        Default::default(),
    );

    // Get state manager and ensure it's loaded
    let state_manager = daemon.state_manager();
    state_manager.write().await.load().await?;

    // Add environment to state manager
    state_manager.write().await.add_environment(env_name.clone(), env_state.clone()).await?;
    debug!("Added environment to state manager");

    // Set as active environment
    state_manager.write().await.set_active_environment(
        env_name.clone(),
        env.path().to_path_buf(),
        python_version.clone(),
    ).await?;
    debug!("Set as active environment");

    // Create initial checkpoint
    state_manager.write().await.create_checkpoint(
        Uuid::new_v4(),
        "Initial environment creation".to_string(),
        None,
    )?;
    debug!("Created initial checkpoint");

    // Generate shell script
    if std::env::var("BLAST_EVAL").is_ok() {
        let script = SHELL_ACTIVATION_SCRIPT
            .replace("{env_path}", &env.path().display().to_string())
            .replace("{env_name}", &env_name)
            .replace("{python_version}", &env.python_version().to_string())
            .replace("{python_major}", &env.python_version().major().to_string());

        println!("{}", script);
    }

    info!("Environment ready: {} (Python {})", env_name, python_version);
    Ok(())
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cli/src/commands/check.rs

```rs
use blast_core::{
    config::BlastConfig,
    error::BlastResult,
};
use blast_daemon::{Daemon, DaemonConfig};
use tracing::{debug, info};

/// Execute the check command
pub async fn execute(config: &BlastConfig) -> BlastResult<()> {
    debug!("Checking environment status");

    // Create daemon configuration
    let daemon_config = DaemonConfig {
        max_pending_updates: 100,
        max_snapshot_age_days: 7,
        env_path: config.project_root.join("environments/default"),
        cache_path: config.project_root.join("cache"),
    };

    // Connect to daemon
    let daemon = Daemon::new(daemon_config).await?;

    // Get current environment state
    let state_manager = daemon.state_manager();
    let state_guard = state_manager.read().await;
    let current_state = state_guard.get_current_state();

    // Get performance metrics
    let metrics = daemon.get_performance_metrics().await?;

    info!("Environment Status:");
    if current_state.name() == "default" {
        info!("  No active environment");
        return Ok(());
    }

    // Show environment details
    info!("  Name: {}", current_state.name());
    info!("  Python: {}", current_state.python_version);
    info!("  Status: {}", if current_state.is_active() { "Active" } else { "Inactive" });
    info!("  Packages: {}", current_state.packages.len());

    // Show performance metrics
    info!("\nPerformance Metrics:");
    info!("  Average pip install time: {:?}", metrics.avg_pip_install_time);
    info!("  Average sync time: {:?}", metrics.avg_sync_time);
    info!("  Cache hit rate: {:.1}%", metrics.cache_hit_rate * 100.0);

    // Show verification status
    if let Ok(verification) = state_guard.verify_state() {
        info!("\nVerification Status:");
        info!("  Verified: {}", verification.is_verified);
        if !verification.issues.is_empty() {
            info!("  Issues:");
            for issue in verification.issues {
                info!("    - {} ({:?})", issue.description, issue.severity);
                if let Some(context) = issue.context {
                    info!("      Context: {}", context);
                }
                if let Some(recommendation) = issue.recommendation {
                    info!("      Recommendation: {}", recommendation);
                }
            }
        }
    }

    Ok(())
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cli/src/commands/list.rs

```rs
use blast_core::{
    config::BlastConfig,
    error::BlastResult,
};
use blast_daemon::{Daemon, DaemonConfig};
use tracing::{debug, info};

/// Execute the list command
pub async fn execute(config: &BlastConfig) -> BlastResult<()> {
    debug!("Listing environments");

    // Create daemon configuration with resolved paths
    let daemon_config = DaemonConfig {
        max_pending_updates: 100,
        max_snapshot_age_days: 7,
        env_path: config.project_root.join("environments"),
        cache_path: config.project_root.join("cache"),
    };

    // Connect to daemon
    let daemon = Daemon::new(daemon_config).await?;

    // Get state manager and ensure it's loaded
    let state_manager = daemon.state_manager();
    let state = state_manager.read().await;
    state.load().await?;

    // Get active environment and environment list
    let active_env = state.get_active_environment().await?;
    let environments = state.list_environments().await?;
    debug!("Retrieved environment list");

    info!("Blast environments:");
    if environments.is_empty() {
        info!("  No environments found");
        return Ok(());
    }

    for (name, env) in environments {
        let status = if let Some(active) = &active_env {
            // Use the name getter method
            if name == active.name() {
                "*active*"
            } else {
                ""
            }
        } else {
            ""
        };

        // Get environment path relative to project root
        let env_path = state.get_environment_path(&name);
        let path_display = env_path.strip_prefix(&config.project_root)
            .map(|p| p.display().to_string())
            .unwrap_or_else(|_| env_path.display().to_string());

        info!(
            "  {} {} (Python {}) [{}]",
            name,
            status,
            env.python_version,
            path_display
        );
    }

    Ok(())
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cli/src/commands/clean.rs

```rs
use blast_core::{
    config::BlastConfig,
    error::BlastResult,
};
use blast_daemon::{Daemon, DaemonConfig};
use tracing::{debug, info};

/// Execute the clean command
pub async fn execute(config: &BlastConfig) -> BlastResult<()> {
    debug!("Cleaning environment");

    // Check if we're in a blast environment
    let env_name = match std::env::var("BLAST_ENV_NAME") {
        Ok(name) => name,
        Err(_) => {
            info!("Not in a blast environment");
            return Ok(());
        }
    };

    // Create daemon configuration
    let daemon_config = DaemonConfig {
        max_pending_updates: 100,
        max_snapshot_age_days: 7,
        env_path: config.project_root.join("environments/default"),
        cache_path: config.project_root.join("cache"),
    };

    // Connect to existing daemon
    let daemon = Daemon::new(daemon_config).await?;

    // Get active environment
    if let Some(env) = daemon.get_active_environment().await? {
        info!("Cleaning environment: {}", env_name);
        
        // Save current state for recovery if needed
        daemon.save_environment_state(&env).await?;
        
        // Remove all packages
        daemon.clean_environment(&env).await?;
        
        // Reinitialize environment
        daemon.reinitialize_environment(&env).await?;
        
        // Restore essential packages
        daemon.restore_essential_packages(&env).await?;

        info!("Environment cleaned and reinitialized");
    } else {
        info!("No active environment found");
    }

    Ok(())
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cli/src/commands/register.rs

```rs
use std::path::PathBuf;
use blast_core::{
    config::BlastConfig,
    error::BlastResult,
    state::EnvironmentState,
    python::PythonVersion,
};
use blast_daemon::{Daemon, DaemonConfig};
use tracing::{debug, info};
use std::collections::HashMap;

pub async fn execute(
    name: String,
    path: PathBuf,
    config: &BlastConfig,
) -> BlastResult<()> {
    debug!("Registering environment: {} at {}", name, path.display());

    // Create daemon configuration
    let daemon_config = DaemonConfig {
        max_pending_updates: 100,
        max_snapshot_age_days: 7,
        env_path: path.clone(),
        cache_path: config.project_root.join("cache"),
    };

    // Connect to daemon
    let daemon = Daemon::new(daemon_config).await?;

    // Get Python version from environment
    let python_version = if let Ok(version) = std::env::var("BLAST_PYTHON_VERSION") {
        PythonVersion::parse(&version)?
    } else {
        // Default to Python 3.8 if not specified
        PythonVersion::parse("3.8")?
    };

    // Create environment state
    let env_state = EnvironmentState::new(
        name.clone(),
        python_version,
        HashMap::new(), // Empty packages initially
        HashMap::new(), // Empty env vars initially
    );

    // Update state manager
    let state_manager = daemon.state_manager();
    state_manager.write().await.update_current_state(env_state.clone())?;

    // Register as active environment
    daemon.register_active_environment(name.clone()).await?;

    info!("Successfully registered environment:");
    info!("  Name: {}", name);
    info!("  Path: {}", path.display());
    info!("  Python: {}", python_version);

    Ok(())
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cli/src/commands/save.rs

```rs
use std::io::{self, Write};
use blast_core::{
    config::BlastConfig,
    error::{BlastError, BlastResult},
};
use blast_daemon::{Daemon, DaemonConfig};
use blast_image::{
    layer::{Layer as Image, LayerType},
    compression::{CompressionType, CompressionLevel},
    error::Error as ImageError,
};
use tracing::{debug, info, warn};

// Helper function to convert ImageError to BlastError
fn convert_image_error(err: ImageError) -> BlastError {
    BlastError::environment(err.to_string())
}

/// Execute the save command
pub async fn execute(name: Option<String>, config: &BlastConfig) -> BlastResult<()> {
    // Check if we're in a blast environment
    let env_name = match std::env::var("BLAST_ENV_NAME") {
        Ok(name) => name,
        Err(_) => {
            warn!("Not in a blast environment");
            return Ok(());
        }
    };

    // Get image name from parameter or prompt user
    let image_name = match name {
        Some(n) => n,
        None => {
            // Check if there's an existing image for this environment
            let daemon_config = DaemonConfig {
                max_pending_updates: 100,
                max_snapshot_age_days: 7,
                env_path: config.project_root.join("environments/default"),
                cache_path: config.project_root.join("cache"),
            };
            let daemon = Daemon::new(daemon_config).await?;
            let existing_images = daemon.list_environment_images(&env_name).await?;
            
            if let Some(existing) = existing_images.first() {
                // If there's an existing image, use its name for updating
                existing.name.clone()
            } else {
                // Prompt for name
                print!("Enter image name: ");
                io::stdout().flush()?;
                let mut input = String::new();
                io::stdin().read_line(&mut input)?;
                input.trim().to_string()
            }
        }
    };

    debug!("Saving environment image: {}", image_name);

    // Create .blast directory if it doesn't exist
    let blast_dir = config.project_root.join(".blast");
    if !blast_dir.exists() {
        std::fs::create_dir_all(&blast_dir)?;
    }

    // Create daemon configuration
    let daemon_config = DaemonConfig {
        max_pending_updates: 100,
        max_snapshot_age_days: 7,
        env_path: config.project_root.join("environments/default"),
        cache_path: config.project_root.join("cache"),
    };

    // Connect to daemon
    let daemon = Daemon::new(daemon_config).await?;

    // Get active environment
    if let Some(env) = daemon.get_active_environment().await? {
        // Create image from environment with options
        let mut image = Image::from_environment_with_options(
            &env,
            LayerType::Packages,
            CompressionType::Zstd,
            CompressionLevel::default(),
        ).map_err(convert_image_error)?;

        // Save image
        let image_path = blast_dir.join(&image_name);
        image.save(&image_path).map_err(convert_image_error)?;

        info!("Successfully saved environment image:");
        info!("  Name: {}", image_name);
        info!("  Environment: {}", env_name);
        info!("  Python: {}", env.python_version());
        info!("  Compression ratio: {:.2}x", image.compression_ratio());
        info!("  Total size: {} bytes", image.size());
        info!("  Path: {}", image_path.display());
    } else {
        warn!("No active environment found");
    }

    Ok(())
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cli/src/commands/mod.rs

```rs
//! CLI command implementations

pub mod start;
pub mod kill;
pub mod clean;
pub mod save;
pub mod load;
pub mod list;
pub mod check;

// Export command functions with clear names
pub use start::execute as execute_start;
pub use kill::execute as execute_kill;
pub use clean::execute as execute_clean;
pub use save::execute as execute_save;
pub use load::execute as execute_load;
pub use list::execute as execute_list;
pub use check::execute as execute_check; 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cli/src/commands/load.rs

```rs
use std::io::{self, Write};
use blast_core::{
    config::BlastConfig,
    error::{BlastError, BlastResult},
};
use blast_daemon::{Daemon, DaemonConfig};
use blast_image::{
    layer::Layer as Image,
    error::Error as ImageError,
};
use tracing::{debug, info, warn};

// Helper function to convert ImageError to BlastError
fn convert_image_error(err: ImageError) -> BlastError {
    BlastError::environment(err.to_string())
}

/// Execute the load command
pub async fn execute(name: Option<String>, config: &BlastConfig) -> BlastResult<()> {
    // Check if we're already in a blast environment
    if let Ok(current_env) = std::env::var("BLAST_ENV_NAME") {
        warn!("Already in blast environment: {}", current_env);
        warn!("Please run 'blast kill' first");
        return Ok(());
    }

    // Create daemon configuration
    let daemon_config = DaemonConfig {
        max_pending_updates: 100,
        max_snapshot_age_days: 7,
        env_path: config.project_root.join("environments/default"),
        cache_path: config.project_root.join("cache"),
    };

    // Connect to daemon
    let daemon = Daemon::new(daemon_config).await?;

    // Get list of available images
    let blast_dir = config.project_root.join(".blast");
    let available_images = daemon.list_all_images().await?;

    if available_images.is_empty() {
        warn!("No saved images found");
        return Ok(());
    }

    // Determine which image to load
    let image_name = match name {
        Some(n) => {
            // Verify the specified image exists
            if !available_images.iter().any(|img| img.name == n) {
                warn!("Image not found: {}", n);
                return Ok(());
            }
            n
        }
        None => {
            if available_images.len() == 1 {
                // Auto-load if only one image exists
                available_images[0].name.clone()
            } else {
                // Show available images and prompt for selection
                info!("Available images:");
                for (i, img) in available_images.iter().enumerate() {
                    info!(
                        "  {}. {} (created: {}, Python {})",
                        i + 1,
                        img.name,
                        img.created.format("%Y-%m-%d %H:%M:%S"),
                        img.python_version
                    );
                }

                print!("Enter image number to load (1-{}): ", available_images.len());
                io::stdout().flush()?;
                let mut input = String::new();
                io::stdin().read_line(&mut input)?;
                
                match input.trim().parse::<usize>() {
                    Ok(n) if n > 0 && n <= available_images.len() => {
                        available_images[n - 1].name.clone()
                    }
                    _ => {
                        warn!("Invalid selection");
                        return Ok(());
                    }
                }
            }
        }
    };

    let image_path = blast_dir.join(&image_name);
    debug!("Loading image: {}", image_name);

    // Load image
    let image = Image::load(&image_path, &image_path).map_err(convert_image_error)?;
    
    // Create environment from image
    let env = daemon.create_environment_from_image(&image).await?;

    // Set up environment variables
    std::env::set_var("BLAST_ENV_NAME", env.name().unwrap_or("unnamed"));
    std::env::set_var("BLAST_ENV_PATH", env.path().display().to_string());
    std::env::set_var("BLAST_SOCKET_PATH", format!("/tmp/blast_{}.sock", image_name));

    // Set up shell prompt
    if let Ok(shell) = std::env::var("SHELL") {
        if shell.contains("bash") {
            std::env::set_var("PS1", "(blast) $PS1");
        } else if shell.contains("zsh") {
            std::env::set_var("PROMPT", "(blast) $PROMPT");
        }
    }

    info!("Successfully loaded environment image:");
    info!("  Name: {}", image_name);
    info!("  Python: {}", env.python_version());
    info!("  Path: {}", env.path().display());
    info!("  Created: {}", image.metadata.created_at.to_rfc3339());

    Ok(())
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cli/src/commands/kill.rs

```rs
use blast_core::{
    config::BlastConfig,
    error::BlastResult,
};
use blast_daemon::{Daemon, DaemonConfig};
use tracing::{debug, info, warn};

/// Execute the kill command
pub async fn execute(
    force: bool,
    config: &BlastConfig,
) -> BlastResult<()> {
    debug!("Killing blast environment");
    debug!("Force: {}", force);

    // Check if we're in a blast environment
    let env_name = match std::env::var("BLAST_ENV_NAME") {
        Ok(name) => name,
        Err(_) => {
            warn!("Not in a blast environment");
            return Ok(());
        }
    };

    let env_path = match std::env::var("BLAST_ENV_PATH") {
        Ok(path) => path,
        Err(_) => {
            warn!("Environment path not found");
            return Ok(());
        }
    };

    // Create daemon configuration
    let daemon_config = DaemonConfig {
        max_pending_updates: 100,
        max_snapshot_age_days: 7,
        env_path: config.project_root.join("environments/default"),
        cache_path: config.project_root.join("cache"),
    };

    // Connect to existing daemon
    let daemon = Daemon::new(daemon_config).await?;

    // Get active environment
    if let Some(env) = daemon.get_active_environment().await? {
        if force {
            // Force kill
            daemon.destroy_environment(&env).await?;
        } else {
            // Graceful shutdown
            info!("Gracefully shutting down environment");
            
            // Save state if needed
            daemon.save_environment_state(&env).await?;
            
            // Stop monitoring
            daemon.stop_monitoring(&env).await?;
            
            // Destroy environment
            daemon.destroy_environment(&env).await?;
        }

        // Clean up environment variables
        std::env::remove_var("BLAST_ENV_NAME");
        std::env::remove_var("BLAST_ENV_PATH");
        std::env::remove_var("BLAST_SOCKET_PATH");

        // Restore shell prompt
        if let Ok(shell) = std::env::var("SHELL") {
            if shell.contains("bash") {
                std::env::remove_var("PS1");
            } else if shell.contains("zsh") {
                std::env::remove_var("PROMPT");
            }
        }

        info!("Killed blast environment:");
        info!("  Name: {}", env_name);
        info!("  Path: {}", env_path);
    } else {
        warn!("Environment not found: {}", env_name);
    }

    Ok(())
} 
```



---

> 📸 Generated with [Jockey CLI](https://github.com/saint0x/jockey-cli)
````

## File: /Users/saint/Desktop/blast-rs/crates/blast-cli/src/shell.rs

```rs
use std::env;
use std::path::PathBuf;
use blast_core::{
    error::BlastResult,
    shell_scripts::ActivationScripts,
};
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ShellState {
    original_path: Option<String>,
    original_pythonpath: Option<String>,
    original_prompt: Option<String>,
    active_env_name: Option<String>,
    active_env_path: Option<PathBuf>,
    socket_path: Option<String>,
}

impl ShellState {
    pub fn new() -> Self {
        Self {
            original_path: env::var("PATH").ok(),
            original_pythonpath: env::var("PYTHONPATH").ok(),
            original_prompt: env::var("PS1").or_else(|_| env::var("PROMPT")).ok(),
            active_env_name: None,
            active_env_path: None,
            socket_path: None,
        }
    }

    pub fn with_environment(mut self, env_name: String, env_path: PathBuf) -> Self {
        self.active_env_name = Some(env_name.clone());
        self.active_env_path = Some(env_path);
        self.socket_path = Some(format!("/tmp/blast_{}.sock", env_name));
        self
    }

    pub fn save(&self, state_path: &PathBuf) -> BlastResult<()> {
        let state_str = serde_json::to_string(self)?;
        std::fs::write(state_path, state_str)?;
        Ok(())
    }

    pub fn load(state_path: &PathBuf) -> BlastResult<Self> {
        let state_str = std::fs::read_to_string(state_path)?;
        let state = serde_json::from_str(&state_str)?;
        Ok(state)
    }
}

#[derive(Debug, Clone)]
pub enum Shell {
    Bash,
    Zsh,
    Fish,
    PowerShell,
    Unknown,
}

impl Shell {
    pub fn detect() -> Self {
        let shell_path = env::var("SHELL").unwrap_or_default();
        match shell_path.split('/').last().unwrap_or("") {
            "bash" => Shell::Bash,
            "zsh" => Shell::Zsh,
            "fish" => Shell::Fish,
            "pwsh" | "powershell" => Shell::PowerShell,
            _ => Shell::Unknown,
        }
    }

    pub fn get_activation_command(&self, env_path: &PathBuf) -> String {
        let bin_dir = env_path.join("bin");
        match self {
            Shell::Bash | Shell::Zsh => {
                format!("source {}/activate", bin_dir.display())
            }
            Shell::Fish => {
                format!("source {}/activate.fish", bin_dir.display())
            }
            Shell::PowerShell => {
                format!(". {}/activate.ps1", bin_dir.display())
            }
            Shell::Unknown => {
                format!("echo 'Unsupported shell detected. Please use bash, zsh, fish, or powershell.'")
            }
        }
    }

    pub fn get_deactivation_command(&self) -> &'static str {
        match self {
            Shell::Bash | Shell::Zsh | Shell::Fish => "deactivate",
            Shell::PowerShell => "deactivate",
            Shell::Unknown => "echo 'Unsupported shell detected.'",
        }
    }
}

pub struct EnvironmentActivator {
    shell: Shell,
    env_path: PathBuf,
    env_name: String,
    state: ShellState,
}

impl EnvironmentActivator {
    pub fn new(env_path: PathBuf, env_name: String) -> Self {
        let shell = Shell::detect();
        let state = ShellState::new().with_environment(env_name.clone(), env_path.clone());
        
        Self {
            shell,
            env_path,
            env_name,
            state,
        }
    }

    pub fn generate_activation_script(&self) -> String {
        let scripts = ActivationScripts::generate(&self.env_path, &self.env_name);
        match self.shell {
            Shell::Bash | Shell::Zsh => scripts.bash,
            Shell::Fish => scripts.fish,
            Shell::PowerShell => scripts.powershell,
            Shell::Unknown => "echo 'Unsupported shell detected. Please use bash, zsh, fish, or powershell.'".to_string(),
        }
    }

    pub fn generate_deactivation_script(&self) -> String {
        self.shell.get_deactivation_command().to_string()
    }

    pub fn save_state(&self) -> BlastResult<()> {
        let state_dir = dirs::cache_dir()
            .unwrap_or_else(|| PathBuf::from("/tmp"))
            .join("blast");
        
        std::fs::create_dir_all(&state_dir)?;
        
        let state_path = state_dir.join(format!("{}.json", self.env_name));
        self.state.save(&state_path)?;
        
        // Create daemon socket directory if it doesn't exist
        if let Some(socket_path) = self.get_socket_path() {
            if let Some(parent) = PathBuf::from(socket_path).parent() {
                std::fs::create_dir_all(parent)?;
            }
        }
        
        Ok(())
    }

    pub fn get_socket_path(&self) -> Option<&str> {
        self.state.socket_path.as_deref()
    }

    pub fn is_daemon_running(&self) -> bool {
        if let Some(socket_path) = self.get_socket_path() {
            std::path::Path::new(socket_path).exists()
        } else {
            false
        }
    }

    pub fn ensure_daemon_running(&self) -> bool {
        self.is_daemon_running()
    }

    pub fn env_path(&self) -> &PathBuf {
        &self.env_path
    }

    pub fn env_name(&self) -> &str {
        &self.env_name
    }

    pub fn shell(&self) -> &Shell {
        &self.shell
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cli/src/lib.rs

```rs
//! Command-line interface for the Blast Python environment manager.

use std::path::PathBuf;
use anyhow::Result;
use clap::{Parser, Subcommand};
use tracing::error;
use once_cell::sync::OnceCell;

use blast_core::config::BlastConfig;
use blast_core::python::PythonVersion;

mod commands;
mod output;
mod progress;
pub mod shell;
mod setup;

pub use commands::*;
pub use output::*;
pub use progress::*;

static LOGGING: OnceCell<()> = OnceCell::new();

fn init_logging(eval_mode: bool) {
    let _ = LOGGING.get_or_init(|| {
        let builder = tracing_subscriber::fmt()
            .with_env_filter(
                tracing_subscriber::EnvFilter::from_default_env()
                    .add_directive(if eval_mode {
                        tracing::Level::INFO.into()
                    } else {
                        tracing::Level::DEBUG.into()
                    })
            );

        // Configure based on mode
        let builder = if eval_mode {
            builder
                .with_target(false)
                .with_ansi(false)
                .with_thread_ids(false)
                .with_thread_names(false)
                .with_file(false)
                .with_line_number(false)
                .with_span_events(tracing_subscriber::fmt::format::FmtSpan::NONE)
        } else {
            builder
                .with_target(false)
                .with_ansi(true)
                .with_thread_ids(true)
                .with_thread_names(true)
                .with_file(true)
                .with_line_number(true)
                .with_span_events(tracing_subscriber::fmt::format::FmtSpan::ACTIVE)
        };

        builder.try_init().expect("Failed to initialize logging");
    });
}

/// CLI arguments parser
#[derive(Parser)]
#[command(author, version, about, long_about = None)]
pub struct Cli {
    /// Config file path
    #[arg(short, long, value_name = "FILE")]
    config: Option<PathBuf>,

    /// Verbose output
    #[arg(short, long)]
    verbose: bool,

    #[command(subcommand)]
    pub command: Commands,
}

#[derive(Subcommand)]
pub enum Commands {
    /// Start a new blast environment (stacks if one exists)
    Start {
        /// Python version to use
        #[arg(short, long)]
        python: Option<String>,

        /// Environment name
        #[arg(short, long)]
        name: Option<String>,

        /// Environment path
        #[arg(short, long)]
        path: Option<PathBuf>,

        /// Additional environment variables
        #[arg(short, long)]
        env: Vec<String>,
    },

    /// Kill the current blast environment
    Kill {
        /// Force kill without graceful shutdown
        #[arg(short, long)]
        force: bool,
    },

    /// Clean and reinstall all dependencies
    Clean,

    /// Save environment image
    Save {
        /// Image name
        #[arg(short, long)]
        name: Option<String>,
    },

    /// Load environment image
    Load {
        /// Image name
        #[arg(short, long)]
        name: Option<String>,
    },

    /// List all environments from most to least recently used
    List,

    /// Check environment status and health
    Check,
}

/// Run the CLI application
pub async fn run() -> Result<()> {
    let cli = Cli::parse();

    // Initialize logging
    init_logging(cli.verbose);

    // Check for first run and initialize if needed
    if !is_initialized() {
        setup::initialize()?;
        mark_as_initialized()?;
    }

    // Load or create config
    let config = if let Some(path) = cli.config {
        BlastConfig::from_file(path)?
    } else {
        let current_dir = std::env::current_dir()?;
        BlastConfig::new(
            current_dir.file_name().unwrap().to_string_lossy().to_string(),
            "0.1.0",
            PythonVersion::parse("3.8")?,
            current_dir,
        )
    };

    // Execute command
    match cli.command {
        Commands::Start {
            python,
            name,
            path,
            env,
        } => {
            commands::execute_start(python, name, path, env, &config).await?;
        }
        Commands::Kill { force } => {
            let env_name = std::env::var("BLAST_ENV_NAME")
                .unwrap_or_else(|_| "default".to_string());
            commands::execute_kill(env_name, force, &config).await?;
        }
        Commands::Clean => {
            commands::execute_clean(&config).await?;
        }
        Commands::Save { name } => {
            commands::execute_save(name, &config).await?;
        }
        Commands::Load { name } => {
            commands::execute_load(name, &config).await?;
        }
        Commands::List => {
            commands::execute_list(&config).await?;
        }
        Commands::Check => {
            commands::execute_check(&config).await?;
        }
    }

    Ok(())
}

fn is_initialized() -> bool {
    let config_dir = dirs::config_dir()
        .map(|d| d.join("blast"))
        .unwrap_or_else(|| PathBuf::from(".blast"));
    
    config_dir.join(".initialized").exists()
}

fn mark_as_initialized() -> Result<()> {
    let config_dir = dirs::config_dir()
        .map(|d| d.join("blast"))
        .unwrap_or_else(|| PathBuf::from(".blast"));
    
    std::fs::create_dir_all(&config_dir)?;
    std::fs::write(config_dir.join(".initialized"), "")?;
    Ok(())
}

/// Main entry point for the CLI binary
pub fn main() {
    // Initialize logging with default settings
    init_logging(false);

    if let Err(e) = tokio::runtime::Runtime::new()
        .unwrap()
        .block_on(run())
    {
        error!("Error: {}", e);
        std::process::exit(1);
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cli/src/output/logger.rs

```rs
use console::{style, Term};
use std::fmt::Display;

pub struct Logger {
    term: Term,
}

#[derive(Debug, Clone, Copy)]
pub enum HealthStatus {
    Good,
    Okay,
    Bad,
}

impl HealthStatus {
    pub fn from_resource_usage(cpu_percent: f32, memory_percent: f32, disk_percent: f32) -> Self {
        if cpu_percent > 90.0 || memory_percent > 90.0 || disk_percent > 90.0 {
            HealthStatus::Bad
        } else if cpu_percent > 70.0 || memory_percent > 70.0 || disk_percent > 70.0 {
            HealthStatus::Okay
        } else {
            HealthStatus::Good
        }
    }

    pub fn color(&self) -> console::Style {
        match self {
            HealthStatus::Good => style().green(),
            HealthStatus::Okay => style().yellow(),
            HealthStatus::Bad => style().red(),
        }
    }
}

impl Display for HealthStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            HealthStatus::Good => write!(f, "good"),
            HealthStatus::Okay => write!(f, "okay"),
            HealthStatus::Bad => write!(f, "bad"),
        }
    }
}

impl Logger {
    pub fn new() -> Self {
        Self {
            term: Term::stdout(),
        }
    }

    pub fn header(&self, text: &str) {
        let width = self.term.size().1 as usize;
        let padding = "=".repeat((width - text.len() - 2) / 2);
        println!("\n{} {} {}\n", padding, style(text).bold(), padding);
    }

    pub fn section(&self, text: &str) {
        println!("\n{}", style(text).bold().underlined());
    }

    pub fn status(&self, label: &str, status: HealthStatus) {
        println!("{}: {}", 
            style(label).bold(),
            status.color().apply_to(status.to_string())
        );
    }

    pub fn info(&self, label: &str, value: impl Display) {
        println!("{}: {}", style(label).bold(), value);
    }

    pub fn resource(&self, label: &str, used: u64, total: u64) {
        let percentage = (used as f32 / total as f32) * 100.0;
        let status = if percentage > 90.0 {
            HealthStatus::Bad
        } else if percentage > 70.0 {
            HealthStatus::Okay
        } else {
            HealthStatus::Good
        };

        println!("{}: {} / {} ({:.1}%) {}",
            style(label).bold(),
            self.format_bytes(used),
            self.format_bytes(total),
            percentage,
            status.color().apply_to("●")
        );
    }

    pub fn warning(&self, text: impl Display) {
        println!("{} {}", 
            style("WARNING:").yellow().bold(),
            text
        );
    }

    pub fn error(&self, text: impl Display) {
        println!("{} {}", 
            style("ERROR:").red().bold(),
            text
        );
    }

    fn format_bytes(&self, bytes: u64) -> String {
        const KB: u64 = 1024;
        const MB: u64 = KB * 1024;
        const GB: u64 = MB * 1024;

        if bytes >= GB {
            format!("{:.1}GB", bytes as f64 / GB as f64)
        } else if bytes >= MB {
            format!("{:.1}MB", bytes as f64 / MB as f64)
        } else if bytes >= KB {
            format!("{:.1}KB", bytes as f64 / KB as f64)
        } else {
            format!("{}B", bytes)
        }
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cli/src/output.rs

```rs
//! Output formatting utilities for CLI

use console::style;
use blast_core::{
    package::Package,
    version::Version,
};

/// Format a package for display
pub fn format_package(package: &Package) -> String {
    format!(
        "{} {}",
        style(package.name()).green(),
        style(package.version()).yellow()
    )
}

/// Format a version for display
pub fn format_version(version: &Version) -> String {
    style(version.to_string()).yellow().to_string()
}

/// Format a dependency tree
pub fn format_dependency_tree(package: &Package, depth: usize) -> String {
    let mut output = String::new();
    let indent = "  ".repeat(depth);
    
    output.push_str(&format!(
        "{}{}",
        indent,
        format_package(package)
    ));

    for (name, constraint) in package.metadata().dependencies.iter() {
        output.push_str(&format!(
            "\n{}└── {} {}",
            indent,
            style(name).blue(),
            style(constraint).dim()
        ));
    }

    output
}

/// Format an error message
pub fn format_error(msg: &str) -> String {
    style(format!("Error: {}", msg)).red().to_string()
}

/// Format a success message
pub fn format_success(msg: &str) -> String {
    style(format!("Success: {}", msg)).green().to_string()
}

/// Format a warning message
pub fn format_warning(msg: &str) -> String {
    style(format!("Warning: {}", msg)).yellow().to_string()
}

/// Format an info message
pub fn format_info(msg: &str) -> String {
    style(msg).blue().to_string()
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cli/src/progress.rs

```rs
//! Progress tracking utilities for CLI operations

use std::time::Duration;
use indicatif::{ProgressBar, ProgressStyle};
use console::style;
use blast_core::package::Package;

/// Manages progress bars for concurrent operations
pub struct ProgressManager {
    resolution_spinner: Option<ProgressBar>,
    installation_progress: Option<ProgressBar>,
}

impl ProgressManager {
    /// Create a new progress manager
    pub fn new() -> Self {
        Self {
            resolution_spinner: None,
            installation_progress: None,
        }
    }

    /// Start the resolution process
    pub fn start_resolution(&mut self) {
        let spinner = ProgressBar::new_spinner();
        spinner.set_style(
            ProgressStyle::default_spinner()
                .template("{spinner} {msg}")
                .unwrap(),
        );
        spinner.set_message("Resolving dependencies...");
        spinner.enable_steady_tick(Duration::from_millis(100));
        self.resolution_spinner = Some(spinner);
    }

    /// Finish the resolution process
    pub fn finish_resolution(&mut self) {
        if let Some(spinner) = self.resolution_spinner.take() {
            spinner.finish_with_message("Dependencies resolved");
        }
    }

    /// Start the installation process
    pub fn start_installation(&mut self, total: usize) {
        let progress = ProgressBar::new(total as u64);
        progress.set_style(
            ProgressStyle::default_bar()
                .template("{spinner:.green} [{bar:40.cyan/blue}] {pos}/{len} {msg}")
                .unwrap()
                .progress_chars("#>-"),
        );
        progress.set_message("Installing packages...");
        self.installation_progress = Some(progress);
    }

    /// Set the progress for a specific package
    pub fn set_package(&mut self, package: &Package) {
        if let Some(progress) = &self.installation_progress {
            progress.set_message(format!("Installing {}", style(package.id()).cyan()));
        }
    }

    /// Increment the installation progress
    pub fn increment(&mut self) {
        if let Some(progress) = &self.installation_progress {
            progress.inc(1);
        }
    }

    /// Finish the installation process
    pub fn finish_installation(&mut self) {
        if let Some(progress) = self.installation_progress.take() {
            progress.finish_with_message("Installation complete");
        }
    }
}

impl Default for ProgressManager {
    fn default() -> Self {
        Self::new()
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cli/src/main.rs

```rs
use blast_cli;

fn main() {
    blast_cli::main();
}
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cli/src/shell_scripts.rs

```rs
use std::path::PathBuf;

/// Shell activation script templates for different shells
pub struct ShellScripts;

impl ShellScripts {
    /// Generate activation script for bash/zsh shells
    pub fn bash_zsh(env_path: &PathBuf, env_name: &str) -> String {
        format!(
            r#"#!/bin/bash
# Blast environment activation script for bash/zsh

deactivate () {{
    # reset old environment variables
    if [ -n "$_OLD_BLAST_PATH" ] ; then
        PATH="$_OLD_BLAST_PATH"
        export PATH
        unset _OLD_BLAST_PATH
    fi

    if [ -n "$_OLD_BLAST_PS1" ] ; then
        PS1="$_OLD_BLAST_PS1"
        export PS1
        unset _OLD_BLAST_PS1
    fi

    if [ -n "$BLAST_ENV" ] ; then
        unset BLAST_ENV
    fi

    if [ -n "$BLAST_ENV_NAME" ] ; then
        unset BLAST_ENV_NAME
    fi

    if [ ! "$1" = "nondestructive" ] ; then
        # Self destruct!
        unset -f deactivate
    fi
}}

# unset irrelevant variables
deactivate nondestructive

_OLD_BLAST_PATH="$PATH"
_OLD_BLAST_PS1="${{PS1:-}}"
BLAST_ENV="{}"
BLAST_ENV_NAME="{}"

export BLAST_ENV
export BLAST_ENV_NAME
export _OLD_BLAST_PATH
export _OLD_BLAST_PS1

PATH="$BLAST_ENV/bin:$PATH"
export PATH

if [ -z "$BLAST_DISABLE_PROMPT" ] ; then
    PS1="(blast:$BLAST_ENV_NAME) $PS1"
    export PS1
fi

# This should detect bash and zsh, which have a hash command that must
# be called to get it to forget past commands.  Without forgetting
# past commands the $PATH changes we made may not be respected
if [ -n "$BASH" -o -n "$ZSH_VERSION" ] ; then
    hash -r 2>/dev/null
fi
"#,
            env_path.display(),
            env_name
        )
    }

    /// Generate activation script for fish shell
    pub fn fish(env_path: &PathBuf, env_name: &str) -> String {
        format!(
            r#"# Blast environment activation script for fish shell

function deactivate  -d "Exit blast environment and return to normal shell environment"
    # reset old environment variables
    if test -n "$_OLD_BLAST_PATH"
        set -gx PATH $_OLD_BLAST_PATH
        set -e _OLD_BLAST_PATH
    end

    if test -n "$_OLD_BLAST_PS1"
        functions -c $_OLD_BLAST_PS1 fish_prompt
        functions -e _OLD_BLAST_PS1
    end

    if test -n "$BLAST_ENV"
        set -e BLAST_ENV
    end

    if test -n "$BLAST_ENV_NAME"
        set -e BLAST_ENV_NAME
    end

    if test "$argv[1]" != "nondestructive"
        # Self destruct!
        functions -e deactivate
    end
end

# Unset irrelevant variables
deactivate nondestructive

set -gx BLAST_ENV "{}"
set -gx BLAST_ENV_NAME "{}"

set -gx _OLD_BLAST_PATH $PATH
set -gx PATH "$BLAST_ENV/bin" $PATH

if not set -q BLAST_DISABLE_PROMPT
    functions -c fish_prompt _old_fish_prompt
    function fish_prompt
        if test -n "(blast)"
            printf "%s%s" "(blast:$BLAST_ENV_NAME) " (_old_fish_prompt)
        else
            _old_fish_prompt
        end
    end
end
"#,
            env_path.display(),
            env_name
        )
    }

    /// Generate activation script for PowerShell
    pub fn powershell(env_path: &PathBuf, env_name: &str) -> String {
        format!(
            r#"# Blast environment activation script for PowerShell

function global:deactivate ([switch]$NonDestructive) {{
    if (Test-Path variable:_OLD_BLAST_PATH) {{
        $env:PATH = $_OLD_BLAST_PATH
        Remove-Variable "_OLD_BLAST_PATH" -Scope global
    }}

    if (Test-Path variable:_OLD_BLAST_PROMPT) {{
        $env:PROMPT = $_OLD_BLAST_PROMPT
        Remove-Variable "_OLD_BLAST_PROMPT" -Scope global
    }}

    if (Test-Path env:BLAST_ENV) {{
        Remove-Item env:BLAST_ENV
    }}

    if (Test-Path env:BLAST_ENV_NAME) {{
        Remove-Item env:BLAST_ENV_NAME
    }}

    if (!$NonDestructive) {{
        # Self destruct!
        Remove-Item function:deactivate
    }}
}}

deactivate -NonDestructive

$_OLD_BLAST_PATH = $env:PATH
$_OLD_BLAST_PROMPT = $env:PROMPT

$env:BLAST_ENV = "{}"
$env:BLAST_ENV_NAME = "{}"
$env:PATH = "$env:BLAST_ENV\bin;$env:PATH"

if (!(Test-Path env:BLAST_DISABLE_PROMPT)) {{
    $env:PROMPT = "(blast:$env:BLAST_ENV_NAME) " + $env:PROMPT
}}
"#,
            env_path.display(),
            env_name
        )
    }

    /// Generate activation script for csh shell
    pub fn csh(env_path: &PathBuf, env_name: &str) -> String {
        format!(
            r#"# Blast environment activation script for csh shell

alias deactivate 'test $?_OLD_BLAST_PATH != 0 && setenv PATH "$_OLD_BLAST_PATH" && unset _OLD_BLAST_PATH; rehash; test $?_OLD_BLAST_PROMPT != 0 && set prompt="$_OLD_BLAST_PROMPT" && unset _OLD_BLAST_PROMPT; unsetenv BLAST_ENV; unsetenv BLAST_ENV_NAME; test "\!:*" != "nondestructive" && unalias deactivate'

# Unset irrelevant variables
deactivate nondestructive

setenv BLAST_ENV "{}"
setenv BLAST_ENV_NAME "{}"

set _OLD_BLAST_PATH="$PATH"
setenv PATH "$BLAST_ENV/bin:$PATH"

if ("" != "") then
    set _OLD_BLAST_PROMPT="$prompt"
endif

if (! "$?BLAST_DISABLE_PROMPT") then
    set prompt = "(blast:$BLAST_ENV_NAME) $prompt"
endif

rehash
"#,
            env_path.display(),
            env_name
        )
    }
}

/// Represents the activation scripts for a blast environment
pub struct ActivationScripts {
    pub bash: String,
    pub fish: String,
    pub csh: String,
    pub powershell: String,
}

impl ActivationScripts {
    /// Generate all activation scripts for an environment
    pub fn generate(env_path: &PathBuf, env_name: &str) -> Self {
        Self {
            bash: ShellScripts::bash_zsh(env_path, env_name),
            fish: ShellScripts::fish(env_path, env_name),
            csh: ShellScripts::csh(env_path, env_name),
            powershell: ShellScripts::powershell(env_path, env_name),
        }
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cli/src/commands/deactivate.rs

```rs
use blast_core::{
    config::BlastConfig,
    error::BlastResult,
};
use blast_daemon::{Daemon, DaemonConfig};
use tracing::{debug, info};

pub async fn execute(config: &BlastConfig) -> BlastResult<()> {
    debug!("Deactivating environment");

    // Create daemon configuration
    let daemon_config = DaemonConfig {
        max_pending_updates: 100,
        max_snapshot_age_days: 7,
        env_path: config.project_root.join("environments/default"),
        cache_path: config.project_root.join("cache"),
    };

    // Connect to daemon
    let daemon = Daemon::new(daemon_config).await?;

    // Deactivate current environment
    daemon.deactivate_environment().await?;

    // Get current state to show what was deactivated
    let state_manager = daemon.state_manager();
    let current_state = state_manager.read().await.get_current_state();

    info!("Deactivated environment: {}", current_state.name());
    info!("Run 'blast list' to see available environments");

    Ok(())
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cli/src/commands/start.rs

```rs
use std::path::PathBuf;
use blast_core::{
    config::BlastConfig,
    error::BlastResult,
    python::PythonVersion,
    security::{SecurityPolicy, IsolationLevel, ResourceLimits},
    Version,
};
use blast_daemon::{Daemon, DaemonConfig};
use tracing::{debug, info, warn};
use uuid::Uuid;
use crate::shell::EnvironmentActivator;
use std::collections::HashMap;
use tokio::process::Command;

/// Execute the start command
pub async fn execute(
    python: Option<String>,
    name: Option<String>,
    path: Option<PathBuf>,
    env_vars: Vec<String>,
    config: &BlastConfig,
) -> BlastResult<()> {
    // If BLAST_EVAL is set, we're in the activation phase
    if std::env::var("BLAST_EVAL").is_ok() {
        return handle_activation_phase(name, path, config).await;
    }

    // Otherwise, we're in the setup phase
    handle_setup_phase(python, name, path, env_vars, config).await
}

/// Handle the activation phase - outputs shell script for environment activation
async fn handle_activation_phase(
    name: Option<String>,
    path: Option<PathBuf>,
    config: &BlastConfig,
) -> BlastResult<()> {
    let env_path = path.unwrap_or_else(|| config.env_path());
    let env_name = name.unwrap_or_else(|| {
        env_path
            .file_name()
            .unwrap_or_default()
            .to_string_lossy()
            .to_string()
    });

    let activator = EnvironmentActivator::new(env_path, env_name);
    
    // Ensure daemon is running
    if !activator.is_daemon_running() {
        // Initialize and start daemon
        let daemon_config = DaemonConfig {
            max_pending_updates: 100,
            max_snapshot_age_days: 7,
            env_path: activator.env_path().to_path_buf(),
            cache_path: config.project_root.join("cache"),
        };

        let daemon = Daemon::new(daemon_config).await?;
        start_background(&daemon).await?;
    }

    // Save shell state
    activator.save_state()?;

    // Output activation script
    println!("{}", activator.generate_activation_script());
    Ok(())
}

/// Handle the setup phase - creates the environment and starts the daemon
async fn handle_setup_phase(
    python: Option<String>,
    name: Option<String>,
    path: Option<PathBuf>,
    env_vars: Vec<String>,
    config: &BlastConfig,
) -> BlastResult<()> {
    debug!("Starting environment creation");
    
    // Check if we're already in a blast environment
    if let Ok(current_env) = std::env::var("BLAST_ENV_NAME") {
        warn!("Already in blast environment: {}", current_env);
        return Ok(());
    }
    
    // Resolve environment path
    let env_path = path.unwrap_or_else(|| config.env_path());
    if !env_path.exists() {
        debug!("Creating environment directory");
        std::fs::create_dir_all(&env_path)?;
    }

    // Resolve environment name
    let env_name = name.unwrap_or_else(|| {
        env_path
            .file_name()
            .unwrap_or_default()
            .to_string_lossy()
            .to_string()
    });

    // Parse Python version
    let python_version = python
        .map(|v| PythonVersion::parse(&v))
        .transpose()?
        .unwrap_or_else(|| config.python_version.clone());

    debug!("Creating environment with Python {}", python_version);

    // Create daemon configuration
    let daemon_config = DaemonConfig {
        max_pending_updates: 100,
        max_snapshot_age_days: 7,
        env_path: env_path.clone(),
        cache_path: config.project_root.join("cache"),
    };

    // Initialize daemon
    let daemon = Daemon::new(daemon_config).await?;
    
    // Create security policy
    let security_policy = SecurityPolicy {
        isolation_level: IsolationLevel::Process,
        python_version: python_version.clone(),
        resource_limits: ResourceLimits::default(),
    };

    // Create environment
    let env = daemon.create_environment(&security_policy).await?;
    debug!("Created Python environment at {}", env.path().display());

    // Create environment state
    let env_vars: HashMap<String, Version> = env_vars
        .into_iter()
        .filter_map(|var| {
            let parts: Vec<&str> = var.split('=').collect();
            if parts.len() == 2 {
                Version::parse(parts[1]).ok().map(|version| (parts[0].to_string(), version))
            } else {
                None
            }
        })
        .collect();

    let env_state = blast_core::state::EnvironmentState::new(
        env_name.clone(),
        python_version.clone(),
        env_vars,
        Default::default(),
    );

    // Get state manager and ensure it's loaded
    let state_manager = daemon.state_manager();
    state_manager.write().await.load().await?;

    // Add environment to state manager
    state_manager.write().await.add_environment(env_name.clone(), env_state.clone()).await?;
    debug!("Added environment to state manager");

    // Set as active environment
    state_manager.write().await.set_active_environment(
        env_name.clone(),
        env.path().to_path_buf(),
        python_version.clone(),
    ).await?;
    debug!("Set as active environment");

    // Create initial checkpoint
    state_manager.write().await.create_checkpoint(
        Uuid::new_v4(),
        "Initial environment creation".to_string(),
        None,
    ).await?;
    debug!("Created initial checkpoint");

    // Create and save shell state
    let activator = EnvironmentActivator::new(
        env.path().to_path_buf(),
        env_name.clone(),
    );
    activator.save_state()?;

    info!("Environment ready: {} (Python {})", env_name, python_version);

    // Start daemon in background
    start_background(&daemon).await?;

    // Re-execute with BLAST_EVAL set to get shell activation
    let current_exe = std::env::current_exe()?;
    let mut cmd = Command::new(current_exe);
    cmd.arg("start")
        .env("BLAST_EVAL", "1")
        .env("BLAST_ENV_NAME", env_name)
        .env("BLAST_ENV_PATH", env.path());

    let output = cmd.output().await?;
    println!("{}", String::from_utf8_lossy(&output.stdout));

    Ok(())
}

async fn start_background(daemon: &Daemon) -> BlastResult<()> {
    // Start the daemon's background service
    daemon.start_background().await?;

    // If we're not already running as a daemon process
    if std::env::var("BLAST_DAEMON").is_err() {
        // Get current executable path
        let exe_path = std::env::current_exe()?;
        
        // Create command to run daemon in background
        let mut cmd = Command::new(exe_path);
        cmd.arg("daemon")
           .env("BLAST_DAEMON", "1")
           .stdin(std::process::Stdio::null())
           .stdout(std::process::Stdio::null())
           .stderr(std::process::Stdio::null());

        // Create a pid file to track the daemon process
        let pid_file = std::path::Path::new("/tmp/blast").join("daemon.pid");
        if !pid_file.parent().unwrap().exists() {
            std::fs::create_dir_all(pid_file.parent().unwrap())?;
        }

        // Spawn the process
        let child = cmd.spawn()?;
        
        // Write PID to file if available
        if let Some(pid) = child.id() {
            std::fs::write(&pid_file, pid.to_string())?;
        }

        // Don't wait for child, let it run in background
        tokio::spawn(async move {
            let _ = child.wait_with_output().await;
            // Clean up PID file when process exits
            let _ = std::fs::remove_file(&pid_file);
        });

        // Brief pause to ensure daemon is started
        tokio::time::sleep(std::time::Duration::from_millis(100)).await;
    }
    
    Ok(())
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cli/src/commands/check.rs

```rs
use blast_core::{
    config::BlastConfig,
    error::BlastResult,
};
use blast_daemon::{Daemon, DaemonConfig};
use tracing::{debug, info};

/// Execute the check command
pub async fn execute(config: &BlastConfig) -> BlastResult<()> {
    debug!("Checking environment status");

    // Create daemon configuration
    let daemon_config = DaemonConfig {
        max_pending_updates: 100,
        max_snapshot_age_days: 7,
        env_path: config.project_root.join("environments/default"),
        cache_path: config.project_root.join("cache"),
    };

    // Connect to daemon
    let daemon = Daemon::new(daemon_config).await?;

    // Get current environment state
    let state_manager = daemon.state_manager();
    let state_guard = state_manager.read().await;
    let current_state = state_guard.get_current_state().await?;

    // Get activation state
    let _activation_state = daemon.get_activation_state().await?;

    info!("Environment Status:");
    if !current_state.is_active() {
        info!("  No active environment");
        return Ok(());
    }

    // Show environment details
    info!("  Name: {}", current_state.name());
    info!("  Python: {}", current_state.python_version);
    info!("  Status: Active");
    info!("  Packages: {}", current_state.packages.len());

    // List environments to get package count
    let environments = daemon.list_environments().await?;
    if let Some(env) = environments.iter().find(|e| e.name == current_state.name()) {
        info!("  Path: {}", env.path.display());
    }

    // Show verification status
    if let Some(verification) = current_state.verification.as_ref() {
        info!("\nVerification Status:");
        info!("  Verified: {}", verification.is_verified);
        if !verification.issues.is_empty() {
            info!("  Issues:");
            for issue in &verification.issues {
                info!("    - {} ({:?})", issue.description, issue.severity);
                if let Some(context) = &issue.context {
                    info!("      Context: {}", context);
                }
                if let Some(recommendation) = &issue.recommendation {
                    info!("      Recommendation: {}", recommendation);
                }
            }
        }
    }

    Ok(())
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cli/src/commands/list.rs

```rs
use blast_core::{
    config::BlastConfig,
    error::BlastResult,
};
use blast_daemon::{Daemon, DaemonConfig};
use tracing::{debug, info};

/// Execute the list command
pub async fn execute(config: &BlastConfig) -> BlastResult<()> {
    debug!("Listing environments");

    // Create daemon configuration with resolved paths
    let daemon_config = DaemonConfig {
        max_pending_updates: 100,
        max_snapshot_age_days: 7,
        env_path: config.project_root.join("environments"),
        cache_path: config.project_root.join("cache"),
    };

    // Connect to daemon
    let daemon = Daemon::new(daemon_config).await?;

    // Get environment list
    let environments = daemon.list_environments().await?;
    debug!("Retrieved environment list");

    // Get current state to check which environment is active
    let state_manager = daemon.state_manager();
    let state_guard = state_manager.read().await;
    let current_state = state_guard.get_current_state().await?;

    info!("Blast environments:");
    if environments.is_empty() {
        info!("  No environments found");
        return Ok(());
    }

    for env in environments {
        let status = if current_state.is_active() && env.name == current_state.name() {
            "*active*"
        } else {
            ""
        };

        info!(
            "  {} {} (Python {}) [{}]",
            env.name,
            status,
            env.python_version,
            env.path.display()
        );
    }

    Ok(())
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cli/src/commands/clean.rs

```rs
use blast_core::{
    config::BlastConfig,
    error::BlastResult,
};
use blast_daemon::{Daemon, DaemonConfig};
use tracing::{debug, info};

/// Execute the clean command
pub async fn execute(config: &BlastConfig) -> BlastResult<()> {
    debug!("Cleaning environment");

    // Check if we're in a blast environment
    let env_name = match std::env::var("BLAST_ENV_NAME") {
        Ok(name) => name,
        Err(_) => {
            info!("Not in a blast environment");
            return Ok(());
        }
    };

    // Create daemon configuration
    let daemon_config = DaemonConfig {
        max_pending_updates: 100,
        max_snapshot_age_days: 7,
        env_path: config.project_root.join("environments/default"),
        cache_path: config.project_root.join("cache"),
    };

    // Connect to existing daemon
    let daemon = Daemon::new(daemon_config).await?;

    // Get current environment state
    let state_manager = daemon.state_manager();
    let state_guard = state_manager.read().await;
    let current_state = state_guard.get_current_state().await?;

    if current_state.is_active() {
        info!("Cleaning environment: {}", env_name);
        
        // Create a Python environment instance
        let env = blast_core::python::PythonEnvironment::new(
            config.project_root.join("environments").join(&env_name),
            current_state.python_version.clone(),
        );
        
        // Clean the environment
        daemon.clean_environment(&env).await?;
        
        // Reinitialize environment
        daemon.reinitialize_environment(&env).await?;

        info!("Environment cleaned and reinitialized");
    } else {
        info!("No active environment found");
    }

    Ok(())
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cli/src/commands/register.rs

```rs
use std::path::PathBuf;
use blast_core::{
    config::BlastConfig,
    error::BlastResult,
    state::EnvironmentState,
    python::PythonVersion,
};
use blast_daemon::{Daemon, DaemonConfig};
use tracing::{debug, info};
use std::collections::HashMap;

pub async fn execute(
    name: String,
    path: PathBuf,
    config: &BlastConfig,
) -> BlastResult<()> {
    debug!("Registering environment: {} at {}", name, path.display());

    // Create daemon configuration
    let daemon_config = DaemonConfig {
        max_pending_updates: 100,
        max_snapshot_age_days: 7,
        env_path: path.clone(),
        cache_path: config.project_root.join("cache"),
    };

    // Connect to daemon
    let daemon = Daemon::new(daemon_config).await?;

    // Get Python version from environment
    let python_version = if let Ok(version) = std::env::var("BLAST_PYTHON_VERSION") {
        PythonVersion::parse(&version)?
    } else {
        // Default to Python 3.8 if not specified
        PythonVersion::parse("3.8")?
    };

    // Create environment state
    let env_state = EnvironmentState::new(
        name.clone(),
        python_version,
        HashMap::new(), // Empty packages initially
        HashMap::new(), // Empty env vars initially
    );

    // Update state manager
    let state_manager = daemon.state_manager();
    state_manager.write().await.update_current_state(env_state.clone())?;

    // Register as active environment
    daemon.register_active_environment(name.clone()).await?;

    info!("Successfully registered environment:");
    info!("  Name: {}", name);
    info!("  Path: {}", path.display());
    info!("  Python: {}", python_version);

    Ok(())
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cli/src/commands/save.rs

```rs
use std::io::{self, Write};
use blast_core::{
    config::BlastConfig,
    error::{BlastError, BlastResult},
    python::PythonEnvironment,
};
use blast_daemon::{Daemon, DaemonConfig};
use blast_image::{
    layer::{Layer as Image, LayerType},
    compression::{CompressionType, CompressionLevel},
    error::Error as ImageError,
};
use tracing::{debug, info, warn};

// Helper function to convert ImageError to BlastError
fn convert_image_error(err: ImageError) -> BlastError {
    BlastError::environment(err.to_string())
}

/// Execute the save command
pub async fn execute(name: Option<String>, config: &BlastConfig) -> BlastResult<()> {
    // Check if we're in a blast environment
    let env_name = match std::env::var("BLAST_ENV_NAME") {
        Ok(name) => name,
        Err(_) => {
            warn!("Not in a blast environment");
            return Ok(());
        }
    };

    // Get image name from parameter or prompt user
    let image_name = match name {
        Some(n) => n,
        None => {
            // Check if there's an existing image for this environment
            let blast_dir = config.project_root.join(".blast");
            let mut existing_name = None;
            
            if blast_dir.exists() {
                for entry in std::fs::read_dir(&blast_dir)? {
                    let entry = entry?;
                    let path = entry.path();
                    if path.is_file() && path.extension().map_or(false, |ext| ext == "blast") {
                        if let Ok(image) = Image::load(&path, &path).map_err(convert_image_error) {
                            if image.name == env_name {
                                existing_name = Some(env_name.clone());
                                break;
                            }
                        }
                    }
                }
            }
            
            if let Some(name) = existing_name {
                // If there's an existing image, use its name for updating
                name
            } else {
                // Prompt for name
                print!("Enter image name: ");
                io::stdout().flush()?;
                let mut input = String::new();
                io::stdin().read_line(&mut input)?;
                input.trim().to_string()
            }
        }
    };

    debug!("Saving environment image: {}", image_name);

    // Create .blast directory if it doesn't exist
    let blast_dir = config.project_root.join(".blast");
    if !blast_dir.exists() {
        std::fs::create_dir_all(&blast_dir)?;
    }

    // Create daemon configuration
    let daemon_config = DaemonConfig {
        max_pending_updates: 100,
        max_snapshot_age_days: 7,
        env_path: config.project_root.join("environments/default"),
        cache_path: config.project_root.join("cache"),
    };

    // Connect to daemon
    let daemon = Daemon::new(daemon_config).await?;

    // Get current environment state
    let state_manager = daemon.state_manager();
    let state_guard = state_manager.read().await;
    let current_state = state_guard.get_current_state().await?;

    if current_state.is_active() {
        // Create Python environment instance
        let env = PythonEnvironment::new(
            config.project_root.join("environments").join(&env_name),
            current_state.python_version.clone(),
        );

        // Create image from environment with options
        let mut image = Image::from_environment_with_options(
            &env,
            LayerType::Packages,
            CompressionType::Zstd,
            CompressionLevel::default(),
        ).map_err(convert_image_error)?;

        // Save image
        let image_path = blast_dir.join(&image_name);
        image.save(&image_path).map_err(convert_image_error)?;

        info!("Successfully saved environment image:");
        info!("  Name: {}", image_name);
        info!("  Environment: {}", env_name);
        info!("  Python: {}", env.python_version());
        info!("  Compression ratio: {:.2}x", image.compression_ratio());
        info!("  Total size: {} bytes", image.size());
        info!("  Path: {}", image_path.display());
    } else {
        warn!("No active environment found");
    }

    Ok(())
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cli/src/commands/mod.rs

```rs
//! CLI command implementations

pub mod start;
pub mod kill;
pub mod clean;
pub mod save;
pub mod load;
pub mod list;
pub mod check;

// Export command functions with clear names
pub use start::execute as execute_start;
pub use kill::execute as execute_kill;
pub use clean::execute as execute_clean;
pub use save::execute as execute_save;
pub use load::execute as execute_load;
pub use list::execute as execute_list;
pub use check::execute as execute_check; 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cli/src/commands/load.rs

```rs
use std::io::{self, Write};
use blast_core::{
    config::BlastConfig,
    error::{BlastError, BlastResult},
    security::SecurityPolicy,
};
use blast_daemon::{Daemon, DaemonConfig};
use blast_image::{
    layer::Layer as Image,
    error::Error as ImageError,
    Manifest,
};
use tracing::{debug, info, warn};

// Helper function to convert ImageError to BlastError
fn convert_image_error(err: ImageError) -> BlastError {
    BlastError::environment(err.to_string())
}

/// Execute the load command
pub async fn execute(name: Option<String>, config: &BlastConfig) -> BlastResult<()> {
    // Check if we're already in a blast environment
    if let Ok(current_env) = std::env::var("BLAST_ENV_NAME") {
        warn!("Already in blast environment: {}", current_env);
        warn!("Please run 'blast kill' first");
        return Ok(());
    }

    // Create daemon configuration
    let daemon_config = DaemonConfig {
        max_pending_updates: 100,
        max_snapshot_age_days: 7,
        env_path: config.project_root.join("environments/default"),
        cache_path: config.project_root.join("cache"),
    };

    // Connect to daemon
    let daemon = Daemon::new(daemon_config).await?;

    // Get list of available images from the .blast directory
    let blast_dir = config.project_root.join(".blast");
    let mut available_images = Vec::new();
    let mut manifests = Vec::new();

    if blast_dir.exists() {
        for entry in std::fs::read_dir(&blast_dir)? {
            let entry = entry?;
            let path = entry.path();
            if path.is_file() && path.extension().map_or(false, |ext| ext == "blast") {
                if let Ok(image) = Image::load(&path, &path).map_err(convert_image_error) {
                    // Load manifest from the same directory
                    let manifest_path = path.with_extension("toml");
                    if let Ok(manifest) = Manifest::load(manifest_path).await {
                        available_images.push(image);
                        manifests.push(manifest);
                    }
                }
            }
        }
    }

    if available_images.is_empty() {
        warn!("No saved images found");
        return Ok(());
    }

    // Determine which image to load
    let (image_idx, image_name) = match name {
        Some(n) => {
            // Verify the specified image exists
            if let Some((idx, _)) = available_images.iter().enumerate()
                .find(|(_, img)| img.name == n) {
                (idx, n)
            } else {
                warn!("Image not found: {}", n);
                return Ok(());
            }
        }
        None => {
            if available_images.len() == 1 {
                // Auto-load if only one image exists
                (0, available_images[0].name.clone())
            } else {
                // Show available images and prompt for selection
                info!("Available images:");
                for (i, (img, manifest)) in available_images.iter().zip(manifests.iter()).enumerate() {
                    info!(
                        "  {}. {} (created: {}, Python {})",
                        i + 1,
                        img.name,
                        img.metadata.created_at.format("%Y-%m-%d %H:%M:%S"),
                        manifest.metadata.python_version
                    );
                }

                print!("Enter image number to load (1-{}): ", available_images.len());
                io::stdout().flush()?;
                let mut input = String::new();
                io::stdin().read_line(&mut input)?;
                
                match input.trim().parse::<usize>() {
                    Ok(n) if n > 0 && n <= available_images.len() => {
                        (n - 1, available_images[n - 1].name.clone())
                    }
                    _ => {
                        warn!("Invalid selection");
                        return Ok(());
                    }
                }
            }
        }
    };

    let mut image = available_images.into_iter().nth(image_idx).unwrap();
    let manifest = manifests.into_iter().nth(image_idx).unwrap();
    
    debug!("Loading image: {}", image_name);

    // Create environment with image's Python version
    let policy = SecurityPolicy {
        python_version: manifest.metadata.python_version.clone(),
        ..SecurityPolicy::default()
    };
    
    let env = daemon.create_environment(&policy).await?;

    // Apply image contents to environment
    image.save(&env.path()).map_err(convert_image_error)?;

    // Activate the environment
    daemon.activate_environment(&image_name, manifest.metadata.python_version.clone()).await?;

    // Set up environment variables
    std::env::set_var("BLAST_ENV_NAME", &image_name);
    std::env::set_var("BLAST_ENV_PATH", env.path().display().to_string());
    std::env::set_var("BLAST_SOCKET_PATH", format!("/tmp/blast_{}.sock", &image_name));

    // Set up shell prompt
    if let Ok(shell) = std::env::var("SHELL") {
        if shell.contains("bash") {
            std::env::set_var("PS1", "(blast) $PS1");
        } else if shell.contains("zsh") {
            std::env::set_var("PROMPT", "(blast) $PROMPT");
        }
    }

    info!("Successfully loaded environment image:");
    info!("  Name: {}", image_name);
    info!("  Python: {}", env.python_version());
    info!("  Path: {}", env.path().display());
    info!("  Created: {}", image.metadata.created_at.to_rfc3339());

    Ok(())
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cli/src/commands/kill.rs

```rs
use blast_core::{
    config::BlastConfig,
    error::BlastResult,
};
use tracing::info;
use std::process::Command;

/// Execute the kill command
pub async fn execute(
    env_name: String,
    _force: bool,
    config: &BlastConfig,
) -> BlastResult<()> {
    let env_path = config.project_root.join("environments").join(&env_name);
    
    // Read PID file
    let pid_file = std::path::Path::new("/tmp/blast").join("daemon.pid");
    if pid_file.exists() {
        if let Ok(pid_str) = std::fs::read_to_string(&pid_file) {
            if let Ok(pid) = pid_str.trim().parse::<u32>() {
                // Kill the daemon process
                #[cfg(unix)]
                {
                    use nix::sys::signal::{kill, Signal};
                    use nix::unistd::Pid;
                    // First try SIGTERM
                    let _ = kill(Pid::from_raw(pid as i32), Signal::SIGTERM);
                    // Give it a moment to clean up
                    std::thread::sleep(std::time::Duration::from_millis(100));
                    // Force kill if still running
                    let _ = kill(Pid::from_raw(pid as i32), Signal::SIGKILL);
                }
                
                #[cfg(windows)]
                {
                    let _ = Command::new("taskkill")
                        .args(&["/PID", &pid.to_string(), "/F"])
                        .output();
                }
            }
        }
        // Clean up PID file
        let _ = std::fs::remove_file(&pid_file);
    }

    // Clean up environment variables
    std::env::remove_var("BLAST_ENV_NAME");
    std::env::remove_var("BLAST_ENV_PATH");
    std::env::remove_var("BLAST_SOCKET_PATH");
    std::env::remove_var("BLAST_DAEMON");
    std::env::remove_var("BLAST_EVAL");

    // Kill any running terminal processes
    if let Ok(ppid) = std::env::var("PPID") {
        if let Ok(ppid) = ppid.parse::<i32>() {
            #[cfg(unix)]
            {
                use nix::sys::signal::{kill, Signal};
                use nix::unistd::Pid;
                let _ = kill(Pid::from_raw(ppid), Signal::SIGTERM);
            }
        }
    }

    // Restore shell prompt
    if let Ok(shell) = std::env::var("SHELL") {
        if shell.contains("bash") || shell.contains("zsh") {
            println!("PS1=\"${{PS1#\\(blast\\) }}\"");
        } else if shell.contains("fish") {
            println!("functions -e fish_prompt; functions -c _old_fish_prompt fish_prompt");
        }
    }

    info!("Killed blast environment:");
    info!("  Name: {}", env_name);
    info!("  Path: {}", env_path.display());

    Ok(())
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cli/src/setup.rs

```rs
use std::path::PathBuf;
use blast_core::error::{BlastResult, BlastError};
use crate::shell::Shell;
use tracing::{info, debug};

const SHELL_FUNCTION: &str = r#"
# Blast environment manager shell integration
blast() {
    eval "$(blast-cli start "$@")"
}
"#;

pub struct ShellSetup {
    shell: Shell,
    config_file: PathBuf,
}

impl ShellSetup {
    pub fn new() -> BlastResult<Self> {
        let shell = Shell::detect();
        let home_dir = dirs::home_dir().ok_or_else(|| {
            BlastError::Config("Could not determine home directory".to_string())
        })?;

        let config_file = match shell {
            Shell::Bash => home_dir.join(".bashrc"),
            Shell::Zsh => home_dir.join(".zshrc"),
            Shell::Fish => home_dir.join(".config").join("fish").join("config.fish"),
            Shell::PowerShell => home_dir.join("Documents")
                .join("WindowsPowerShell")
                .join("Microsoft.PowerShell_profile.ps1"),
            Shell::Unknown => return Err(BlastError::Config("Unsupported shell".to_string())),
        };

        Ok(Self {
            shell,
            config_file,
        })
    }

    pub fn ensure_shell_integration(&self) -> BlastResult<bool> {
        // Check if integration already exists
        if self.is_already_configured()? {
            debug!("Shell integration already configured");
            return Ok(false);
        }

        // Add shell integration
        self.add_shell_integration()?;
        info!("Added blast shell integration to {}", self.config_file.display());
        
        Ok(true)
    }

    fn is_already_configured(&self) -> BlastResult<bool> {
        if !self.config_file.exists() {
            return Ok(false);
        }

        let content = std::fs::read_to_string(&self.config_file)?;
        Ok(content.contains("blast() {") || content.contains("function blast"))
    }

    fn add_shell_integration(&self) -> BlastResult<()> {
        let mut content = String::new();
        
        if self.config_file.exists() {
            content = std::fs::read_to_string(&self.config_file)?;
            if !content.ends_with('\n') {
                content.push('\n');
            }
        }

        // Create parent directories if they don't exist
        if let Some(parent) = self.config_file.parent() {
            std::fs::create_dir_all(parent)?;
        }

        // Add our shell function
        content.push_str(SHELL_FUNCTION);
        std::fs::write(&self.config_file, content)?;

        Ok(())
    }

    pub fn get_shell_reload_command(&self) -> &'static str {
        match self.shell {
            Shell::Bash => "source ~/.bashrc",
            Shell::Zsh => "source ~/.zshrc",
            Shell::Fish => "source ~/.config/fish/config.fish",
            Shell::PowerShell => ". $PROFILE",
            Shell::Unknown => "",
        }
    }
}

/// Initialize blast for first use
pub fn initialize() -> BlastResult<()> {
    let setup = ShellSetup::new()?;
    
    if setup.ensure_shell_integration()? {
        info!("Blast shell integration has been configured.");
        info!("To activate the changes, please run:");
        info!("    {}", setup.get_shell_reload_command());
    }

    Ok(())
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cache/Cargo.toml

```toml
[package]
name = "blast-cache"
version = "0.1.0"
edition = "2021"
authors = ["Blast Contributors"]
description = "Caching system for the Blast Python environment manager"
license = "MIT"

[dependencies]
# Internal dependencies
blast-core = { path = "../blast-core" }

# Async runtime
tokio = { workspace = true }
async-trait = { workspace = true }

# Error handling
thiserror = { workspace = true }
anyhow = { workspace = true }

# Serialization
serde = { workspace = true, features = ["derive"] }
serde_json = { workspace = true }

# Time
chrono = { version = "0.4", features = ["serde"] }

# Logging
tracing = { workspace = true }

# Filesystem
notify = { workspace = true }
walkdir = { workspace = true }
tempfile = { workspace = true }

# Compression
zstd = "0.13"
tar = "0.4"

# Hashing
blake3 = "1.5"
hex = "0.4"

# Caching
lru = "0.12"

[dev-dependencies]
tokio = { workspace = true, features = ["macros", "rt-multi-thread"] }
tempfile = { workspace = true }
proptest = { workspace = true } 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cache/src/compression.rs

```rs
use std::io::{Read, Write};
use std::sync::Arc;
use async_trait::async_trait;
use blast_core::error::{BlastError, BlastResult};
use crate::storage::CacheStorage;
use serde::{Serialize, Deserialize};

/// Compression level for cache entries
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum CompressionLevel {
    /// No compression
    None,
    /// Fast compression
    Fast,
    /// Default compression
    Default,
    /// Maximum compression
    Maximum,
}

impl CompressionLevel {
    fn to_level(&self) -> i32 {
        match self {
            CompressionLevel::None => 0,
            CompressionLevel::Fast => 1,
            CompressionLevel::Default => 3,
            CompressionLevel::Maximum => 19,
        }
    }
}

/// Compressed storage that compresses data before storing
pub struct CompressedStorage<S: CacheStorage + ?Sized> {
    inner: Arc<S>,
}

impl<S: CacheStorage + ?Sized> CompressedStorage<S> {
    /// Create new compressed storage
    pub fn new(inner: Arc<S>) -> Self {
        Self { inner }
    }
}

#[async_trait]
impl<S: CacheStorage + Send + Sync + ?Sized> CacheStorage for CompressedStorage<S> {
    async fn store(&self, hash: &blake3::Hash, data: &[u8]) -> BlastResult<()> {
        let compressed = compress(data, CompressionLevel::Default)?;
        self.inner.store(hash, &compressed).await
    }

    async fn load(&self, hash: &blake3::Hash) -> BlastResult<Vec<u8>> {
        let compressed = self.inner.load(hash).await?;
        decompress(&compressed)
    }

    async fn remove(&self, hash: &blake3::Hash) -> BlastResult<()> {
        self.inner.remove(hash).await
    }

    async fn clear(&self) -> BlastResult<()> {
        self.inner.clear().await
    }

    fn hash_path(&self, hash: &blake3::Hash) -> std::path::PathBuf {
        self.inner.hash_path(hash)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

/// Compress data using zstd
pub fn compress(data: &[u8], level: CompressionLevel) -> BlastResult<Vec<u8>> {
    let mut encoder = zstd::Encoder::new(Vec::new(), level.to_level())
        .map_err(|e| BlastError::cache(format!("Failed to create zstd encoder: {}", e)))?;
    
    encoder.write_all(data)
        .map_err(|e| BlastError::cache(format!("Failed to compress data: {}", e)))?;
    
    encoder.finish()
        .map_err(|e| BlastError::cache(format!("Failed to finish compression: {}", e)))
}

/// Decompress zstd compressed data
pub fn decompress(data: &[u8]) -> BlastResult<Vec<u8>> {
    let mut decoder = zstd::Decoder::new(data)
        .map_err(|e| BlastError::cache(format!("Failed to create zstd decoder: {}", e)))?;
    
    let mut decompressed = Vec::new();
    decoder.read_to_end(&mut decompressed)
        .map_err(|e| BlastError::cache(format!("Failed to decompress data: {}", e)))?;
    
    Ok(decompressed)
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cache/src/layered.rs

```rs
use std::collections::HashMap;
use std::path::PathBuf;
use std::time::SystemTime;
use std::sync::Arc;

use chrono;
use serde::{Deserialize, Serialize};
use async_trait::async_trait;

use blast_core::error::BlastResult;

use crate::compression::CompressionLevel;
use crate::memory::MemoryCacheStats;
use crate::disk::DiskCacheStats;
use crate::storage::CacheStorage;

/// Cache layer type
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum LayerType {
    /// Base layer containing Python interpreter
    Base,
    /// Layer containing installed packages
    Packages,
    /// Layer containing environment configuration
    Config,
    /// Layer containing user files
    Files,
}

/// Cache layer metadata
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum CacheLayer {
    /// Package layer (wheels, source distributions)
    Package {
        name: String,
        version: String,
        hash: String,
    },
    /// Built package layer
    Build {
        package: String,
        version: String,
        platform: String,
        python_version: String,
    },
    /// Environment snapshot layer
    Environment {
        name: String,
        python_version: String,
        timestamp: chrono::DateTime<chrono::Utc>,
    },
    /// Dependency resolution layer
    Resolution {
        requirements: Vec<String>,
        python_version: String,
        platform: String,
    },
    /// Image layer
    ImageLayer {
        hash: String,
        layer_type: LayerType,
        parent: Option<String>,
    },
}

/// Cache entry with metadata
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LayerCacheEntry {
    /// Layer type and metadata
    pub layer: CacheLayer,
    /// Content hash
    pub hash: String,
    /// Original size in bytes
    pub size: u64,
    /// Compressed size in bytes
    pub compressed_size: u64,
    /// Compression level used
    pub compression: CompressionLevel,
    /// Path to cached file
    pub path: PathBuf,
    /// Last access time
    pub accessed: SystemTime,
    /// Creation time
    pub created: SystemTime,
    /// Access count
    pub access_count: u64,
    /// Parent layer hash if any
    pub parent: Option<String>,
}

/// Cache size limits
#[derive(Debug, Clone)]
pub struct CacheSizeLimits {
    /// Maximum total size
    pub max_total_size: u64,
    /// Maximum size per layer type
    pub max_layer_sizes: HashMap<String, u64>,
    /// Target size after cleanup
    pub target_size: u64,
}

impl Default for CacheSizeLimits {
    fn default() -> Self {
        let mut max_layer_sizes = HashMap::new();
        // 1GB for packages
        max_layer_sizes.insert("package".to_string(), 1024 * 1024 * 1024);
        // 2GB for builds
        max_layer_sizes.insert("build".to_string(), 2 * 1024 * 1024 * 1024);
        // 5GB for environments
        max_layer_sizes.insert("environment".to_string(), 5 * 1024 * 1024 * 1024);
        // 100MB for resolutions
        max_layer_sizes.insert("resolution".to_string(), 100 * 1024 * 1024);
        // 10GB for image layers
        max_layer_sizes.insert("image".to_string(), 10 * 1024 * 1024 * 1024);

        Self {
            // 20GB total
            max_total_size: 20 * 1024 * 1024 * 1024,
            max_layer_sizes,
            // 80% of max size
            target_size: 16 * 1024 * 1024 * 1024,
        }
    }
}

/// Combined statistics for layered cache
#[derive(Debug, Clone)]
pub struct LayeredCacheStats {
    /// Memory cache statistics
    pub memory_stats: MemoryCacheStats,
    /// Disk cache statistics
    pub disk_stats: DiskCacheStats,
    /// Total cache size in bytes
    pub total_size: u64,
    /// Total number of cached items
    pub total_items: usize,
    /// Cache hit ratio (0.0-1.0)
    pub hit_ratio: f64,
}

/// Layered cache implementation
pub struct LayeredCache<M, D>
where
    M: CacheStorage + Send + Sync + ?Sized,
    D: CacheStorage + Send + Sync + ?Sized,
{
    memory: Arc<M>,
    disk: Arc<D>,
}

impl<M, D> LayeredCache<M, D>
where
    M: CacheStorage + Send + Sync + ?Sized,
    D: CacheStorage + Send + Sync + ?Sized,
{
    /// Create new layered cache
    pub fn new(memory: Arc<M>, disk: Arc<D>) -> Self {
        Self { memory, disk }
    }
}

#[async_trait]
impl<M, D> CacheStorage for LayeredCache<M, D>
where
    M: CacheStorage + Send + Sync + ?Sized,
    D: CacheStorage + Send + Sync + ?Sized,
{
    async fn store(&self, hash: &blake3::Hash, data: &[u8]) -> BlastResult<()> {
        // Store in both layers
        self.memory.store(hash, data).await?;
        self.disk.store(hash, data).await?;
        Ok(())
    }

    async fn load(&self, hash: &blake3::Hash) -> BlastResult<Vec<u8>> {
        // Try memory first
        match self.memory.load(hash).await {
            Ok(data) => Ok(data),
            Err(_) => {
                // Try disk and cache in memory if found
                let data = self.disk.load(hash).await?;
                let _ = self.memory.store(hash, &data).await;
                Ok(data)
            }
        }
    }

    async fn remove(&self, hash: &blake3::Hash) -> BlastResult<()> {
        // Remove from both layers
        let _ = self.memory.remove(hash).await;
        self.disk.remove(hash).await?;
        Ok(())
    }

    async fn clear(&self) -> BlastResult<()> {
        // Clear both layers
        self.memory.clear().await?;
        self.disk.clear().await?;
        Ok(())
    }

    fn hash_path(&self, hash: &blake3::Hash) -> std::path::PathBuf {
        self.disk.hash_path(hash)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

impl LayerCacheEntry {
    // Removing unused method layer_type_str
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cache/src/lib.rs

```rs
//! Caching system for the Blast Python environment manager.
//! 
//! This crate provides a high-performance, persistent caching system with
//! compression and atomic operations.

use std::path::PathBuf;
use std::sync::Arc;
use std::time::SystemTime;

use serde::{Deserialize, Serialize};
use tokio::sync::RwLock;
use hex;

use blast_core::error::{BlastError, BlastResult};

pub mod compression;
pub mod storage;
pub mod memory;
pub mod layered;
pub mod lru;
pub mod index;
pub mod disk;

use std::path::Path;
use memory::MemoryStorage;
use layered::LayeredCache;
use compression::CompressedStorage;
use lru::LRUCache;
use index::IndexedStorage;

// Re-export types
pub use layered::{CacheLayer, LayerType};
pub use compression::CompressionLevel;

pub use index::CacheIndex;
pub use storage::{CacheStorage, FileStorage};
pub use memory::{MemoryCache, MemoryCacheStats};

/// Wrapper for blake3::Hash that implements serialization
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct SerializableHash(String);

impl From<blake3::Hash> for SerializableHash {
    fn from(hash: blake3::Hash) -> Self {
        Self(hash.to_hex().to_string())
    }
}

impl TryFrom<SerializableHash> for blake3::Hash {
    type Error = BlastError;

    fn try_from(hash: SerializableHash) -> Result<Self, Self::Error> {
        let bytes = hex::decode(&hash.0)
            .map_err(|e| BlastError::cache(format!("Invalid hash: {}", e)))?;
        Ok(blake3::Hash::from_bytes(bytes.try_into().unwrap()))
    }
}

/// Cache entry with metadata
#[derive(Debug, Clone, Serialize, Deserialize)]
struct CacheEntry {
    /// Content hash
    hash: SerializableHash,
    /// Original size in bytes
    size: u64,
    /// Compressed size in bytes
    compressed_size: u64,
    /// Path to cached file
    path: PathBuf,
    /// Last access time
    accessed: SystemTime,
    /// Creation time
    created: SystemTime,
}

/// Cache builder for configuring cache options
pub struct CacheBuilder {
    path: Option<std::path::PathBuf>,
    memory_size: Option<usize>,
    compression: bool,
    indexed: bool,
}

impl CacheBuilder {
    /// Create new cache builder
    pub fn new() -> Self {
        Self {
            path: None,
            memory_size: None,
            compression: false,
            indexed: false,
        }
    }

    /// Set cache path
    pub fn path(mut self, path: impl AsRef<Path>) -> Self {
        self.path = Some(path.as_ref().to_path_buf());
        self
    }

    /// Set memory cache size
    pub fn memory_size(mut self, size: usize) -> Self {
        self.memory_size = Some(size);
        self
    }

    /// Enable compression
    pub fn compression(mut self, enabled: bool) -> Self {
        self.compression = enabled;
        self
    }

    /// Enable key indexing
    pub fn indexed(mut self, enabled: bool) -> Self {
        self.indexed = enabled;
        self
    }

    /// Build cache with current configuration
    pub async fn build(self) -> BlastResult<Cache> {
        let path = self.path.ok_or_else(|| {
            blast_core::error::BlastError::cache("Cache path not specified")
        })?;

        // Create base storage
        let disk = Arc::new(FileStorage::new(&path).await?);
        let memory = Arc::new(RwLock::new(MemoryStorage::new()));
        let layered = Arc::new(LayeredCache::new(memory, disk));

        // Add optional features
        let mut storage: Arc<dyn CacheStorage + Send + Sync> = layered;

        if self.compression {
            storage = Arc::new(CompressedStorage::new(storage));
        }

        if let Some(size) = self.memory_size {
            storage = Arc::new(LRUCache::new(storage, size));
        }

        if self.indexed {
            storage = Arc::new(IndexedStorage::new(storage));
        }

        Ok(Cache { storage })
    }
}

impl Default for CacheBuilder {
    fn default() -> Self {
        Self::new()
    }
}

/// Cache interface
pub struct Cache {
    storage: Arc<dyn CacheStorage + Send + Sync>,
}

impl Cache {
    /// Store data in cache
    pub async fn store(&self, hash: &blake3::Hash, data: &[u8]) -> BlastResult<()> {
        self.storage.store(hash, data).await
    }

    /// Load data from cache
    pub async fn load(&self, hash: &blake3::Hash) -> BlastResult<Vec<u8>> {
        self.storage.load(hash).await
    }

    /// Remove data from cache
    pub async fn remove(&self, hash: &blake3::Hash) -> BlastResult<()> {
        self.storage.remove(hash).await
    }

    /// Clear all cached data
    pub async fn clear(&self) -> BlastResult<()> {
        self.storage.clear().await
    }

    /// Store data with key
    pub async fn store_with_key(&self, key: &str, hash: &blake3::Hash, data: &[u8]) -> BlastResult<()> {
        if let Some(indexed) = self.storage.as_any().downcast_ref::<IndexedStorage<dyn CacheStorage + Send + Sync>>() {
            indexed.store_with_key(key, hash, data).await
        } else {
            Err(blast_core::error::BlastError::cache("Indexing not enabled"))
        }
    }

    /// Load data by key
    pub async fn load_by_key(&self, key: &str) -> BlastResult<Vec<u8>> {
        if let Some(indexed) = self.storage.as_any().downcast_ref::<IndexedStorage<dyn CacheStorage + Send + Sync>>() {
            indexed.load_by_key(key).await
        } else {
            Err(blast_core::error::BlastError::cache("Indexing not enabled"))
        }
    }

    /// Remove data by key
    pub async fn remove_by_key(&self, key: &str) -> BlastResult<()> {
        if let Some(indexed) = self.storage.as_any().downcast_ref::<IndexedStorage<dyn CacheStorage + Send + Sync>>() {
            indexed.remove_by_key(key).await
        } else {
            Err(blast_core::error::BlastError::cache("Indexing not enabled"))
        }
    }

    /// Check if compression is enabled
    pub fn is_compression_enabled(&self) -> bool {
        self.storage.as_any().is::<CompressedStorage<dyn CacheStorage + Send + Sync>>()
    }
}

/// Cache statistics
#[derive(Debug, Clone)]
pub struct CacheStats {
    pub total_entries: usize,
    pub total_size: u64,
    pub total_compressed_size: u64,
    pub compression_ratio: f64,
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cache/src/memory.rs

```rs
use std::time::{Duration, SystemTime};
use std::num::NonZeroUsize;
use tokio::sync::RwLock;
use lru::LruCache;
use blast_core::error::BlastResult;
use std::collections::HashMap;
use std::sync::Arc;
use async_trait::async_trait;
use blast_core::error::BlastError;
use crate::storage::CacheStorage;

/// Memory cache statistics
#[derive(Debug, Clone, Default)]
pub struct MemoryCacheStats {
    /// Number of cache hits
    pub hits: u64,
    /// Number of cache misses
    pub misses: u64,
    /// Memory usage in bytes
    pub memory_usage: usize,
    /// Number of items in cache
    pub items: usize,
    /// Number of evicted items
    pub evictions: u64,
}

/// Memory cache entry with TTL
#[derive(Clone)]
struct CacheEntry<V> {
    value: V,
    created: SystemTime,
    ttl: Option<Duration>,
}

/// Memory-based cache implementation
pub struct MemoryCache<K, V> {
    cache: RwLock<LruCache<K, CacheEntry<V>>>,
    stats: RwLock<MemoryCacheStats>,
}

impl<K: Clone + Eq + std::hash::Hash, V: Clone> MemoryCache<K, V> {
    /// Create new memory cache with given capacity
    pub fn new(capacity: usize) -> Self {
        Self {
            cache: RwLock::new(LruCache::new(NonZeroUsize::new(capacity).unwrap())),
            stats: RwLock::new(MemoryCacheStats::default()),
        }
    }

    /// Get value by key
    pub async fn get(&self, key: &K) -> Option<V> {
        let mut cache = self.cache.write().await;
        let mut stats = self.stats.write().await;
        
        if let Some(entry) = cache.get(key) {
            if let Some(ttl) = entry.ttl {
                if SystemTime::now().duration_since(entry.created).unwrap() > ttl {
                    cache.pop(key);
                    stats.misses += 1;
                    stats.evictions += 1;
                    return None;
                }
            }
            stats.hits += 1;
            Some(entry.value.clone())
        } else {
            stats.misses += 1;
            None
        }
    }

    /// Get cache statistics
    pub async fn stats(&self) -> MemoryCacheStats {
        self.stats.read().await.clone()
    }

    /// Put value with key
    pub async fn put(&self, key: K, value: V, ttl: Option<Duration>) -> BlastResult<()> {
        let mut cache = self.cache.write().await;
        let mut stats = self.stats.write().await;
        
        // Track evictions
        let old_len = cache.len();
        cache.put(key, CacheEntry {
            value,
            created: SystemTime::now(),
            ttl,
        });
        if cache.len() <= old_len {
            stats.evictions += 1;
        }
        
        stats.items = cache.len();
        stats.memory_usage = std::mem::size_of::<CacheEntry<V>>() * cache.len();
        Ok(())
    }

    /// Remove value by key
    pub async fn remove(&self, key: &K) -> BlastResult<()> {
        let mut cache = self.cache.write().await;
        let mut stats = self.stats.write().await;
        if cache.pop(key).is_some() {
            stats.evictions += 1;
        }
        Ok(())
    }

    /// Clear all entries
    pub async fn clear(&self) -> BlastResult<()> {
        let mut cache = self.cache.write().await;
        let mut stats = self.stats.write().await;
        stats.evictions += cache.len() as u64;
        cache.clear();
        Ok(())
    }

    /// Remove expired entries
    pub async fn cleanup(&self) -> BlastResult<()> {
        let mut cache = self.cache.write().await;
        let mut stats = self.stats.write().await;
        let now = SystemTime::now();
        let expired: Vec<_> = cache.iter()
            .filter(|(_, entry)| {
                entry.ttl.map_or(false, |ttl| {
                    now.duration_since(entry.created).unwrap() > ttl
                })
            })
            .map(|(k, _)| k.clone())
            .collect();
        
        stats.evictions += expired.len() as u64;
        for key in expired {
            cache.pop(&key);
        }
        Ok(())
    }
}

/// In-memory storage backend
#[derive(Debug)]
pub struct MemoryStorage {
    data: Arc<RwLock<HashMap<blake3::Hash, Vec<u8>>>>,
    size_limit: Option<usize>,
    current_size: usize,
}

impl MemoryStorage {
    /// Create new memory storage
    pub fn new() -> Self {
        Self {
            data: Arc::new(RwLock::new(HashMap::new())),
            size_limit: None,
            current_size: 0,
        }
    }

    /// Set size limit in bytes
    pub fn set_size_limit(&mut self, limit: usize) {
        self.size_limit = Some(limit);
    }

    /// Get current size in bytes
    pub fn size(&self) -> usize {
        self.current_size
    }
}

impl Default for MemoryStorage {
    fn default() -> Self {
        Self::new()
    }
}

#[async_trait]
impl CacheStorage for MemoryStorage {
    async fn store(&self, hash: &blake3::Hash, data: &[u8]) -> BlastResult<()> {
        let mut storage = self.data.write().await;
        
        // Check size limit
        if let Some(limit) = self.size_limit {
            if data.len() > limit {
                return Err(BlastError::cache("Data exceeds size limit"));
            }
        }

        storage.insert(*hash, data.to_vec());
        Ok(())
    }

    async fn load(&self, hash: &blake3::Hash) -> BlastResult<Vec<u8>> {
        let storage = self.data.read().await;
        storage
            .get(hash)
            .cloned()
            .ok_or_else(|| BlastError::cache("Data not found"))
    }

    async fn remove(&self, hash: &blake3::Hash) -> BlastResult<()> {
        let mut storage = self.data.write().await;
        storage.remove(hash);
        Ok(())
    }

    async fn clear(&self) -> BlastResult<()> {
        let mut storage = self.data.write().await;
        storage.clear();
        Ok(())
    }

    fn hash_path(&self, _hash: &blake3::Hash) -> std::path::PathBuf {
        // Memory storage doesn't use paths
        std::path::PathBuf::new()
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[async_trait]
impl CacheStorage for RwLock<MemoryStorage> {
    async fn store(&self, hash: &blake3::Hash, data: &[u8]) -> BlastResult<()> {
        self.write().await.store(hash, data).await
    }

    async fn load(&self, hash: &blake3::Hash) -> BlastResult<Vec<u8>> {
        self.read().await.load(hash).await
    }

    async fn remove(&self, hash: &blake3::Hash) -> BlastResult<()> {
        self.write().await.remove(hash).await
    }

    async fn clear(&self) -> BlastResult<()> {
        self.write().await.clear().await
    }

    fn hash_path(&self, _hash: &blake3::Hash) -> std::path::PathBuf {
        self.blocking_read().hash_path(_hash)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cache/src/index.rs

```rs
use std::collections::HashMap;
use std::path::{Path, PathBuf};
use std::time::SystemTime;
use std::sync::Arc;
use tokio::sync::RwLock;
use tokio::fs;
use serde::{Deserialize, Serialize};
use async_trait::async_trait;

use blast_core::error::BlastResult;
use crate::storage::CacheStorage;
use crate::SerializableHash;

/// Cache entry in the index
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CacheEntry {
    /// Content hash
    pub hash: SerializableHash,
    /// Original size in bytes
    pub size: u64,
    /// Compressed size in bytes
    pub compressed_size: u64,
    /// Path to cached file
    pub path: PathBuf,
    /// Last access time
    pub accessed: SystemTime,
    /// Creation time
    pub created: SystemTime,
}

/// Index of cached items
#[derive(Debug, Default, Serialize, Deserialize)]
pub struct CacheIndex {
    /// Cached entries by key
    entries: HashMap<String, CacheEntry>,
    /// Path to index file
    #[serde(skip)]
    path: Option<PathBuf>,
}

impl CacheIndex {
    /// Load index from file or create new if not exists
    pub async fn load_or_create(cache_dir: impl AsRef<Path>) -> BlastResult<Self> {
        let path = cache_dir.as_ref().join("index.json");
        
        if path.exists() {
            let data = fs::read(&path).await?;
            let mut index: Self = serde_json::from_slice(&data)?;
            index.path = Some(path);
            Ok(index)
        } else {
            let mut index = Self::default();
            index.path = Some(path);
            index.save().await?;
            Ok(index)
        }
    }

    /// Save index to file
    pub async fn save(&self) -> BlastResult<()> {
        if let Some(path) = &self.path {
            let data = serde_json::to_vec_pretty(self)?;
            fs::write(path, data).await?;
        }
        Ok(())
    }

    /// Insert entry into index
    pub fn insert(&mut self, key: String, entry: CacheEntry) {
        self.entries.insert(key, entry);
    }

    /// Get entry by key
    pub fn get(&self, key: &str) -> Option<&CacheEntry> {
        self.entries.get(key)
    }

    /// Get mutable entry by key
    pub fn get_mut(&mut self, key: &str) -> Option<&mut CacheEntry> {
        self.entries.get_mut(key)
    }

    /// Remove entry by key
    pub fn remove(&mut self, key: &str) -> Option<CacheEntry> {
        self.entries.remove(key)
    }

    /// Clear all entries
    pub fn clear(&mut self) {
        self.entries.clear();
    }

    /// Get number of entries
    pub fn len(&self) -> usize {
        self.entries.len()
    }

    /// Get total size of cached items
    pub fn total_size(&self) -> u64 {
        self.entries.values().map(|e| e.size).sum()
    }

    /// Get total compressed size
    pub fn total_compressed_size(&self) -> u64 {
        self.entries.values().map(|e| e.compressed_size).sum()
    }

    /// Get compression ratio
    pub fn compression_ratio(&self) -> f64 {
        let total = self.total_size();
        let compressed = self.total_compressed_size();
        if total > 0 {
            compressed as f64 / total as f64
        } else {
            1.0
        }
    }
}

/// Storage wrapper that adds key-based indexing
pub struct IndexedStorage<S: CacheStorage + ?Sized> {
    inner: Arc<S>,
    index: RwLock<HashMap<String, blake3::Hash>>,
}

impl<S: CacheStorage + ?Sized> IndexedStorage<S> {
    /// Create new indexed storage
    pub fn new(inner: Arc<S>) -> Self {
        Self {
            inner,
            index: RwLock::new(HashMap::new()),
        }
    }

    /// Store data with key
    pub async fn store_with_key(&self, key: &str, hash: &blake3::Hash, data: &[u8]) -> BlastResult<()> {
        self.inner.store(hash, data).await?;
        self.index.write().await.insert(key.to_string(), *hash);
        Ok(())
    }

    /// Load data by key
    pub async fn load_by_key(&self, key: &str) -> BlastResult<Vec<u8>> {
        let index = self.index.read().await;
        let hash = index.get(key).ok_or_else(|| {
            blast_core::error::BlastError::cache("Key not found")
        })?;
        self.inner.load(hash).await
    }

    /// Remove data by key
    pub async fn remove_by_key(&self, key: &str) -> BlastResult<()> {
        if let Some(hash) = self.index.write().await.remove(key) {
            self.inner.remove(&hash).await?;
        }
        Ok(())
    }
}

#[async_trait]
impl<S: CacheStorage + ?Sized> CacheStorage for IndexedStorage<S> {
    async fn store(&self, hash: &blake3::Hash, data: &[u8]) -> BlastResult<()> {
        self.inner.store(hash, data).await
    }

    async fn load(&self, hash: &blake3::Hash) -> BlastResult<Vec<u8>> {
        self.inner.load(hash).await
    }

    async fn remove(&self, hash: &blake3::Hash) -> BlastResult<()> {
        self.inner.remove(hash).await
    }

    async fn clear(&self) -> BlastResult<()> {
        self.inner.clear().await?;
        self.index.write().await.clear();
        Ok(())
    }

    fn hash_path(&self, hash: &blake3::Hash) -> PathBuf {
        self.inner.hash_path(hash)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cache/src/disk.rs

```rs
use std::path::Path;
use blast_core::error::BlastResult;
use crate::storage::{CacheStorage, FileStorage};

/// Statistics for disk cache
#[derive(Debug, Clone, Default)]
pub struct DiskCacheStats {
    /// Number of cache hits
    pub hits: u64,
    /// Number of cache misses
    pub misses: u64,
    /// Total size in bytes
    pub total_size: u64,
    /// Number of items in cache
    pub items: usize,
}

/// Disk-based cache implementation
pub struct DiskCache {
    storage: FileStorage,
    stats: DiskCacheStats,
}

impl DiskCache {
    /// Create new disk cache at given path
    pub async fn new(path: impl AsRef<Path>, _max_size: u64) -> BlastResult<Self> {
        Ok(Self {
            storage: FileStorage::new(path).await?,
            stats: DiskCacheStats::default(),
        })
    }

    /// Get layer data by hash
    pub async fn get_layer(&mut self, hash: &str) -> BlastResult<Option<Vec<u8>>> {
        let hash = blake3::hash(hash.as_bytes());
        match CacheStorage::load(&self.storage, &hash).await {
            Ok(data) => {
                self.stats.hits += 1;
                Ok(Some(data))
            }
            Err(_) => {
                self.stats.misses += 1;
                Ok(None)
            }
        }
    }

    /// Store layer data with hash
    pub async fn put_layer(&mut self, hash: &str, data: Vec<u8>) -> BlastResult<()> {
        let hash = blake3::hash(hash.as_bytes());
        CacheStorage::store(&self.storage, &hash, &data).await?;
        self.stats.total_size += data.len() as u64;
        self.stats.items += 1;
        Ok(())
    }

    /// Remove layer by hash
    pub async fn remove_layer(&self, hash: &str) -> BlastResult<()> {
        let hash = blake3::hash(hash.as_bytes());
        CacheStorage::remove(&self.storage, &hash).await
    }

    /// Clean up expired or invalid layers
    pub async fn cleanup(&self) -> BlastResult<()> {
        CacheStorage::clear(&self.storage).await
    }

    /// Get cache statistics
    pub fn stats(&self) -> DiskCacheStats {
        self.stats.clone()
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cache/src/storage.rs

```rs
use std::path::{Path, PathBuf};
use tokio::fs;
use async_trait::async_trait;
use blast_core::error::BlastResult;
use std::any::Any;

/// Storage backend for cache data
#[async_trait]
pub trait CacheStorage: Send + Sync + Any {
    /// Store data with given hash
    async fn store(&self, hash: &blake3::Hash, data: &[u8]) -> BlastResult<()>;

    /// Load data for given hash
    async fn load(&self, hash: &blake3::Hash) -> BlastResult<Vec<u8>>;

    /// Remove data for given hash
    async fn remove(&self, hash: &blake3::Hash) -> BlastResult<()>;

    /// Clear all stored data
    async fn clear(&self) -> BlastResult<()>;

    /// Get the path for a given hash
    fn hash_path(&self, hash: &blake3::Hash) -> PathBuf;

    /// Get as Any for downcasting
    fn as_any(&self) -> &dyn Any;
}

/// File-based storage backend
#[derive(Debug)]
pub struct FileStorage {
    path: PathBuf,
}

impl FileStorage {
    /// Create new file storage at path
    pub async fn new(path: impl AsRef<Path>) -> BlastResult<Self> {
        let path = path.as_ref().to_path_buf();
        fs::create_dir_all(&path).await?;
        Ok(Self { path })
    }

    /// Get file path for hash
    fn hash_path(&self, hash: &blake3::Hash) -> PathBuf {
        let hex = hash.to_hex().to_string();
        self.path.join(&hex[0..2]).join(&hex[2..])
    }
}

#[async_trait]
impl CacheStorage for FileStorage {
    async fn store(&self, hash: &blake3::Hash, data: &[u8]) -> BlastResult<()> {
        let path = self.hash_path(hash);
        fs::write(path, data).await?;
        Ok(())
    }

    async fn load(&self, hash: &blake3::Hash) -> BlastResult<Vec<u8>> {
        let path = self.hash_path(hash);
        fs::read(path).await.map_err(Into::into)
    }

    async fn remove(&self, hash: &blake3::Hash) -> BlastResult<()> {
        let path = self.hash_path(hash);
        fs::remove_file(path).await?;
        Ok(())
    }

    async fn clear(&self) -> BlastResult<()> {
        let mut entries = fs::read_dir(&self.path).await?;
        while let Some(entry) = entries.next_entry().await? {
            fs::remove_file(entry.path()).await?;
        }
        Ok(())
    }

    fn hash_path(&self, hash: &blake3::Hash) -> PathBuf {
        let hex = hash.to_hex().to_string();
        self.path.join(&hex[0..2]).join(&hex[2..])
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
} 
```

## File: /Users/saint/Desktop/blast-rs/crates/blast-cache/src/lru.rs

```rs
use std::sync::Arc;
use std::time::{Duration, Instant};
use std::collections::{HashMap, VecDeque};
use async_trait::async_trait;
use blast_core::error::BlastResult;
use crate::storage::CacheStorage;

/// LRU cache entry
#[derive(Clone)]
pub struct LruEntry<V> {
    /// Stored value
    pub value: V,
    /// When the entry was created
    pub created: Instant,
    /// Time-to-live duration
    pub ttl: Duration,
    /// Number of times this entry was accessed
    pub hits: u64,
}

/// LRU cache implementation
pub struct LruCache<K, V> {
    /// Maximum number of entries
    capacity: usize,
    /// Stored entries
    entries: HashMap<K, LruEntry<V>>,
    /// LRU ordering (most recently used at front)
    lru_list: VecDeque<K>,
}

impl<K, V> LruCache<K, V>
where
    K: Clone + Eq + std::hash::Hash,
{
    /// Create new LRU cache with given capacity
    pub fn new(capacity: usize) -> Self {
        Self {
            capacity,
            entries: HashMap::new(),
            lru_list: VecDeque::new(),
        }
    }

    /// Get entry by key
    pub fn get(&mut self, key: &K) -> Option<LruEntry<V>>
    where
        V: Clone,
    {
        // First check if the entry exists and clone it
        let entry = match self.entries.get(key) {
            Some(e) => e.clone(),
            None => return None,
        };

        // Check if expired
        if entry.created.elapsed() > entry.ttl {
            self.remove(key);
            return None;
        }

        // Update LRU order
        if let Some(pos) = self.lru_list.iter().position(|k| k == key) {
            self.lru_list.remove(pos);
            self.lru_list.push_front(key.clone());
        }

        // Update hit count
        if let Some(entry) = self.entries.get_mut(key) {
            entry.hits += 1;
        }

        Some(entry)
    }

    /// Put entry in cache
    pub fn put(&mut self, key: K, value: V, ttl: Duration) {
        let entry = LruEntry {
            value,
            created: Instant::now(),
            ttl,
            hits: 0,
        };

        // Remove oldest if at capacity
        if self.entries.len() >= self.capacity {
            if let Some(lru_key) = self.lru_list.pop_back() {
                self.entries.remove(&lru_key);
            }
        }

        // Add new entry
        self.entries.insert(key.clone(), entry);
        self.lru_list.push_front(key);
    }

    /// Remove entry by key
    pub fn remove(&mut self, key: &K) -> Option<LruEntry<V>> {
        if let Some(pos) = self.lru_list.iter().position(|k| k == key) {
            self.lru_list.remove(pos);
        }
        self.entries.remove(key)
    }

    /// Remove and return least recently used entry
    pub fn pop_lru(&mut self) -> Option<(K, LruEntry<V>)> {
        if let Some(key) = self.lru_list.pop_back() {
            if let Some(entry) = self.entries.remove(&key) {
                return Some((key, entry));
            }
        }
        None
    }

    /// Clear all entries
    pub fn clear(&mut self) {
        self.entries.clear();
        self.lru_list.clear();
    }

    /// Get number of entries
    pub fn len(&self) -> usize {
        self.entries.len()
    }

    /// Check if cache is empty
    pub fn is_empty(&self) -> bool {
        self.entries.is_empty()
    }

    /// Get iterator over entries
    pub fn iter(&self) -> impl Iterator<Item = (&K, &LruEntry<V>)> {
        self.entries.iter()
    }
}

/// LRU cache storage implementation
pub struct LRUCache<S: CacheStorage + ?Sized> {
    inner: Arc<S>,
    capacity: usize,
    items: lru::LruCache<blake3::Hash, ()>,
}

impl<S: CacheStorage + ?Sized> LRUCache<S> {
    /// Create new LRU cache with given capacity
    pub fn new(inner: Arc<S>, capacity: usize) -> Self {
        Self {
            inner,
            capacity,
            items: lru::LruCache::new(std::num::NonZeroUsize::new(capacity).unwrap()),
        }
    }
}

#[async_trait]
impl<S: CacheStorage + Send + Sync + ?Sized> CacheStorage for LRUCache<S> {
    async fn store(&self, hash: &blake3::Hash, data: &[u8]) -> BlastResult<()> {
        // Store in inner storage
        self.inner.store(hash, data).await?;

        // Update LRU cache
        let mut items = self.items.clone();
        if items.len() >= self.capacity {
            if let Some((old_hash, _)) = items.pop_lru() {
                let _ = self.inner.remove(&old_hash).await;
            }
        }
        items.put(*hash, ());

        Ok(())
    }

    async fn load(&self, hash: &blake3::Hash) -> BlastResult<Vec<u8>> {
        // Update LRU status
        let mut items = self.items.clone();
        if items.get(hash).is_some() {
            let data = self.inner.load(hash).await?;
            items.promote(hash);
            Ok(data)
        } else {
            Err(blast_core::error::BlastError::cache("Data not found"))
        }
    }

    async fn remove(&self, hash: &blake3::Hash) -> BlastResult<()> {
        let mut items = self.items.clone();
        items.pop(hash);
        self.inner.remove(hash).await
    }

    async fn clear(&self) -> BlastResult<()> {
        let mut items = self.items.clone();
        items.clear();
        self.inner.clear().await
    }

    fn hash_path(&self, hash: &blake3::Hash) -> std::path::PathBuf {
        self.inner.hash_path(hash)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
} 
```



---

> 📸 Generated with [Jockey CLI](https://github.com/saint0x/jockey-cli)
